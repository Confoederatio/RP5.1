//Discord initialisation
const Discord = require("discord.js");
const { prefix, token } = require('./config.json');
const client = new Discord.Client();

const Canvas = require("canvas");

//Node.js imports
var fs = require('fs'),
	path = require('path'),
	_ = require('underscore');
	
var backup_array = fs.readdirSync("./backups/");

backup_array.sort(function(a, b) {
	return fs.statSync("./backups/" + a).mtime.getTime() - fs.statSync("./backups/" + b).mtime.getTime();
});

console.log("[Triumph & Tragedy]: Backup Array: " + backup_array);

//Other imports	
function getMostRecentFile (dir) {
    var files = fs.readdirSync(dir);

    // use underscore for max()
    return _.max(files, function (f) {
        var fullpath = path.join(dir, f);

        // ctime = creation time is used
        // replace with mtime for modification time
        return fs.statSync(fullpath).ctime;
    });
}

function returnChannel (arg0) {
	return client.channels.cache.get(arg0);
}

Array.prototype.remove = function() {
    var what, a = arguments, L = a.length, ax;
    while (L && this.length) {
        what = a[--L];
        while ((ax = this.indexOf(what)) !== -1) {
            this.splice(ax, 1);
        }
    }
    return this;
};

function readConfig () {
	let rawconfig = fs.readFileSync('config.txt');
	eval(rawconfig.toString());
}

//Bot settings
{
	bot_prefix = "$";
	start_date = new Date(2020, 03, 26, 16, 09);
	turn_timer = 60;
	announcements_channel = "701470100674576475";
	authorised_role = "";
}

readConfig();

let rawdata = fs.readFileSync('database.js');
let main;

function loadMostRecentSave () {
	//ABRS - Automated Backup and Restoration System (ABRS)
	if (rawdata.toString().length != 0) {
		main = JSON.parse(rawdata);
	} else {
		for (var i = 0; i < backup_array.length; i++) {
			let current_backup = fs.readFileSync("./backups/" + backup_array[i]);
			if (current_backup.toString().length != 0) {
				main = JSON.parse(current_backup);
				//returnChannel(announcements_channel).send("A backup from **" + backup_array[i] + "** was automatically restored.");
			}
		}
	}
}
var original_svg = fs.readFileSync("./maps/sample_test.svg", "utf8");

loadMostRecentSave();

client.once('ready', () => {
	console.log("[Triumph & Tragedy] is ready. Hello!");
});

client.login('<INSERT_TOKEN_HERE>');

client.on('ready', () => {
	client.user.setPresence({ activity: { name: "Triumph & Tragedy"}, status: 'online'}).then(console.log).catch(console.error);
})

function randomNumber(min, max) {  
	return Math.floor(Math.random() * (max - min) + min); 
}

var localisation = ["MISSING_LOC_STRING"];

function getLoc (index) {
	var loc_element = 0;
	if (index != undefined) {
		loc_element = index;
	}
	
	return localisation[(localisation.length-1)-loc_element];
}

var config = {
	//Resources
	materials: ["coal","food","gold","iron","knowledge","lead","petroil","steel","stone","wood"],
	raw_resources: ["coal","food","gold","iron","knowledge","lead","stone","wood"],
	mineable_materials: ["coal", "gold", "iron", "iron", "iron", "lead", "petroil", "stone", "stone"],
	
	//Buildings
	building_categories: ["industry","food_production","raw_production_facilities","military_buildings","research_buildings"],
	buildings: ["guilds","workshops","watermills","manufactories","mills","factories","arsenals","assembly_plants","industrial_complexes", "civilian_industries","wartime_industries","production_facilities","modern_financial_centres","ai_hubs","farms","centralised_farms","modern_farms","industrial_farms","vertical_farms","coal_mines","gold_mines","iron_mines","lead_mines","quarries","lumberjacks","steelworks","refineries","ack_ack_guns","aeroports","artillery_factories","auto_plants","barracks","dockyards","schools","libraries","universities","research_labs","research_complexes"],
	
	industry: ["guilds","workshops","watermills","manufactories","mills","factories","arsenals","assembly_plants","industrial_complexes", "civilian_industries","wartime_industries","production_facilities","modern_financial_centres","ai_hubs"],
	food_production: ["farms","centralised_farms","modern_farms","industrial_farms","vertical_farms"],
	raw_production_facilities: ["coal_mines","gold_mines","iron_mines","lead_mines","quarries","lumberjacks","steelworks","refineries"],
	military_buildings: ["ack_ack_guns","aeroports","artillery_factories","auto_plants","barracks","dockyards"],
	research_buildings: ["schools","libraries","universities","research_labs","research_complexes"],
	
	building_stats: {
		//Action buildings
		guilds: {
			name: "Guilds",
			singular: "Guild",
			icon: "<:workers:732730754735276124>",
			category: "industry",
			
			costs: [[2, "iron"], [2, "wood"], [3, "stone"], [2500, "money"], [65000, "workers"]],
			produces: [[1, "actions"]]
		},
		workshops: {
			name: "Workshops",
			singular: "Workshop",
			icon: "<:trade:716828677115084812>",
			category: "industry",
			
			costs: [[3, "iron"], [2, "wood"], [1, "lead"], [5, "stone"], [5000, "money"], [55000, "workers"]],
			produces: [[[2,3], "actions"]]
		},
		watermills: {
			name: "Watermills",
			singular: "Watermill",
			icon: "<:paper:759161240987369522>",
			category: "industry",
			
			costs: [[5, "stone"], [3, "wood"], [1, "lead"], [6500, "money"], [20000, "workers"]],
			produces: [[[3,5], "actions"]]
		},
		manufactories: {
			name: "Manufactories",
			singular: "Manufactory",
			icon: "<:development:716811992421367869>",
			category: "industry",
			
			costs: [[8, "stone"], [5, "iron"], [3, "wood"], [7500, "money"], [30000, "workers"]],
			produces: [[[4,6], "actions"]]
		},
		mills: {
			name: "Mills",
			singular: "Mill",
			icon: "<:government:716817688693047306>",
			category: "industry",
			
			costs: [[12, "stone"], [5, "wood"], [3, "iron"], [2, "lead"], [8000, "money"], [30000, "workers"]],
			produces: [[[5,7], "actions"]]
		},
		factories: {
			name: "Factories",
			singular: "Factory",
			icon: "<:factory:759161240601493525>",
			category: "industry",
			
			costs: [[5, "iron"], [10, "stone"], [5, "wood"], [5, "coal"], [10000, "money"], [50000, "workers"]],
			produces: [[[7,10], "actions"]]
		},
		arsenals: {
			name: "Arsenals",
			singular: "Arsenal",
			icon: "<:coal:716791408714973204>",
			category: "industry",
			
			costs: [[3, "steel"], [5, "iron"], [15, "stone"], [7, "wood"], [5, "coal"], [10000, "money"], [50000, "workers"]],
			produces: [[[10,12], "actions"]]
		},
		assembly_plants: {
			name: "Assembly Plants",
			singular: "Assembly Plant",
			icon: "<:artillery_piece:759161240999952445>",
			category: "industry",
			
			costs: [[10, "steel"], [10, "stone"], [5, "petroil"], [20000, "money"], [40000, "workers"]],
			produces: [[[12,15], "actions"]]
		},
		industrial_complexes: {
			name: "Industrial Complexes",
			singular: "Industrial Complex",
			icon: "<:actions:716817688244256770>",
			category: "industry",
			
			costs: [[20, "steel"], [10, "stone"], [15, "petroil"], [50000, "money"], [55000, "workers"]],
			produces: [[[12,18], "actions"]]
		},
		civilian_industries: {
			name: "Civilian Industries",
			singular: "Civilian Factory",
			icon: "<:government_scroll:716828975175041054>",
			category: "industry",
			
			costs: [[25, "steel"], [15, "stone"], [5, "gold"], [10, "petroil"], [65000, "money"], [55000, "workers"]],
			produces: [[[15,20], "actions"]]
		},
		wartime_industries: {
			name: "Wartime Industries",
			singular: "Military Factory",
			icon: "<:land_vehicles:716821195215077406>",
			category: "industry",
			
			costs: [[25, "steel"], [15, "stone"], [5, "gold"], [10, "petroil"], [70000, "money"], [60000, "workers"]],
			produces: [[20, "ground_units_cp"], [20, "ground_artillery_cp"], [20, "ground_vehicles_cp"], [20, "aeroplanes_cp"], [20, "naval_units_cp"]]
		},
		production_facilities: {
			name: "Production Facilities",
			singular: "Production Facility",
			icon: "<:building:716827579650408538>",
			category: "industry",
			
			costs: [[15, "steel"], [5, "stone"], [5, "petroil"], [85000, "money"], [50000, "workers"]],
			produces: [[[20,25], "actions"]]
		},
		modern_financial_centres: {
			name: "Modern Financial Centres",
			singular: "Modern Financial Centre",
			icon: "<:taxes:716817688781127810>",
			category: "industry",
			
			costs: [[25, "steel"], [30, "stone"], [15, "petroil"], [150000, "money"], [50000, "workers"]],
			produces: [[[25,30], "actions"]]
		},
		ai_hubs: {
			name: "AI Hubs",
			singular: "AI Hub",
			icon: "<:money:716817688718213192>",
			category: "industry",
			
			costs: [[25, "steel"], [35, "gold"], [30, "stone"], [25, "petroil"], [200000, "money"], [35000, "workers"]],
			produces: [[[25,40], "actions"]]
		},
		//Farms
		farms: {
			name: "Farms",
			singular: "Farm",
			icon: "<:food:716797746715033602>",
			category: "food_production",
			
			costs: [[3, "wood"], [1, "iron"], [2000, "money"], [50000, "workers"]],
			produces: [[3, "food"]]
		},
		centralised_farms: {
			name: "Centralised Farms",
			singular: "Centralised Farm",
			icon: "<:food:716797746715033602>",
			category: "food_production",
			
			costs: [[5, "wood"], [3, "iron"], [7000, "money"], [35000, "workers"]],
			produces: [[5, "food"]]
		},
		modern_farms: {
			name: "Modern Farms",
			singular: "Modern Farm",
			icon: "<:food:716797746715033602>",
			category: "food_production",
			
			costs: [[8, "steel"], [5, "iron"], [1, "gold"], [25000, "money"], [30000, "workers"]],
			produces: [[7, "food"]]
		},
		industrial_farms: {
			name: "Industrial Farms",
			singular: "Industrial Farm",
			icon: "<:food:716797746715033602>",
			category: "food_production",
			
			costs: [[10, "steel"], [5, "wood"], [5, "iron"], [3, "gold"], [50000, "money"], [20000, "workers"]],
			produces: [[12, "food"]]
		},
		vertical_farms: {
			name: "Vertical Farms",
			singular: "Vertical Farm",
			icon: "<:food:716797746715033602>",
			category: "food_production",
			
			costs: [[15, "steel"], [10, "gold"], [150000, "money"], [1000, "workers"]],
			produces: [[15, "food"]]
		},
		//Raw Production Facilities
		coal_mines: {
			name: "Coal Mines",
			singular: "Coal Mine",
			icon: "<:coal:716791408714973204>",
			category: "raw_production_facilities",
			
			costs: [[5, "wood"], [5, "iron"], [15000, "money"], [70000, "workers"]],
			produces: [[5, "coal"]]
		},
		gold_mines: {
			name: "Gold Mines",
			singular: "Gold Mine",
			icon: "<:gold:716798541028261927>",
			category: "raw_production_facilities",
			
			costs: [[10, "wood"], [5, "iron"], [20000, "money"], [120000, "workers"]],
			produces: [[2, "gold"]]
		},
		iron_mines: {
			name: "Iron Mines",
			singular: "Iron Mine",
			icon: "<:iron:716791408819961866>",
			category: "raw_production_facilities",
			
			costs: [[7, "wood"], [5, "iron"], [20000, "money"], [100000, "workers"]],
			produces: [[3, "iron"]]
		},
		lead_mines: {
			name: "Lead Mines",
			singular: "Lead Mine",
			icon: "<:lead:716791408840671322>",
			category: "raw_production_facilities",
			
			costs: [[5, "wood"], [5, "iron"], [15000, "money"], [70000, "workers"]],
			produces: [[3, "lead"]]
		},
		quarries: {
			name: "Quarries",
			singular: "Quarry",
			icon: "<:stone:716796878649426020>",
			category: "raw_production_facilities",
			
			costs: [[5, "wood"], [2, "iron"], [2500, "money"], [50000, "workers"]],
			produces: [[5, "stone"]]
		},
		lumberjacks: {
			name: "Lumberjacks",
			singular: "Lumberjack",
			icon: "<:wood:716791408928751636>",
			category: "raw_production_facilities",
			
			costs: [[3, "wood"], [2, "stone"], [2, "iron"], [6000, "money"], [50000, "workers"]],
			produces: [[3, "wood"]]
		},
		steelworks: {
			name: "Steelworks",
			singular: "Steelwork",
			icon: "<:steel:716791408828088420>",
			category: "raw_production_facilities",
			
			costs: [[10, "wood"], [15, "stone"], [20, "iron"], [5, "coal"], [70000, "money"], [100000, "workers"]],
			produces: [[5, "steel"]],
			cost_per_turn: [[5, "coal"], [5, "iron"]]
		},
		refineries: {
			name: "Refineries",
			singular: "Refinery",
			icon: "<:petroil:716791408748658739>",
			category: "raw_production_facilities",
			
			costs: [[15, "steel"], [10, "coal"], [5, "stone"], [3, "gold"], [80000, "money"], [75000, "workers"]],
			produces: [[5, "petroil"]],
			cost_per_turn: [[1, "coal"]]
		},
		//Military Buildings
		ack_ack_guns: {
			name: "Ack-Ack Guns",
			singular: "Ack-Ack Gun",
			icon: "<:artillery_piece:759161240999952445>",
			category: "military_buildings",
			
			costs: [[3, "wood"], [3, "steel"], [3, "lead"], [1, "food"], [5000, "money"]]
		},
		aeroports: {
			name: "Aeroports",
			singular: "Aeroport",
			icon: "<:aeroplanes:716821195407884358>",
			category: "military_buildings",
			
			costs: [[20, "steel"], [15, "stone"], [10, "petroil"], [60000, "money"], [70000, "workers"]],
			produces: [[20, "aeroplanes_cp"]]
		},
		artillery_factories: {
			name: "Artillery Factories",
			singular: "Artillery Factory",
			icon: "<:artillery:716821195055431681>",
			category: "military_buildings",
			
			costs: [[5, "iron"], [10, "stone"], [5, "coal"], [25000, "money"], [50000, "workers"]],
			produces: [[20, "ground_artillery_cp"]]
		},
		auto_plants: {
			name: "Auto Plants",
			singular: "Auto Plant",
			icon: "<:land_vehicles:716821195215077406>",
			category: "military_buildings",
			
			costs: [[15, "steel"], [10, "stone"], [10, "petroil"], [5, "coal"], [80000, "money"], [100000, "workers"]],
			produces: [[20, "ground_vehicles_cp"]]
		},
		barracks: {
			name: "Barracks",
			singular: "Barracks",
			icon: "<:manpower:716817688705499177>",
			category: "military_buildings",
			
			costs: [[2, "wood"], [1, "iron"], [20000, "money"], [70000, "workers"]],
			produces: [[20, "ground_units_cp"]]
		},
		dockyards: {
			name: "Dockyards",
			singular: "Dockyard",
			icon: "<:naval_units:716821195277729832>",
			category: "military_buildings",
			
			costs: [[5, "wood"], [3, "iron"], [25000, "money"], [80000, "workers"]],
			produces: [[20, "naval_units_cp"]]
		},
		//Research Buildings
		schools: {
			name: "Schools",
			singular: "School",
			icon: "<:knowledge:716797747193446441>",
			category: "research_buildings",
			
			costs: [[3, "wood"], [2, "stone"], [5000, "money"], [5000, "faculty"]],
			produces: [[10, "knowledge"]]
		},
		libraries: {
			name: "Libraries",
			singular: "Library",
			icon: "<:old_scroll:716828676880334881>",
			category: "research_buildings",
			
			costs: [[2, "wood"], [5, "stone"], [7000, "money"], [10000, "faculty"]],
			produces: [[50, "knowledge"]]
		},
		universities: {
			name: "Universities",
			singular: "University",
			icon: "<:faculty:732730754911436830>",
			category: "research_buildings",
			
			costs: [[5, "wood"], [15, "stone"], [15000, "money"], [25000, "faculty"]],
			produces: [[100, "knowledge"]]
		},
		research_labs: {
			name: "Research Labs",
			singular: "Research Lab",
			icon: "<:government:716817688693047306>",
			category: "research_buildings",
			
			costs: [[25, "steel"], [10, "stone"], [5, "petroil"], [5, "gold"], [5, "lead"], [15000, "faculty"]],
			produces: [[500, "knowledge"]]
		},
		research_complexes: {
			name: "Research Complexes",
			singular: "Research Complex",
			icon: "<:technology:716812861514711040>",
			category: "research_buildings",
			
			costs: [[35, "steel"], [20, "stone"], [15, "gold"], [10, "petroil"], [5, "lead"], [35000, "faculty"]],
			produces: [[1000, "knowledge"]]
		}
	},
	
	//Units
	unit_categories: ["ground_units", "ground_artillery", "ground_vehicles", "aeroplanes", "naval_units", "colonists"],
	
	units: ["skirmishers","spearmen","swordsmen","knights","archers","longbowmen","pike_and_square","tercio","pike_and_shot","arquebusiers","snaplock_infantry","snaphaunce_infantry","matchlock_infantry","wheellock_infantry","flintlock_infantry","musketeers","line_infantry","fusiliers","napoleonic_infantry","rangers","guards","riflemen","marines","breechloaded_infantry","franc_tireurs","bolt_action_infantry","mg_companies","great_war_infantry","shock_troops","freikorps","motorised_infantry","paratroopers","special_forces","modern_infantry","combined_arms_infantry","contemporary_infantry","augmented_infantry","condottieri","early_modern_mercenaries","landsknecht","swiss_guards","lance_cavalry","heavy_cavalry","light_cavalry","cuirassiers","hussars","dragoons","uhlans","mounted_rifles","modern_cavalry","armoured_cars","armoured_personnel_carriers","half_tracks","troop_carriers","modern_armoured_cars","modern_apcs","landship","light_tanks","interwar_tanks","medium_tanks","heavy_tanks","tank_destroyers","improved_medium_tanks","modern_tanks","main_battle_tanks","modern_mbts","multirole_mbts","bombard","hand_cannons","long_cannons","field_culverins","demi_cannon","field_cannon","demi_culverins","minions","siege_artillery","mysorean_rockets","carronades","congreve_rockets","smoothbores","rifled_cannons","railwayguns","field_artillery","artillery_howitzers","mobile_artillery","long_range_artillery","modern_howitzers","self_propelled_artillery","rocket_artillery","railguns","directed_heat_weapons","caravels","galleons","men_of_war","ships_of_the_line","first_rate","frigates","steamboats","clippers","gunboats","ironclads","breastwork_monitors","destroyers","cruisers","pre_dreadnoughts","dreadnoughts","torpedo_boats","battlecruisers","submarines","air_carriers","battleships","aircraft_carriers","nuclear_submarines","supercarriers","modern_cruisers","modern_frigates","railgun_cruisers","reconaissance_balloons","dirigibles","zeppelins","biplanes","improved_biplanes","monoplane_fighters","propeller_fighters","fighters","advanced_fighters","rocket_interceptors","jet_fighters","multirole_fighters","drones","stealth_fighters","ai_multirole_fighters","early_bombers","monoplane_bombers","interwar_bombers","bombers","strategic_bombers","stealth_bombers","ai_bombers","scout_helicopters","multirole_helicopters","modern_helicopters","torpedo_bombers","naval_bombers","conquistadors","settlers","magistrates","colonists","magnates","administrators","bureaucrats"],
	
	ground_units: ["skirmishers","spearmen","swordsmen","knights","archers","longbowmen","pike_and_square","tercio","pike_and_shot","arquebusiers","snaplock_infantry","snaphaunce_infantry","matchlock_infantry","wheellock_infantry","flintlock_infantry","musketeers","line_infantry","fusiliers","napoleonic_infantry","rangers","guards","riflemen","marines","breechloaded_infantry","franc_tireurs","bolt_action_infantry","mg_companies","great_war_infantry","shock_troops","freikorps","motorised_infantry","paratroopers","special_forces","modern_infantry","combined_arms_infantry","contemporary_infantry","augmented_infantry","condottieri","early_modern_mercenaries","landsknecht","swiss_guards","lance_cavalry","heavy_cavalry","light_cavalry","cuirassiers","hussars","dragoons","uhlans","mounted_rifles"],
	ground_artillery: ["bombard","hand_cannons","long_cannons","field_culverins","demi_cannon","field_cannon","demi_culverins","minions","siege_artillery","mysorean_rockets","carronades","congreve_rockets","smoothbores","rifled_cannons","railwayguns","field_artillery","artillery_howitzers","mobile_artillery","long_range_artillery","modern_howitzers","self_propelled_artillery","rocket_artillery","railguns","directed_heat_weapons"],
	ground_vehicles: ["armoured_cars","armoured_personnel_carriers","half_tracks","troop_carriers","modern_armoured_cars","modern_apcs","landship","light_tanks","interwar_tanks","medium_tanks","heavy_tanks","tank_destroyers","improved_medium_tanks","modern_tanks","main_battle_tanks","modern_mbts","multirole_mbts"],
	aeroplanes: ["reconaissance_balloons","dirigibles","zeppelins","biplanes","improved_biplanes","monoplane_fighters","propeller_fighters","fighters","advanced_fighters","rocket_interceptors","jet_fighters","multirole_fighters","drones","stealth_fighters","ai_multirole_fighters","early_bombers","monoplane_bombers","interwar_bombers","bombers","strategic_bombers","stealth_bombers","ai_bombers","scout_helicopters","multirole_helicopters","modern_helicopters","torpedo_bombers","naval_bombers"],
	naval_units: ["caravels","galleons","men_of_war","ships_of_the_line","first_rate","frigates","steamboats","clippers","gunboats","ironclads","breastwork_monitors","destroyers","cruisers","pre_dreadnoughts","dreadnoughts","torpedo_boats","battlecruisers","submarines","air_carriers","battleships","aircraft_carriers","nuclear_submarines","supercarriers","modern_cruisers","modern_frigates","railgun_cruisers"],
	colonists: ["conquistadors","settlers","magistrates","colonists","magnates","administrators","bureaucrats"],
	
	//Icons and GFX
	resource_icons: ["<:coal:716791408714973204>","<:food:716797746715033602>","<:gold:716798541028261927>","<:iron:716791408819961866>","<:knowledge:716797747193446441>","<:lead:716791408840671322>","<:petroil:716791408748658739>","<:steel:716791408828088420>","<:stone:716796878649426020>","<:wood:716791408928751636>"], //Resource Icons
	unit_category_icons: ["<:active_personnel:716820390474940426>","<:artillery:716821195055431681>","<:land_vehicles:716821195215077406>","<:aeroplanes:716821195407884358>","<:naval_units:716821195277729832>","<:colonisation:716821194891853826>"],
	
	unit_stats: {
		//Mediaeval Infantry Units and Pike and Shot
		skirmishers: {
			name: "Skirmishers",
			ap: 1,
			dp: 3,
			mp: 2,
			ip: 1,
			quantity: 10000,
			costs: [[1, "wood"], [1, "iron"], [2, "food"], [500, "money"], [5, "ground_units_cp"], [10000, "soldiers"]]
		},
		spearmen: {
			name: "Spearmen",
			ap: 2,
			dp: 1,
			mp: 1,
			ip: 2,
			quantity: 10000,
			costs: [[2, "wood"], [1, "iron"], [2, "food"], [700, "money"], [5, "ground_units_cp"], [10000, "soldiers"]]
		},
		swordsmen: {
			name: "Swordsmen",
			ap: 3,
			dp: 2,
			mp: 0,
			ip: 3,
			quantity: 10000,
			costs: [[1, "wood"], [2, "iron"], [3, "food"], [1000, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		knights: {
			name: "Knights",
			ap: 5,
			dp: 1,
			mp: 2,
			ip: 2,
			quantity: 10000,
			costs: [[3, "iron"], [5, "food"], [2500, "money"], [20, "ground_units_cp"], [10000, "soldiers"]]
		},
		archers: {
			name: "Archers",
			ap: 2,
			dp: 1,
			mp: 1,
			ip: 3,
			quantity: 10000,
			costs: [[2, "wood"], [3, "food"], [1000, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		longbowmen: {
			name: "Longbowmen",
			ap: 3,
			dp: 1,
			mp: 1,
			ip: 2,
			quantity: 10000,
			costs: [[3, "wood"], [4, "food"], [2000, "money"], [20, "ground_units_cp"], [10000, "soldiers"]]
		},
		pike_and_square: {
			name: "Pike and Square",
			ap: 1,
			dp: 3,
			mp: 1,
			ip: 2,
			quantity: 10000,
			costs: [[1, "wood"], [2, "iron"], [3, "food"], [850, "money"], [5, "ground_units_cp"], [10000, "soldiers"]]
		},
		tercio: {
			name: "Tercio",
			ap: 6,
			dp: 4,
			mp: 1,
			ip: 2,
			quantity: 10000,
			costs: [[1, "wood"], [5, "iron"], [2, "lead"], [3, "food"], [2500, "money"], [5, "ground_units_cp"], [10000, "soldiers"]]
		},
		pike_and_shot: {
			name: "Pike and Shot",
			ap: 8,
			dp: 2,
			mp: 1,
			ip: 2,
			quantity: 10000,
			costs: [[1, "wood"], [6, "iron"], [3, "lead"], [5, "food"], [3000, "money"], [5, "ground_units_cp"], [10000, "soldiers"]]
		},
		//Early Modern Ranged Units
		arquebusiers: {
			name: "Arquebusiers",
			ap: 4,
			dp: 1,
			mp: 2,
			ip: 2,
			quantity: 10000,
			costs: [[1, "wood"], [1, "iron"], [1, "lead"], [2, "food"], [1500, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		snaplock_infantry: {
			name: "Snaplock Infantry",
			ap: 5,
			dp: 1,
			mp: 2,
			ip: 2,
			quantity: 10000,
			costs: [[1, "wood"], [2, "iron"], [1, "lead"], [2, "food"], [1500, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		snaphaunce_infantry: {
			name: "Snaphaunce Infantry",
			ap: 5,
			dp: 2,
			mp: 3,
			ip: 3,
			quantity: 10000,
			costs: [[1, "wood"], [2, "iron"], [1, "lead"], [2, "food"], [1500, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		matchlock_infantry: {
			name: "Matchlock Infantry",
			ap: 6,
			dp: 2,
			mp: 2,
			ip: 3,
			quantity: 10000,
			costs: [[2, "wood"], [2, "iron"], [1, "lead"], [3, "food"], [2000, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		wheellock_infantry: {
			name: "Wheellock Infantry",
			ap: 6,
			dp: 3,
			mp: 1,
			ip: 4,
			quantity: 10000,
			costs: [[1, "wood"], [2, "iron"], [1, "lead"], [3, "food"], [2000, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		flintlock_infantry: {
			name: "Flintlock Infantry",
			ap: 10,
			dp: 2,
			mp: 1,
			ip: 5,
			quantity: 10000,
			costs: [[1, "wood"], [3, "iron"], [1, "lead"], [3, "food"], [1500, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		musketeers: {
			name: "Musketeers",
			ap: 12,
			dp: 5,
			mp: 1,
			ip: 5,
			quantity: 10000,
			costs: [[1, "wood"], [3, "iron"], [2, "lead"], [4, "food"], [1000, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		line_infantry: {
			name: "Line Infantry",
			ap: 15,
			dp: 4,
			mp: 0,
			ip: 5,
			quantity: 10000,
			costs: [[1, "wood"], [3, "iron"], [1, "lead"], [2, "food"], [1000, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		fusiliers: {
			name: "Fusiliers",
			ap: 18,
			dp: 6,
			mp: 1,
			ip: 6,
			quantity: 10000,
			costs: [[1, "wood"], [2, "iron"], [2, "lead"], [4, "food"], [3500, "money"], [20, "ground_units_cp"], [10000, "soldiers"]]
		},
		napoleonic_infantry: {
			name: "Napoleonic Infantry",
			ap: 10,
			dp: 3,
			mp: 3,
			ip: 4,
			quantity: 10000,
			costs: [[1, "wood"], [1, "iron"], [1, "lead"], [2, "food"], [1000, "money"], [5, "ground_units_cp"], [10000, "soldiers"]]
		},
		rangers: {
			name: "Rangers",
			ap: 7,
			dp: 3,
			mp: 6,
			ip: 5,
			quantity: 10000,
			costs: [[2, "wood"], [1, "lead"], [4, "food"], [1500, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		guards: {
			name: "Guards",
			ap: 20,
			dp: 5,
			mp: 2,
			ip: 4,
			quantity: 10000,
			costs: [[3, "wood"], [2, "iron"], [2, "lead"], [5, "food"], [2500, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		riflemen: {
			name: "Riflemen",
			ap: 14,
			dp: 10,
			mp: 3,
			ip: 3,
			quantity: 10000,
			costs: [[2, "wood"], [3, "iron"], [1, "lead"], [3, "food"], [2000, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		marines: {
			name: "Marines",
			ap: 20,
			dp: 3,
			mp: 5,
			ip: 1,
			quantity: 10000,
			costs: [[3, "wood"], [1, "iron"], [1, "lead"], [5, "food"], [3000, "money"], [15, "ground_units_cp"], [10000, "soldiers"]]
		},
		breechloaded_infantry: {
			name: "Breechloaded Infantry",
			ap: 18,
			dp: 20,
			mp: 2,
			ip: 5,
			quantity: 10000,
			costs: [[1, "wood"], [1, "steel"], [1, "lead"], [3, "food"], [3000, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		//Great War Ranged Infantry Units
		franc_tireurs: {
			name: "Franc-Tireurs",
			ap: 1,
			dp: 3,
			mp: 6,
			ip: 1,
			quantity: 10000,
			costs: [[1, "wood"], [10000, "soldiers"]]
		},
		bolt_action_infantry: {
			name: "Bolt-Action Infantry",
			ap: 12,
			dp: 20,
			mp: 7,
			ip: 4,
			quantity: 10000,
			costs: [[1, "wood"], [2, "steel"], [1, "lead"], [2, "food"], [2500, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		mg_companies: {
			name: "MG Companies",
			ap: 35,
			dp: 5,
			mp: 1,
			ip: 4,
			quantity: 10000,
			costs: [[10, "steel"], [5, "lead"], [2, "wood"], [5, "food"], [10000, "money"], [20, "ground_units_cp"], [10000, "soldiers"]]
		},
		great_war_infantry: {
			name: "Great War Infantry",
			ap: 10,
			dp: 25,
			mp: 5,
			ip: 5,
			quantity: 10000,
			costs: [[2, "steel"], [2, "lead"], [3, "food"], [2000, "money"], [5, "ground_units_cp"], [10000, "soldiers"]]
		},
		shock_troops: {
			name: "Shock Troops",
			ap: 20,
			dp: 5,
			mp: 6,
			ip: 6,
			quantity: 10000,
			costs: [[5, "wood"], [10, "steel"], [5, "iron"], [3, "lead"], [6, "food"], [5000, "money"], [20, "ground_units_cp"], [10000, "soldiers"]]
		},
		//Modern Ranged Infantry Units
		freikorps: {
			name: "Freikorps",
			ap: 12,
			dp: 5,
			mp: 2,
			ip: 5,
			quantity: 10000,
			costs: [[1, "wood"], [2, "steel"], [1, "petroil"], [2, "food"], [1500, "money"], [5, "ground_units_cp"], [10000, "soldiers"]]
		},
		motorised_infantry: {
			name: "Motorised Infantry",
			ap: 15,
			dp: 5,
			mp: 5,
			ip: 7,
			quantity: 10000,
			costs: [[5, "steel"], [3, "petroil"], [4, "food"], [2500, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		paratroopers: {
			name: "Paratroopers",
			ap: 5,
			dp: 3,
			mp: 8,
			ip: 6,
			quantity: 10000,
			costs: [[1, "steel"], [1, "wood"], [3, "petroil"], [5, "food"], [5000, "money"], [20, "ground_units_cp"], [10000, "soldiers"]]
		},
		special_forces: {
			name: "Special Forces",
			ap: 25,
			dp: 3,
			mp: 8,
			ip: 8,
			quantity: 10000,
			costs: [[10, "steel"], [5, "iron"], [5, "lead"], [5, "petroil"], [10, "food"], [20000, "money"], [40, "ground_units_cp"], [10000, "soldiers"]]
		},
		modern_infantry: {
			name: "Modern Infantry",
			ap: 20,
			dp: 35,
			mp: 4,
			ip: 5,
			quantity: 10000,
			costs: [[5, "steel"], [2, "lead"], [3, "food"], [3500, "money"], [5, "ground_units_cp"], [10000, "soldiers"]]
		},
		combined_arms_infantry: {
			name: "Combined Arms Infantry",
			ap: 25,
			dp: 50,
			mp: 3,
			ip: 5,
			quantity: 10000,
			costs: [[8, "steel"], [3, "wood"], [3, "lead"], [3, "food"], [5000, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		contemporary_infantry: {
			name: "Contemporary Infantry",
			ap: 30,
			dp: 65,
			mp: 3,
			ip: 4,
			quantity: 10000,
			costs: [[8, "steel"], [3, "lead"], [1, "gold"], [4, "food"], [5500, "money"], [20, "ground_units_cp"], [10000, "soldiers"]]
		},
		augmented_infantry: {
			name: "Augmented Infantry",
			ap: 40,
			dp: 15,
			mp: 1,
			ip: 9,
			quantity: 10000,
			costs: [[8, "steel"], [3, "iron"], [3, "lead"], [5, "gold"], [5, "food"], [7000, "money"], [40, "ground_units_cp"], [10000, "soldiers"]]
		},
		//Mercenaries
		condottieri: {
			name: "Condottieri",
			ap: 2,
			dp: 5,
			mp: 3,
			ip: 1,
			quantity: 10000,
			costs: [[4000, "money"], [10000, "soldiers"]]
		},
		early_modern_mercenaries: {
			name: "Early Modern Mercenaries",
			ap: 4,
			dp: 2,
			mp: 0,
			ip: 2,
			quantity: 10000,
			costs: [[6500, "money"], [10000, "soldiers"]]
		},
		landsknecht: {
			name: "Landsknecht",
			ap: 7,
			dp: 3,
			mp: 1,
			ip: 1,
			quantity: 10000,
			costs: [[7000, "money"], [10000, "soldiers"]]
		},
		swiss_guards: {
			name: "Swiss Guards",
			ap: 2,
			dp: 6,
			mp: 3,
			ip: 2,
			quantity: 10000,
			costs: [[7000, "money"], [10000, "soldiers"]]
		},
		//Cavalry Units
		lance_cavalry: {
			name: "Lance Cavalry",
			ap: 6,
			dp: 2,
			mp: 3,
			ip: 3,
			quantity: 10000,
			costs: [[1, "wood"], [3, "iron"], [3, "food"], [500, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		heavy_cavalry: {
			name: "Heavy Cavalry",
			ap: 5,
			dp: 3,
			mp: 1,
			ip: 4,
			quantity: 10000,
			costs: [[2, "wood"], [5, "iron"], [4, "food"], [1000, "money"], [20, "ground_units_cp"], [10000, "soldiers"]]
		},
		light_cavalry: {
			name: "Light Cavalry",
			ap: 3,
			dp: 1,
			mp: 5,
			ip: 6,
			quantity: 10000,
			costs: [[1, "wood"], [1, "iron"], [2, "food"], [250, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		cuirassiers: {
			name: "Cuirassiers",
			ap: 5,
			dp: 2,
			mp: 2,
			ip: 5,
			quantity: 10000,
			costs: [[3, "wood"], [6, "iron"], [1, "lead"], [4, "food"], [1500, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		hussars: {
			name: "Hussars",
			ap: 10,
			dp: 3,
			mp: 1,
			ip: 6,
			quantity: 10000,
			costs: [[5, "wood"], [10, "iron"], [3, "lead"], [7, "food"], [2000, "money"], [20, "ground_units_cp"], [10000, "soldiers"]]
		},
		dragoons: {
			name: "Dragoons",
			ap: 8,
			dp: 4,
			mp: 5,
			ip: 5,
			quantity: 10000,
			costs: [[1, "wood"], [1, "iron"], [1, "lead"], [3, "food"], [1000, "money"], [15, "ground_units_cp"], [10000, "soldiers"]]
		},
		uhlans: {
			name: "Uhlans",
			ap: 6,
			dp: 3,
			mp: 6,
			ip: 4,
			quantity: 10000,
			costs: [[2, "wood"], [1, "steel"], [3, "food"], [800, "money"], [5, "ground_units_cp"], [10000, "soldiers"]]
		},
		mounted_rifles: {
			name: "Mounted Rifles",
			ap: 10,
			dp: 5,
			mp: 5,
			ip: 2,
			quantity: 10000,
			costs: [[1, "wood"], [2, "steel"], [3, "lead"], [5, "food"], [2000, "money"], [10, "ground_units_cp"], [10000, "soldiers"]]
		},
		modern_cavalry: {
			name: "Modern Cavalry",
			ap: 8,
			dp: 3,
			mp: 6,
			ip: 1,
			quantity: 10000,
			costs: [[2, "steel"], [3, "lead"], [2, "petroil"], [7, "food"], [3000, "money"], [20, "ground_units_cp"], [10000, "soldiers"]]
		},
		//Artillery Units - Mediaeval to Early Modern
		bombard: {
			name: "Bombards",
			ap: 750,
			dp: 50,
			mp: 0,
			ip: 1,
			quantity: 100,
			costs: [[3, "iron"], [5, "lead"], [3, "food"], [1000, "money"], [5, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		hand_cannons: {
			name: "Hand Cannons",
			ap: 350,
			dp: 100,
			mp: 3,
			ip: 3,
			quantity: 100,
			costs: [[2, "iron"], [1, "lead"], [5, "food"], [700, "money"], [10, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		long_cannons: {
			name: "Long Cannons",
			ap: 1000,
			dp: 35,
			mp: 1,
			ip: 4,
			quantity: 100,
			costs: [[5, "iron"], [2, "wood"], [3, "lead"], [3, "food"], [1500, "money"], [10, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		field_culverins: {
			name: "Field Culverins",
			ap: 1200,
			dp: 40,
			mp: 1,
			ip: 5,
			quantity: 100,
			costs: [[4, "iron"], [3, "wood"], [3, "lead"], [3, "food"], [2000, "money"], [15, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		demi_cannon: {
			name: "Demi Cannon",
			ap: 1250,
			dp: 30,
			mp: 1,
			ip: 4,
			quantity: 100,
			costs: [[4, "iron"], [2, "wood"], [2, "lead"], [3, "food"], [2000, "money"], [15, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		field_cannon: {
			name: "Field Cannon",
			ap: 1500,
			dp: 50,
			mp: 2,
			ip: 5,
			quantity: 100,
			costs: [[5, "iron"], [3, "lead"], [2, "lead"], [3, "food"], [1500, "money"], [20, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		demi_culverins: {
			name: "Demi Culverins",
			ap: 1300,
			dp: 100,
			mp: 3,
			ip: 4,
			quantity: 100,
			costs: [[5, "iron"], [3, "wood"], [3, "lead"], [3, "food"], [2000, "money"], [15, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		minions: {
			name: "Minions",
			ap: 500,
			dp: 600,
			mp: 5,
			ip: 5,
			quantity: 100,
			costs: [[2, "iron"], [2, "wood"], [1, "lead"], [2, "food"], [1000, "money"], [5, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		siege_artillery: {
			name: "Siege Artillery",
			ap: 2000,
			dp: 10,
			mp: 0,
			ip: 2,
			quantity: 100,
			costs: [[8, "iron"], [3, "lead"], [7, "food"], [3500, "money"], [20, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		mysorean_rockets: {
			name: "Mysorean Rockets",
			ap: 450,
			dp: 20,
			mp: 8,
			ip: 2,
			quantity: 100,
			costs: [[2, "iron"], [1, "lead"], [1, "wood"], [1, "food"], [3000, "money"], [20, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		carronades: {
			name: "Carronades",
			ap: 500,
			dp: 200,
			mp: 2,
			ip: 5,
			quantity: 100,
			costs: [[2, "wood"], [3, "iron"], [1, "lead"], [2, "food"], [1000, "money"], [5, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		congreve_rockets: {
			name: "Congreve Rockets",
			ap: 600,
			dp: 20,
			mp: 8,
			ip: 3,
			quantity: 100,
			costs: [[2, "wood"], [4, "iron"], [2, "lead"], [2, "food"], [3000, "money"], [20, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		smoothbores: {
			name: "Smoothbores",
			ap: 1700,
			dp: 50,
			mp: 3,
			ip: 3,
			quantity: 100,
			costs: [[3, "iron"], [1, "wood"], [3, "lead"], [3, "food"], [2000, "money"], [15, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		rifled_cannons: {
			name: "Rifled Cannons",
			ap: 2000,
			dp: 75,
			mp: 2,
			ip: 4,
			quantity: 100,
			costs: [[3, "iron"], [2, "wood"], [3, "lead"], [3, "food"], [2500, "money"], [10, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		railwayguns: {
			name: "Railwayguns",
			ap: 5000,
			dp: 1000,
			mp: 2,
			ip: 3,
			quantity: 100,
			costs: [[15, "steel"], [20, "lead"], [1, "gold"], [5, "iron"], [20, "food"], [15000, "money"], [40, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		field_artillery: {
			name: "Field Artillery",
			ap: 2500,
			dp: 250,
			mp: 1,
			ip: 2,
			quantity: 100,
			costs: [[5, "steel"], [2, "lead"], [3, "food"], [3000, "money"], [10, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		artillery_howitzers: {
			name: "Artillery Howitzers",
			ap: 3500,
			dp: 300,
			mp: 0,
			ip: 3,
			quantity: 100,
			costs: [[7, "steel"], [3, "lead"], [3, "food"], [3000, "money"], [10, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		mobile_artillery: {
			name: "Mobile Artillery",
			ap: 2000,
			dp: 50,
			mp: 5,
			ip: 4,
			quantity: 100,
			costs: [[8, "steel"], [3, "petroil"], [5, "lead"], [3, "food"], [3500, "money"], [20, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		//Modern Artillery Units
		long_range_artillery: {
			name: "Long Range Artillery",
			ap: 5000,
			dp: 50,
			mp: 0,
			ip: 2,
			quantity: 100,
			costs: [[5, "steel"], [3, "lead"], [1, "gold"], [3, "food"], [5000, "money"], [30, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		modern_howitzers: {
			name: "Modern Howitzers",
			ap: 3500,
			dp: 500,
			mp: 1,
			ip: 4,
			quantity: 100,
			costs: [[7, "steel"], [5, "lead"], [3, "gold"], [5, "food"], [3500, "money"], [10, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		self_propelled_artillery: {
			name: "SP Artillery",
			ap: 2500,
			dp: 100,
			mp: 2,
			ip: 1,
			quantity: 100,
			costs: [[10, "steel"], [5, "petroil"], [3, "lead"], [2, "gold"], [5, "food"], [4000, "money"], [20, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		rocket_artillery: {
			name: "Rocket Artillery",
			ap: 2700,
			dp: 500,
			mp: 4,
			ip: 2,
			quantity: 100,
			costs: [[12, "steel"], [5, "petroil"], [5, "lead"], [2, "food"], [4000, "money"], [20, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		railguns: {
			name: "Railguns",
			ap: 5000,
			dp: 250,
			mp: 1,
			ip: 4,
			quantity: 100,
			costs: [[15, "steel"], [5, "iron"], [10, "gold"], [10, "petroil"], [2, "food"], [7000, "money"], [40, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		directed_heat_weapons: {
			name: "Directed Heat Weapons",
			ap: 5500,
			dp: 500,
			mp: 2,
			ip: 5,
			quantity: 100,
			costs: [[20, "steel"], [10, "gold"], [10, "iron"], [5, "petroil"], [3, "food"], [10000, "money"], [40, "ground_artillery_cp"], [20000, "soldiers"]]
		},
		//Ground Vehicles - Armoured Cars
		armoured_cars: {
			name: "Armoured Cars",
			ap: 1200,
			dp: 2000,
			mp: 6,
			ip: 1,
			quantity: 50,
			costs: [[3, "steel"], [2, "iron"], [2, "petroil"], [3, "lead"], [4, "food"], [2000, "money"], [5, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		armoured_personnel_carriers: {
			name: "Armoured Personnel Carriers",
			ap: 1500,
			dp: 2000,
			mp: 5,
			ip: 2,
			quantity: 50,
			costs: [[5, "steel"], [3, "petroil"], [2, "lead"], [5, "food"], [1500, "money"], [5, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		half_tracks: {
			name: "Half-Tracks",
			ap: 1000,
			dp: 1500,
			mp: 3,
			ip: 3,
			quantity: 50,
			costs: [[4, "steel"], [2, "petroil"], [1, "lead"], [5, "food"], [1000, "money"], [5, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		troop_carriers: {
			name: "Troop Carriers",
			ap: 500,
			dp: 1000,
			mp: 7,
			ip: 1,
			quantity: 50,
			costs: [[3, "steel"], [1, "petroil"], [3, "food"], [1000, "money"], [5, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		modern_armoured_cars: {
			name: "Modern Armoured Cars",
			ap: 2000,
			dp: 3500,
			mp: 7,
			ip: 3,
			quantity: 50,
			costs: [[5, "steel"], [3, "petroil"], [5, "food"], [5000, "money"], [10, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		modern_apcs: {
			name: "Modern APCs",
			ap: 1500,
			dp: 4000,
			mp: 3,
			ip: 5,
			quantity: 50,
			costs: [[10, "steel"], [5, "petroil"], [4, "food"], [2500, "money"], [10, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		//Ground Vehicles - Tanks from WW1 to WW2
		landship: {
			name: "Landship",
			ap: 1800,
			dp: 700,
			mp: 1,
			ip: 1,
			quantity: 50,
			costs: [[7, "steel"], [3, "lead"], [5, "petroil"], [5, "food"], [3000, "money"], [20, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		light_tanks: {
			name: "Light Tanks",
			ap: 1200,
			dp: 250,
			mp: 3,
			ip: 4,
			quantity: 50,
			costs: [[5, "steel"], [2, "lead"], [3, "petroil"], [4, "food"], [2500, "money"], [10, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		interwar_tanks: {
			name: "Interwar Tanks",
			ap: 1500,
			dp: 300,
			mp: 2,
			ip: 3,
			quantity: 50,
			costs: [[5, "steel"], [3, "lead"], [4, "petroil"], [5, "food"], [3000, "money"], [10, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		medium_tanks: {
			name: "Medium Tanks",
			ap: 1600,
			dp: 800,
			mp: 1,
			ip: 5,
			quantity: 50,
			costs: [[7, "steel"], [2, "lead"], [2, "petroil"], [3, "food"], [5000, "money"], [15, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		heavy_tanks: {
			name: "Heavy Tanks",
			ap: 2000,
			dp: 1000,
			mp: 0,
			ip: 1,
			quantity: 50,
			costs: [[12, "steel"], [4, "lead"], [3, "petroil"], [3, "food"], [8000, "money"], [20, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		tank_destroyers: {
			name: "Tank Destroyers",
			ap: 2500,
			dp: 300,
			mp: 5,
			ip: 2,
			quantity: 50,
			costs: [[5, "steel"], [2, "lead"], [1, "petroil"], [1, "food"], [3000, "money"], [10, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		//Ground Vehicles - Modern Tanks
		improved_medium_tanks: {
			name: "Improved Medium Tanks",
			ap: 2500,
			dp: 1250,
			mp: 2,
			ip: 3,
			quantity: 50,
			costs: [[10, "steel"], [3, "lead"], [3, "petroil"], [3, "food"], [4000, "money"], [15, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		modern_tanks: {
			name: "Modern Tanks",
			ap: 3000,
			dp: 1000,
			mp: 3,
			ip: 4,
			quantity: 50,
			costs: [[10, "steel"], [1, "gold"], [3, "lead"], [5, "petroil"], [3, "food"], [6000, "money"], [20, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		main_battle_tanks: {
			name: "Main Battle Tanks",
			ap: 3200,
			dp: 1500,
			mp: 2,
			ip: 5,
			quantity: 50,
			costs: [[15, "steel"], [3, "gold"], [4, "lead"], [5, "petroil"], [3, "food"], [8000, "money"], [20, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		modern_mbts: {
			name: "Modern MBTs",
			ap: 4000,
			dp: 2000,
			mp: 1,
			ip: 4,
			quantity: 50,
			costs: [[15, "steel"], [5, "gold"], [5, "lead"], [5, "petroil"], [5, "food"], [10000, "money"], [20, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		multirole_mbts: {
			name: "Multirole MBTs",
			ap: 5000,
			dp: 2000,
			mp: 3,
			ip: 4,
			quantity: 50,
			costs: [[20, "steel"], [10, "gold"], [3, "iron"], [5, "lead"], [7, "petroil"], [7, "food"], [12000, "money"], [40, "ground_vehicles_cp"], [35000, "soldiers"]]
		},
		//Naval Units
		caravels: {
			name: "Caravels",
			ap: 200,
			dp: 500,
			mp: 8,
			ip: 1,
			quantity: 5,
			costs: [[2, "wood"], [1, "iron"], [5, "food"], [500, "money"], [5, "naval_units_cp"], [50000, "soldiers"]]
		},
		galleons: {
			name: "Galleons",
			ap: 500,
			dp: 250,
			mp: 2,
			ip: 3,
			quantity: 5,
			costs: [[3, "wood"], [2, "iron"], [2, "lead"], [7, "food"], [1000, "money"], [10, "naval_units_cp"], [50000, "soldiers"]]
		},
		men_of_war: {
			name: "Men-of-War",
			ap: 650,
			dp: 300,
			mp: 2,
			ip: 4,
			quantity: 5,
			costs: [[5, "wood"], [3, "iron"], [3, "lead"], [7, "food"], [1500, "money"], [15, "naval_units_cp"], [50000, "soldiers"]]
		},
		ships_of_the_line: {
			name: "Ships-of-the-Line",
			ap: 600,
			dp: 400,
			mp: 3,
			ip: 4,
			quantity: 5,
			costs: [[5, "wood"], [3, "iron"], [3, "lead"], [7, "food"], [2000, "money"], [15, "naval_units_cp"], [50000, "soldiers"]]
		},
		first_rate: {
			name: "First Rates",
			ap: 850,
			dp: 350,
			mp: 3,
			ip: 5,
			quantity: 5,
			costs: [[7, "wood"], [3, "iron"], [5, "lead"], [7, "food"], [2500, "money"], [20, "naval_units_cp"], [50000, "soldiers"]]
		},
		frigates: {
			name: "Frigates",
			ap: 500,
			dp: 350,
			mp: 4,
			ip: 3,
			quantity: 5,
			costs: [[5, "wood"], [2, "iron"], [3, "lead"], [4, "food"], [1500, "money"], [10, "naval_units_cp"], [50000, "soldiers"]]
		},
		steamboats: {
			name: "Steamboats",
			ap: 350,
			dp: 600,
			mp: 6,
			ip: 1,
			quantity: 5,
			costs: [[2, "wood"], [5, "iron"], [2, "lead"], [5, "food"], [3000, "money"], [10, "naval_units_cp"], [50000, "soldiers"]]
		},
		clippers: {
			name: "Clippers",
			ap: 150,
			dp: 300,
			mp: 8,
			ip: 3,
			quantity: 5,
			costs: [[3, "wood"], [1, "iron"], [7, "food"], [1500, "money"], [5, "naval_units_cp"], [50000, "soldiers"]]
		},
		gunboats: {
			name: "Gunboats",
			ap: 600,
			dp: 250,
			mp: 4,
			ip: 4,
			quantity: 5,
			costs: [[5, "iron"], [2, "lead"], [6, "food"], [2000, "money"], [10, "naval_units_cp"], [50000, "soldiers"]]
		},
		ironclads: {
			name: "Ironclads",
			ap: 1200,
			dp: 1800,
			mp: 3,
			ip: 5,
			quantity: 5,
			costs: [[10, "iron"], [5, "lead"], [3, "coal"], [5, "food"], [5000, "money"], [20, "naval_units_cp"], [50000, "soldiers"]]
		},
		breastwork_monitors: {
			name: "Breastwork Monitors",
			ap: 1500,
			dp: 2000,
			mp: 3,
			ip: 4,
			quantity: 5,
			cruiser: true,
			costs: [[12, "iron"], [4, "lead"], [3, "coal"], [3, "food"], [5500, "money"], [30, "naval_units_cp"], [50000, "soldiers"]]
		},
		destroyers: {
			name: "Destroyers",
			ap: 800,
			dp: 1200,
			mp: 5,
			ip: 4,
			quantity: 5,
			destroyer: true,
			costs: [[8, "steel"], [4, "iron"], [3, "lead"], [3, "petroil"], [5, "food"], [3000, "money"], [10, "naval_units_cp"], [50000, "soldiers"]]
		},
		cruisers: {
			name: "Cruisers",
			ap: 2000,
			dp: 1500,
			mp: 4,
			ip: 5,
			quantity: 5,
			cruiser: true,
			costs: [[12, "steel"], [5, "iron"], [4, "lead"], [5, "petroil"], [7, "food"], [5000, "money"], [15, "naval_units_cp"], [50000, "soldiers"]]
		},
		pre_dreadnoughts: {
			name: "Pre-Dreadoughts",
			ap: 2000,
			dp: 3500,
			mp: 2,
			ip: 6,
			quantity: 5,
			costs: [[15, "steel"], [5, "lead"], [5, "petroil"], [8, "food"], [7000, "money"], [20, "naval_units_cp"], [50000, "soldiers"]]
		},
		dreadnoughts: {
			name: "Dreadnoughts",
			ap: 3500,
			dp: 4000,
			mp: 1,
			ip: 5,
			quantity: 5,
			costs: [[18, "steel"], [5, "iron"], [8, "lead"], [5, "petroil"], [9, "food"], [10000, "money"], [40, "naval_units_cp"], [50000, "soldiers"]]
		},
		torpedo_boats: {
			name: "Torpedo Boats",
			ap: 2000,
			dp: 50,
			mp: 6,
			ip: 5,
			quantity: 5,
			costs: [[3, "steel"], [2, "iron"], [5, "lead"], [3, "petroil"], [5, "food"], [1500, "money"], [5, "naval_units_cp"], [50000, "soldiers"]]
		},
		battlecruisers: {
			name: "Battlecruisers",
			ap: 3500,
			dp: 2000,
			mp: 4,
			ip: 6,
			quantity: 5,
			cruiser: true,
			costs: [[5, "steel"], [4, "iron"], [3, "lead"], [7, "petroil"], [7, "food"], [6500, "money"], [20, "naval_units_cp"], [50000, "soldiers"]]
		},
		submarines: {
			name: "Submarines",
			ap: 3500,
			dp: 500,
			mp: 8,
			ip: 4,
			quantity: 5,
			submarine: true,
			costs: [[3, "steel"], [2, "lead"], [3, "petroil"], [8, "food"], [2000, "money"], [10, "naval_units_cp"], [50000, "soldiers"]]
		},
		air_carriers: {
			name: "Air Carriers",
			ap: 1500,
			dp: 2000,
			mp: 2,
			ip: 1,
			quantity: 1,
			carrier_capacity: 20,
			costs: [[12, "steel"], [10, "wood"], [5, "iron"], [3, "lead"], [5, "petroil"], [10, "food"], [9000, "money"], [40, "naval_units_cp"], [50000, "soldiers"]]
		},
		battleships: {
			name: "Battleships",
			ap: 5000,
			dp: 7500,
			mp: 3,
			ip: 5,
			quantity: 5,
			costs: [[15, "steel"], [5, "wood"], [5, "lead"], [7, "petroil"], [12, "food"], [8000, "money"], [20, "naval_units_cp"], [50000, "soldiers"]]
		},
		aircraft_carriers: {
			name: "Aircraft Carriers",
			ap: 1200,
			dp: 2200,
			mp: 2,
			ip: 1,
			quantity: 1,
			carrier_capacity: 35,
			costs: [[20, "steel"], [15, "wood"], [5, "lead"], [1, "gold"], [10, "petroil"], [10, "food"], [10000, "money"], [40, "naval_units_cp"], [50000, "soldiers"]]
		},
		nuclear_submarines: {
			name: "Nuclear Submarines",
			ap: 4500,
			dp: 550,
			mp: 6,
			ip: 2,
			quantity: 5,
			submarine: true,
			costs: [[15, "steel"], [3, "gold"], [7, "petroil"], [10, "food"], [5000, "money"], [30, "naval_units_cp"], [50000, "soldiers"]]
		},
		supercarriers: {
			name: "Supercarriers",
			ap: 2000,
			dp: 3500,
			mp: 1,
			ip: 1,
			quantity: 1,
			carrier_capacity: 50,
			costs: [[25, "steel"], [10, "gold"], [10, "lead"], [10, "petroil"], [15, "food"], [15000, "money"], [40, "naval_units_cp"], [50000, "soldiers"]]
		},
		modern_cruisers: {
			name: "Modern Cruisers",
			ap: 3500,
			dp: 3000,
			mp: 4,
			ip: 5,
			quantity: 5,
			cruiser: true,
			costs: [[20, "steel"], [5, "gold"], [10, "lead"], [7, "petroil"], [10, "food"], [5000, "money"], [15, "naval_units_cp"], [50000, "soldiers"]]
		},
		modern_frigates: {
			name: "Modern Frigates",
			ap: 2500,
			dp: 3500,
			mp: 5,
			ip: 4,
			quantity: 5,
			destroyer: true,
			costs: [[15, "steel"], [3, "gold"], [5, "lead"], [5, "petroil"], [7, "food"], [3500, "money"], [10, "naval_units_cp"], [50000, "soldiers"]]
		},
		railgun_cruisers: {
			name: "Railgun Cruisers",
			ap: 5500,
			dp: 2800,
			mp: 3,
			ip: 4,
			quantity: 5,
			cruiser: true,
			costs: [[25, "steel"], [15, "gold"], [5, "lead"], [10, "petroil"], [15, "food"], [15000, "money"], [20, "naval_units_cp"], [50000, "soldiers"]]
		},
		//Air Units - Pre-WW1
		reconaissance_balloons: {
			name: "Reconaissance",
			ap: 20,
			dp: 200,
			mp: 8,
			ip: 1,
			quantity: 20,
			costs: [[1, "wood"], [1, "coal"], [500, "money"], [5, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		dirigibles: {
			name: "Dirigibles",
			ap: 60,
			dp: 250,
			mp: 6,
			ip: 2,
			quantity: 20,
			costs: [[3, "wood"], [1, "coal"], [1, "food"], [1000, "money"], [10, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		zeppelins: {
			name: "Zeppelins",
			ap: 500,
			dp: 350,
			mp: 6,
			ip: 3,
			quantity: 20,
			costs: [[5, "steel"], [2, "wood"], [3, "coal"], [3, "food"], [2500, "money"], [20, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		//Air Units - WW1 and Interwar
		biplanes: {
			name: "Biplanes",
			ap: 500,
			dp: 900,
			mp: 2,
			ip: 2,
			quantity: 20,
			costs: [[5, "wood"], [2, "steel"], [1, "lead"], [1, "petroil"], [1000, "money"], [10, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		improved_biplanes: {
			name: "Improved Biplanes",
			ap: 550,
			dp: 1100,
			mp: 3,
			ip: 3,
			quantity: 20,
			costs: [[5, "wood"], [3, "steel"], [2, "lead"], [1, "petroil"], [1250, "money"], [15, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		monoplane_fighters: {
			name: "Monoplane Fighters",
			ap: 550,
			dp: 1100,
			mp: 4,
			ip: 3,
			quantity: 20,
			costs: [[3, "wood"], [5, "steel"], [3, "lead"], [2, "petroil"], [1500, "money"], [15, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		propeller_fighters: {
			name: "Propeller Fighters",
			ap: 600,
			dp: 1500,
			mp: 5,
			ip: 3,
			quantity: 20,
			costs: [[5, "steel"], [2, "wood"], [2, "lead"], [3, "petroil"], [1500, "money"], [20, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		//Air Units - Fighter Aeroplanes
		fighters: {
			name: "Fighters",
			ap: 600,
			dp: 1800,
			mp: 5,
			ip: 3,
			quantity: 20,
			costs: [[5, "steel"], [1, "wood"], [3, "lead"], [3, "petroil"], [2000, "money"], [20, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		advanced_fighters: {
			name: "Advanced Fighters",
			ap: 700,
			dp: 2000,
			mp: 6,
			ip: 2,
			quantity: 20,
			costs: [[7, "steel"], [3, "wood"], [5, "lead"], [5, "petroil"], [2500, "money"], [25, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		rocket_interceptors: {
			name: "Rocket Interceptors",
			ap: 550,
			dp: 2200,
			mp: 7,
			ip: 1,
			quantity: 20,
			costs: [[6, "steel"], [3, "iron"], [5, "lead"], [10, "petroil"], [4000, "money"], [30, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		jet_fighters: {
			name: "Jet Fighters",
			ap: 850,
			dp: 2500,
			mp: 6,
			ip: 5,
			quantity: 20,
			costs: [[10, "steel"], [2, "gold"], [5, "iron"], [5, "lead"], [7, "petroil"], [4000, "money"], [20, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		multirole_fighters: {
			name: "Multirole Fighters",
			ap: 1000,
			dp: 3000,
			mp: 6,
			ip: 4,
			quantity: 20,
			costs: [[12, "steel"], [3, "gold"], [4, "lead"], [5, "petroil"], [5000, "money"], [20, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		drones: {
			name: "Drones",
			ap: 1200,
			dp: 50,
			mp: 2,
			ip: 5,
			quantity: 20,
			costs: [[5, "steel"], [4, "gold"], [3, "lead"], [2, "petroil"], [10000, "money"], [5, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		stealth_fighters: {
			name: "Stealth Fighters",
			ap: 1100,
			dp: 3200,
			mp: 8,
			ip: 3,
			quantity: 20,
			costs: [[20, "steel"], [15, "gold"], [5, "lead"], [4, "petroil"], [8000, "money"], [30, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		ai_multirole_fighters: {
			name: "AI Multirole Fighters",
			ap: 1500,
			dp: 3500,
			mp: 9,
			ip: 4,
			quantity: 20,
			costs: [[15, "steel"], [20, "gold"], [7, "lead"], [9, "petroil"], [12000, "money"], [50, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		//Air Units - Bombers
		early_bombers: {
			name: "Early Bombers",
			ap: 900,
			dp: 50,
			mp: 1,
			ip: 2,
			quantity: 20,
			costs: [[7, "wood"], [5, "steel"], [5, "lead"], [3, "petroil"], [2000, "money"], [20, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		monoplane_bombers: {
			name: "Monoplane Bombers",
			ap: 1200,
			dp: 75,
			mp: 1,
			ip: 2,
			quantity: 20,
			costs: [[10, "steel"], [8, "wood"], [7, "lead"], [5, "petroil"], [2500, "money"], [20, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		interwar_bombers: {
			name: "Interwar Bombers",
			ap: 1250,
			dp: 150,
			mp: 2,
			ip: 3,
			quantity: 20,
			costs: [[12, "steel"], [5, "wood"], [7, "lead"], [5, "petroil"], [3000, "money"], [25, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		bombers: {
			name: "Bombers",
			ap: 1500,
			dp: 250,
			mp: 2,
			ip: 5,
			quantity: 20,
			costs: [[15, "steel"], [10, "lead"], [7, "petroil"], [5000, "money"], [25, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		strategic_bombers: {
			name: "Strategic Bombers",
			ap: 1700,
			dp: 500,
			mp: 2,
			ip: 5,
			quantity: 20,
			costs: [[15, "steel"], [3, "gold"], [10, "lead"], [7, "petroil"], [6500, "money"], [30, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		stealth_bombers: {
			name: "Stealth Bombers",
			ap: 2500,
			dp: 700,
			mp: 5,
			ip: 4,
			quantity: 20,
			costs: [[25, "steel"], [20, "gold"], [10, "lead"], [10, "petroil"], [12000, "money"], [50, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		ai_bombers: {
			name: "AI Bombers",
			ap: 2800,
			dp: 1000,
			mp: 5,
			ip: 6,
			quantity: 20,
			costs: [[20, "steel"], [20, "gold"], [7, "lead"], [5, "petroil"], [10000, "money"], [50, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		//Air Units - Helicopters
		scout_helicopters: {
			name: "Scout Helicopters",
			ap: 200,
			dp: 50,
			mp: 8,
			ip: 1,
			quantity: 20,
			helicopter: true,
			costs: [[3, "steel"], [1, "petroil"], [1000, "money"], [5, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		multirole_helicopters: {
			name: "Multirole Helicopters",
			ap: 1400,
			dp: 150,
			mp: 5,
			ip: 3,
			quantity: 20,
			helicopter: true,
			costs: [[5, "steel"], [3, "lead"], [2, "petroil"], [3000, "money"], [10, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		modern_helicopters: {
			name: "Modern Helicopters",
			ap: 1800,
			dp: 300,
			mp: 6,
			ip: 3,
			quantity: 20,
			helicopter: true,
			costs: [[7, "steel"], [3, "gold"], [3, "lead"], [2, "petroil"], [3500, "money"], [10, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		//Air Units - Other
		torpedo_bombers: {
			name: "Torpedo Bombers",
			ap: 2700,
			dp: 500,
			mp: 4,
			ip: 5,
			quantity: 20,
			can_bomb_cities: false,
			costs: [[5, "steel"], [5, "lead"], [3, "wood"], [3, "petroil"], [2500, "money"], [10, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		naval_bombers: {
			name: "Naval Bombers",
			ap: 2000,
			dp: 550,
			mp: 7,
			ip: 3,
			quantity: 20,
			can_bomb_cities: false,
			costs: [[6, "steel"], [2, "wood"], [3, "lead"], [3, "petroil"], [1500, "money"], [10, "aeroplanes_cp"], [25000, "soldiers"]]
		},
		//Colonists
		conquistadors: {
			name: "Conquistadors",
			ap: 0,
			dp: 0,
			mp: 0,
			ip: 0,
			quantity: 1,
			colonise_provinces: 1,
			costs: [[1, "wood"], [2, "lead"], [3, "iron"], [5, "food"], [2500, "money"], [1000, "soldiers"]]
		},
		settlers: {
			name: "Settlers",
			ap: 0,
			dp: 0,
			mp: 0,
			ip: 0,
			quantity: 1,
			colonise_provinces: 2,
			costs: [[3, "wood"], [2, "lead"], [5, "iron"], [10, "food"], [5000, "money"], [2500, "soldiers"]]
		},
		magistrates: {
			name: "Magistrates",
			ap: 0,
			dp: 0,
			mp: 0,
			ip: 0,
			quantity: 1,
			colonise_provinces: 3,
			costs: [[10, "wood"], [5, "lead"], [5, "gold"], [10, "iron"], [20, "food"], [6500, "money"], [5000, "soldiers"]]
		},
		colonists: {
			name: "Colonists",
			ap: 0,
			dp: 0,
			mp: 0,
			ip: 0,
			quantity: 1,
			colonise_provinces: 5,
			costs: [[20, "wood"], [7, "lead"], [5, "gold"], [15, "iron"], [40, "food"], [7500, "money"], [4000, "soldiers"]]
		},
		magnates: {
			name: "Magnates",
			ap: 0,
			dp: 0,
			mp: 0,
			ip: 0,
			quantity: 1,
			colonise_provinces: 6,
			costs: [[25, "wood"], [10, "lead"], [5, "gold"], [10, "steel"], [50, "food"], [10000, "money"], [7000, "soldiers"]]
		},
		administrators: {
			name: "Administrators",
			ap: 0,
			dp: 0,
			mp: 0,
			ip: 0,
			quantity: 1,
			colonise_provinces: 8,
			costs: [[10, "wood"], [20, "lead"], [10, "gold"], [20, "steel"], [10, "petroil"], [100, "food"], [15000, "money"], [10000, "soldiers"]]
		},
		bureaucrats: {
			name: "Bureaucrats",
			ap: 0,
			dp: 0,
			mp: 0,
			ip: 0,
			quantity: 1,
			colonise_provinces: 10,
			costs: [[30, "wood"], [50, "lead"], [20, "gold"], [30, "steel"], [5, "iron"], [15, "petroil"], [150, "food"], [20000, "money"], [20000, "soldiers"]]
		}
	},
	
	tech_categories: ["military_technology", "naval_technology", "economic_technology", "administrative_technology"], //"cultural_technology", add later
	technology: {
		//Military Technology
		improved_metallurgy: {
			icon: "<:lead:716791408840671322>",
			description: "By increasing the purity and mixture of our compounds and alloys, our craftsmen will be able to forge more powerful weapons as the winds of the Gunpowder Age sweep our continent.",
			research_cost: 20,
			category: "military_technology",
			modifiers: [
				"Enables **Artillery Factories**",
				"**+5%** Production Efficiency",
				"**+5%** Artillery AP"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("artillery_factories");
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
			}
		},
		standing_army: {
			icon: "<:manpower:716817688705499177>",
			description: "The days of calling upon a feudal levee are gone, we should seek to maintain a standing army for our burgeoning state.",
			research_cost: 20,
			category: "military_technology",
			modifiers: [
				"**+10%** National Manpower"
			],
			unlocks: function (usr) {
				usr.modifiers.national_manpower = usr.modifiers.national_manpower + 0.10;
			}
		},
		lance_cavalry: {
			icon: "<:soldiers:732730754592669702>",
			description: "By better equipping our knights with lances, we can wreak devastating havoc when smashing into enemy lines in mass cavalry formations.",
			research_cost: 20,
			category: "military_technology",
			modifiers: [
				"Enables **Lance Cavalry**",
				"**+2%** Training Cost",
				"Obsoletes **Knights**"
			],
			unlocks: function (usr) {
				usr.available_units.push("lance_cavalry");
				deleteElement(usr.available_units, "knights", [usr, "obsolete_units"]);
				usr.modifiers.training_cost = usr.modifiers.training_cost + 0.02;
			}
		},
		condottieri: {
			icon: "<:colonisation:716821194891853826>",
			description: "Condottieri, originating as mercenaries from the Latin Peninsulae, are mercenaries of great renown that can bolster our military quickly in times of war - for a price of course.",
			research_cost: 20,
			category: "military_technology",
			modifiers: [
				"Enables **Condottieri**",
				"**+5%** National Manpower"
			],
			unlocks: function (usr) {
				usr.available_units.push("condottieri");
				usr.modifiers.national_manpower = usr.modifiers.national_manpower + 0.05;
			}
		},
		the_bombard: {
			icon: "<:artillery:716821195055431681>",
			description: "A terrifying new gunpowder weapon, bombards allow us to tear holes in castles and besiege cities with ease.",
			prerequisite_techs: ["improved_metallurgy"],
			research_cost: 50,
			category: "military_technology",
			modifiers: [
				"Enables **Bombard**",
				"**+3%** Unit Cost"
			],
			unlocks: function (usr) {
				usr.available_units.push("bombard");
				usr.modifiers.unit_cost = usr.modifiers.unit_cost + 0.03;
			}
		},
		pike_and_square: {
			icon: "<:active_personnel:716820390474940426>",
			description: "Pikemen have proven to be our best defence from cavalry amongst our mercenaries -- we should look into new ways of arranging our troops.",
			prerequisite_techs: ["standing_army"],
			research_cost: 50,
			category: "military_technology",
			modifiers: [
				"Enables **Pike and Square**",
				"Obsoletes **Spearmen**"
			],
			unlocks: function (usr) {
				deleteElement(usr.available_units, "spearmen", [usr, "obsolete_units"]);
				usr.available_units.push("pike_and_square");
			}
		},
		heavy_cavalry: {
			icon: "<:soldiers:732730754592669702>",
			description: "Heavy cavalry are units with armoured horses capable of wielding even the heaviest of infantry weapons.",
			prerequisite_techs: ["lance_cavalry"],
			research_cost: 50,
			category: "military_technology",
			modifiers: [
				"Enables **Heavy Cavalry**"
			],
			unlocks: function (usr) {
				usr.available_units.push("heavy_cavalry");
			}
		},
		hand_cannons: {
			icon: "<:manpower:716817688705499177>",
			description: "Hand cannons were a primitive precursor to early modern firearms that had a devastating impact on enemies at the price of a brutally long reload speed.",
			prerequisite_techs: ["the_bombard"],
			research_cost: 75,
			category: "military_technology",
			modifiers: [
				"Enables **Hand Cannons**",
				"**-2%** Training Cost",
				"**+3%** Unit Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.training_cost = usr.modifiers.training_cost - 0.02;
				usr.modifiers.unit_cost = usr.modifiers.unit_cost + 0.03;
				usr.available_units.push("hand_cannons");
			}
		},
		tercio: {
			icon: "<:colonisation:716821194891853826>",
			description: "The Tercio was a pike-and-shot unit highly known for its attacking effectiveness that sought to cover its firearm units with pikemen in order to maintain defensive cohesion.",
			prerequisite_techs: ["improved_metallurgy","pike_and_square","heavy_cavalry"],
			research_cost: 75,
			category: "military_technology",
			modifiers: [
				"Enables **Tercio**",
				"Obsoletes **Pike and Square**"
			],
			unlocks: function (usr) {
				usr.available_units.push("tercio");
				deleteElement(usr.available_units, "pike_and_square", [usr, "obsolete_units"]);
			}
		},
		early_modern_mercenaries: {
			icon: "<:infamy:716817688453709905>",
			description: "Early modern mercenaries, compared to mercenaries of previous eras, typically came from other nations renowned for their fighting skill and professionalism.",
			prerequisite_techs: ["condottieri"],
			research_cost: 75,
			category: "military_technology",
			modifiers: [
				"**+5%** National Manpower",
				"**+5%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.national_manpower = usr.modifiers.national_manpower + 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
			}
		},
		moveable_field_works: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Moveable field works allow our arquebusiers on the front to quickly shield themselves from harm by tying their firearm to their shield.",
			prerequisite_techs: ["hand_cannons"],
			research_cost: 100,
			category: "military_technology",
			modifiers: [
				"**+3%** Infantry and Cavalry DP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.03;
			}
		},
		improved_firepower: {
			icon: "<:artillery:716821195055431681>",
			description: "Our military engineers have begun to realise that our artillery units can maximise their firepower by bombarding targets in coordinated strikes. Perhaps we should employ this method to great effect ...",
			prerequisite_techs: ["hand_cannons"],
			research_cost: 100,
			category: "military_technology",
			modifiers: [
				"**+5%** Artillery AP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
			}
		},
		the_arquebus: {
			icon: "<:active_personnel:716820390474940426>",
			description: "The arquebus, the successor to the hand cannon, was an important milestone in gunpowder warfare, and the first miniaturised firearm that allowed for masses of soldiers to wield it to great effect with minimal training compared to archery.",
			prerequisite_techs: ["hand_cannons"],
			research_cost: 100,
			category: "military_technology",
			modifiers: [
				"Enables **Arquebusiers**",
				"**+5%** National Manpower",
				"Obsoletes **Archers**",
				"Obsoletes **Longbowmen**"
			],
			unlocks: function (usr) {
				usr.available_units.push("arquebusiers");
				usr.modifiers.national_manpower = usr.modifiers.national_manpower + 0.05;
				deleteElement(usr.available_units, "archers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "longbowmen", [usr, "obsolete_units"]);
			}
		},
		light_cavalry: {
			icon: "<:soldiers:732730754592669702>",
			description: "Light cavalry, compared to heavier forms of mounted infantry, can perform shock attacks and flank enemies at high speed, although their piercing attack is not quite as effective.",
			prerequisite_techs: ["pike_and_square","heavy_cavalry"],
			research_cost: 100,
			category: "military_technology",
			modifiers: [
				"Enables **Light Cavalry**",
				"**+5%** Training Cost"
			],
			unlocks: function (usr) {
				usr.available_units.push("light_cavalry");
				usr.modifiers.training_cost = usr.modifiers.training_cost + 0.05;
			}
		},
		landsknecht: {
			icon: "<:colonisation:716821194891853826>",
			description: "Landsknecht, mercenaries originating from the German and Swiss lands, are well known for their brutality in attacking and so make for highly formidable foes in battle.",
			prerequisite_techs: ["early_modern_mercenaries"],
			research_cost: 100,
			category: "military_technology",
			modifiers: [
				"Enables **Landsknecht**",
				"**+10%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.available_units.push("landsknecht");
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.10;
			}
		},
		scorched_earth: {
			icon: "<:cb:716828676855169107>",
			description: "By embracing scorched earth tactics, we can improve the defensibility of our nation, especially in large, open tracts of land and help prepare for the eventuality when others will use it on our attacking troops.",
			prerequisite_techs: ["moveable_field_works"],
			research_cost: 150,
			category: "military_technology",
			modifiers: [
				"**+5%** Infantry DP",
				"**+2%** War Exhaustion Rate"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.05;
				usr.modifiers.war_exhaustion_rate = usr.modifiers.war_exhaustion_rate + 0.02;
			}
		},
		long_cannon: {
			icon: "<:artillery:716821195055431681>",
			description: "The long gun, which could be used either on sea, or on land, became a devastating piece of artillery that could be transported around the battlefield with relative ease. Although lacking protection, it quickly became the mainstay of continental European armies.",
			prerequisite_techs: ["improved_firepower","moveable_field_works"],
			research_cost: 150,
			category: "military_technology",
			modifiers: [
				"Enables **Long Cannons**",
				"Obsoletes **Bombard**",
				"Obsoletes **Hand Cannons**",
				"**+5%** Artillery AP",
				"**+3%** Training Cost"
			],
			unlocks: function (usr) {
				usr.available_units.push("long_cannons");
				deleteElement(usr.available_units, "bombard", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "hand_cannons", [usr, "obsolete_units"]);
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
				usr.modifiers.training_cost = usr.modifiers.training_cost + 0.03;
			}
		},
		snaplock_infantry: {
			icon: "<:active_personnel:716820390474940426>",
			description: "With the recent invention of the snaplock musket, allowing for the striking of gunpowder without external ignition, our troops can now fire at a moderately faster speed than previously, compared to the arquebus.",
			prerequisite_techs: ["the_arquebus"],
			research_cost: 150,
			category: "military_technology",
			modifiers: [
				"Enables **Snaplock Infantry**",
				"**+2%** Infantry AP"
			],
			unlocks: function (usr) {
				usr.available_units.push("snaplock_infantry");
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.02;
			}
		},
		cuirassiers: {
			icon: "<:soldiers:732730754592669702>",
			description: "Beginning in the 15th century, cuirassiers were mounted cavalry units that began adopting firearms as their primary weapon that were in service up until the beginning of the Great War.",
			prerequisite_techs: ["light_cavalry"],
			research_cost: 150,
			category: "military_technology",
			modifiers: [
				"Enables **Cuirassiers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("cuirassiers");
			}
		},
		proliferation_of_firearms: {
			icon: "<:manpower:716817688705499177>",
			description: "The widespread proliferation of firearms amongst conventional armies during the 16th and 17th centuries eventually lead to the decline of other forms of combat, and the dominance of the gunpowder weapon.",
			prerequisite_techs: ["scorched_earth"],
			research_cost: 200,
			category: "military_technology",
			modifiers: [
				"**+10%** Infantry AP",
				"Obsoletes **Swordsmen**",
				"Obsoletes **Skirmishers**"
			],
			unlocks: function (usr) {
				deleteElement(usr.available_units, "swordsmen", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "skirmishers", [usr, "obsolete_units"]);
				usr.available_units.push("cuirassiers");
			}
		},
		field_culverins: {
			icon: "<:artillery:716821195055431681>",
			description: "Field culverins, used as artillery pieces on the battlefield, were highly mobile pieces of relatively small calibre that were valued for their accuracy and range.",
			prerequisite_techs: ["long_cannon"],
			research_cost: 200,
			category: "military_technology",
			modifiers: [
				"Enables **Field Culverins**",
				"**+5% Artillery AP**"
			],
			unlocks: function (usr) {
				usr.available_units.push("field_culverins");
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
			}
		},
		snaphance_musket: {
			icon: "<:active_personnel:716820390474940426>",
			description: "The snaphance musket, or the snaphaunce rather, was a firing mechanism used for muskets similar to the snaplock that increased the reliability of firearms to prevent accidental discharge.",
			prerequisite_techs: ["snaplock_infantry"],
			research_cost: 200,
			category: "military_technology",
			modifiers: [
				"Enables **Snaphaunce Infantry**"
			],
			unlocks: function (usr) {
				usr.available_units.push("snaphaunce_infantry");
			}
		},
		hussars: {
			icon: "<:infamy:716817688453709905>",
			description: "Hussars were famed and well-trained light cavalry whose charges were known for their effectiveness in battle throughout the early modern period.",
			prerequisite_techs: ["cuirassiers"],
			research_cost: 200,
			category: "military_technology",
			modifiers: [
				"Enables **Hussars**",
				"**+5%** Training Cost**"
			],
			unlocks: function (usr) {
				usr.modifiers.training_cost = usr.modifiers.training_cost + 0.05;
				usr.available_units.push("hussars");
			}
		},
		swiss_guards: {
			icon: "<:manpower:716817688705499177>",
			description: "Swiss Guards, famed for their loyalty and ability to serve as guards for various royal courts, (although later repurposed as regular infantry during the Napoleonic Wars) were some of the last mercenaries from foreign countries to be used.",
			prerequisite_techs: ["cuirassiers"],
			research_cost: 200,
			category: "military_technology",
			modifiers: [
				"Enables **Swiss Guards**",
				"**+3%** Upkeep Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.03;
				usr.available_units.push("swiss_guards");
			}
		},
		sustained_bombardment: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Sustained bombardment is a tactic used to suppress enemy forces by constant, round the clock firing of artillery that can be used to great effect, especially during sieges.",
			prerequisite_techs: ["proliferation_of_firearms", "field_culverins"],
			research_cost: 250,
			category: "military_technology",
			modifiers: [
				"**+10%** Artillery AP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.10;
			}
		},
		demi_cannon: {
			icon: "<:artillery:716821195055431681>",
			description: "The demi-cannon was a medium size cannon used primarily at sea, but also on land, that could fire projectiles weighing up to 32 pounds.",
			prerequisite_techs: ["proliferation_of_firearms", "field_culverins"],
			research_cost: 250,
			category: "military_technology",
			modifiers: [
				"Enables **Demi-Cannon**",
				"**+5%** Naval AP"
			],
			unlocks: function (usr) {
				usr.available_units.push("demi_cannon");
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
			}
		},
		matchlock_infantry: {
			icon: "<:active_personnel:716820390474940426>",
			description: "Matchlock infantry debuted beginning in the 16th century that featured heavily during the Thirty Years' War, that no longer required an external source of ignition. Unfortunately, upkeep was high as matchlock infantry had to keep their matches constantly burning.",
			prerequisite_techs: ["snaphance_musket"],
			research_cost: 250,
			category: "military_technology",
			modifiers: [
				"Enables **Matchlock Infantry**",
				"**+10%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.available_units.push("matchlock_infantry");
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
			}
		},
		pike_and_shot: {
			icon: "<:colonisation:716821194891853826>",
			description: "Pike and shot were mixed equipment units that sought to take advantage of the defensiveness of the pike coupled with the offensiveness of early modern firearms in order to maximise damage on the enemy. They were rendered obsolete with the advent of the bayonet.",
			prerequisite_techs: ["the_arquebus","tercio"],
			research_cost: 250,
			category: "military_technology",
			modifiers: [
				"Enables **Pike and Shot**"
			],
			unlocks: function (usr) {
				usr.available_units.push("pike_and_shot");
			}
		},
		professional_officers: {
			icon: "<:aristocrats:732730754643132457>",
			description: "By hiring professional officers instead of relying on aristocrats in the military, we can increase our military professionalism and the quality of our commanders on the field.",
			prerequisite_techs: ["sustained_bombardment"],
			research_cost: 350,
			category: "military_technology",
			modifiers: [
				"**+5%** Infantry AP",
				"**+5%** Infantry DP",
				"**+5%** Artillery AP",
				"**+5%** Artillery DP",
				"**+5%** Training Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.05;
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.05;
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
				usr.modifiers.ground_artillery_dp = usr.modifiers.ground_artillery_dp + 0.05;
				usr.modifiers.training_cost = usr.modifiers.training_cost + 0.05;
			}
		},
		field_cannon: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Beginning in the Thirty Years' War, field cannon were mobile artillery pieces that began to be protected by a shield for the artillerymen, which decreased their vulnerabilities from attack significantly.",
			prerequisite_techs: ["demi_cannon"],
			research_cost: 350,
			category: "military_technology",
			modifiers: [
				"Enables **Field Cannon**",
				"**+5%** Artillery DP",
				"Obsoletes **Long Cannons**"
			],
			unlocks: function (usr) {
				usr.available_units.push("field_cannon");
				usr.modifiers.ground_artillery_dp = usr.modifiers.ground_artillery_dp + 0.05;
				deleteElement(usr.available_units, "long_cannons", [usr, "obsolete_units"]);
			}
		},
		wheellock_musket: {
			icon: "<:soldiers:732730754592669702>",
			description: "The wheellock was the first self-igniting mechanism for firearms, and reduced maintenance of troops wielding it significantly as the match no longer had to be kept burning 24/7, having been replaced by a friction ignition mechanism instead.",
			prerequisite_techs: ["matchlock_infantry"],
			research_cost: 350,
			category: "military_technology",
			modifiers: [
				"Enables **Wheellock Infantry**",
				"Obsoletes **Matchlock Infantry**",
				"Obsoletes **Snaphaunce Infantry**",
				"Obsoletes **Snaplock Infantry**",
				"Obsoletes **Arquebusiers**",
				"**-10%** Training Cost"
			],
			unlocks: function (usr) {
				usr.available_units.push("wheellock_infantry");
				deleteElement(usr.available_units, "matchlock_infantry", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "snaphaunce_infantry", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "snaplock_infantry", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "arquebusiers", [usr, "obsolete_units"]);
				usr.modifiers.training_cost = usr.modifiers.training_cost - 0.10;
			}
		},
		primitive_sidearms: {
			icon: "<:coal:716791408714973204>",
			description: "Primitive sidearms, such as blunderbusses or pistols, were often used as last resort weapons for close combat by early modern infantry troops, as their reliability long-range could not be counted on.",
			prerequisite_techs: ["matchlock_infantry"],
			research_cost: 350,
			category: "military_technology",
			modifiers: [
				"**+5%** Infantry DP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.05;
			}
		},
		dragoons: {
			icon: "<:active_personnel:716820390474940426>",
			description: "Dragoons were a type of light cavalry mounted unit that used infantry firearms, and often disembarked off their mounts in order to conduct combat. Later on, however, they were trained in swordsmanship and were widely used until the end of World War I.",
			prerequisite_techs: ["pike_and_shot","hussars"],
			research_cost: 350,
			category: "military_technology",
			modifiers: [
				"Enables **Dragoons**"
			],
			unlocks: function (usr) {
				usr.available_units.push("dragoons");
			}
		},
		foreign_legions: {
			icon: "<:government_scroll:716828975175041054>",
			description: "Gradually, foreign legions such as the Wild Geese of Ireland, volunteer regiments, and regiments granted to other countries that served underneath a different country other than their own gradually came to replace mercenaries and served as the main source of manpower in their stead.",
			prerequisite_techs: ["swiss_guards"],
			research_cost: 350,
			category: "military_technology",
			modifiers: [
				"**+10%** National Manpower",
				"**+5%** Non-Core Manpower",
				"Obsoletes **Condottieri**",
				"Obsoletes **Landsknecht**",
				"Obsoletes **Swiss Guards**"
			],
			unlocks: function (usr) {
				usr.modifiers.national_manpower = usr.modifiers.national_manpower + 0.10;
				usr.modifiers.non_core_manpower = usr.modifiers.non_core_manpower + 0.05;
				deleteElement(usr.available_units, "condottieri", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "landsknecht", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "swiss_guards", [usr, "obsolete_units"]);
			}
		},
		professional_army: {
			icon: "<:active_personnel:716820390474940426>",
			description: "Standing armies began to turn into professional armies, and whereas levies, and occassionally conscripts, had previously been used to fulfil the manpower prerequisites of most nations, the advent of the professional army further cemented the power of state over its vassals.",
			prerequisite_techs: ["professional_officers"],
			research_cost: 500,
			category: "military_technology",
			modifiers: [
				"**+5%** Infantry AP",
				"**+5%** Infantry DP",
				"**+5%** Artillery AP",
				"**+5%** Artillery DP",
				"**+10%** Army Upkeep",
				"**+10%** Training Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.05;
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.05;
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
				usr.modifiers.ground_artillery_dp = usr.modifiers.ground_artillery_dp + 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.10;
				usr.modifiers.training_cost = usr.modifiers.training_cost + 0.10;
			}
		},
		demi_culverins: {
			icon: "<:artillery:716821195055431681>",
			description: "The demi-culverin, similar to the 'field culverin', was a mobile piece of artillery with improved effectiveness and range used in sieges.",
			prerequisite_techs: ["field_cannon"],
			research_cost: 500,
			category: "military_technology",
			modifiers: [
				"Enables **Demi-Culverin**"
			],
			unlocks: function (usr) {
				usr.available_units.push("demi_culverins");
			}
		},
		flintlock_infantry: {
			icon: "<:soldiers:732730754592669702>",
			description: "Flintlock weaponry was an umbrella term describing any firearm using flint as its primary striking mechanism. Due to its widespread accessibility and ease-of-use, it rapidly obsoleted earlier firearm ignition technologies.",
			prerequisite_techs: ["wheellock_musket","primitive_sidearms"],
			research_cost: 500,
			category: "military_technology",
			modifiers: [
				"Enables **Flintlock Infantry**",
				"Obsoletes **All Previous Ranged Infantry**"
			],
			unlocks: function (usr) {
				deleteElement(usr.available_units, "arquebusiers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "snaplock_infantry", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "snaphaunce_infantry", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "matchlock_infantry", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "wheellock_infantry", [usr, "obsolete_units"]);
				usr.available_units.push("flintlock_infantry");
			}
		},
		the_bayonet: {
			icon: "<:iron:716791408819961866>",
			description: "The bayonet drastically improved the defensiveness of musketeers and firearm infantry, as the lack of a standard melee weapon could now be made up for. By affixing bayonets onto the end of their muskets, early modern troops now had the capability to resist cavalry charges.",
			prerequisite_techs: ["wheellock_musket","primitive_sidearms"],
			research_cost: 500,
			category: "military_technology",
			modifiers: [
				"**+10%** Infantry DP",
				"Obsoletes **Pike and Square**",
				"Obsoletes **Tercio**",
				"Obsoletes **Pike and Shot**"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.10;
				deleteElement(usr.available_units, "pike_and_square", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "tercio", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "pike_and_shot", [usr, "obsolete_units"]);
			}
		},
		early_colonial_troops: {
			icon: "<:old_map:716821884867444746>",
			description: "Early colonial militia were typically tasked with guarding stockades, forts, and various frontier settlements from attack, and were often coupled with friendly natives for manpower support.",
			prerequisite_techs: ["foreign_legions"],
			research_cost: 500,
			category: "military_technology",
			modifiers: [
				"**+5%** Non-Core Manpower",
				"**+1** Maximum Expeditions"
			],
			unlocks: function (usr) {
				usr.modifiers.non_core_manpower = usr.modifiers.non_core_manpower + 0.05;
				usr.modifiers.maximum_expeditions = usr.modifiers.maximum_expeditions + 1;
			}
		},
		regular_conscription: {
			icon: "<:old_scroll:716828676880334881>",
			description: "Regular conscription, or the draft of available conscripts during times of war, was the predecessor to the levee en masse, and allowed early nation-states to rapidly mobilise military assets to use at their disposal.",
			prerequisite_techs: ["professional_army"],
			research_cost: 650,
			category: "military_technology",
			modifiers: [
				"**+10%** National Manpower"
			],
			unlocks: function (usr) {
				usr.modifiers.national_manpower = usr.modifiers.national_manpower + 0.10;
			}
		},
		minions: {
			icon: "<:artillery:716821195055431681>",
			description: "Minions were small cannons that typically armed merchant trade ships, allowing them to carry extra weight not related to armaments whilst keeping their cargo safe.",
			prerequisite_techs: ["demi_culverins"],
			research_cost: 650,
			category: "military_technology",
			modifiers: [
				"Enables **Minions**",
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.available_units.push("minions");
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		musketeers: {
			icon: "<:active_personnel:716820390474940426>",
			description: "Musketeers, the mainstay of line infantry warfare, came about as a result of the advent of the bayonet, and the widescale availability of the flintlock firing mechanism. They boasted a good rate of fire (for the time), and had significant offensive advantages as they could engage enemy units at range, or opt for a bayonet charge.",
			prerequisite_techs: ["flintlock_infantry","the_bayonet"],
			research_cost: 650,
			category: "military_technology",
			modifiers: [
				"Enables **Musketeers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("musketeers");
			}
		},
		improved_grenades: {
			icon: "<:coal:716791408714973204>",
			description: "Improved reliability for grenades help ensure the safety of the soldier and also unlock further offensive capabilities in which they can be used.",
			prerequisite_techs: ["demi_culverins"],
			research_cost: 650,
			category: "military_technology",
			modifiers: [
				"**+5%** Infantry AP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.05;
			}
		},
		trade_company_mercenaries: {
			icon: "<:trade:716828677115084812>",
			description: "Mercenaries hired by trade companies helped to protect their trading posts and valuable goods in exotic lands from being pillaged or stolen.",
			prerequisite_techs: ["early_colonial_troops"],
			research_cost: 650,
			category: "military_technology",
			modifiers: [
				"**+5%** Non-Core Manpower"
			],
			unlocks: function (usr) {
				usr.modifiers.non_core_manpower = usr.modifiers.non_core_manpower + 0.05;
			}
		},
		siege_artillery: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Siege artillery were large-calibre artillery pieces with low mobility designed specially for putting cities underneath siege.",
			prerequisite_techs: ["minions"],
			research_cost: 750,
			category: "military_technology",
			modifiers: [
				"Enables **Siege Artillery**"
			],
			unlocks: function (usr) {
				usr.available_units.push("siege_artillery");
			}
		},
		line_infantry: {
			icon: "<:manpower:716817688705499177>",
			description: "Line infantry became the mainstay formations of continental European armies at home and abroad throughout the 18th century as earlier melee infantry classes were quickly outpaced in development, and cavalry became increasingly obsolete.",
			prerequisite_techs: ["musketeers"],
			research_cost: 750,
			category: "military_technology",
			modifiers: [
				"Enables **Line Infantry**",
				"Obsoletes **Flintlock Infantry**"
			],
			unlocks: function (usr) {
				usr.available_units.push("siege_artillery");
				deleteElement(usr.available_units, "flintlock_infantry", [usr, "obsolete_units"]);
			}
		},
		sepoys: {
			icon: "<:active_personnel:716820390474940426>",
			description: "Sepoys were soldiers of mainly Indian origin that were armed with muskets and helped to server in continental Indian armies and overseas European ones as well.",
			prerequisite_techs: ["trade_company_mercenaries"],
			research_cost: 750,
			category: "military_technology",
			modifiers: [
				"**+5%** Non-Core Manpower",
				"**-5%** Army Upkeep",
				"**+1** Maximum Expeditions"
			],
			unlocks: function (usr) {
				usr.modifiers.non_core_manpower = usr.modifiers.non_core_manpower + 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.05;
				usr.modifiers.maximum_expeditions = usr.modifiers.maximum_expeditions + 1;
			}
		},
		mysorean_rocket: {
			icon: "<:coal:716791408714973204>",
			description: "The Mysorean rocket was a key asset of the Mysoreans during the Anglo-Mysore wars, with the weapon being so effective at causing panic amongst advancing infantry that it was later adopted by the British underneath the improved Congreve Rocket.",
			prerequisite_techs: ["siege_artillery"],
			research_cost: 900,
			category: "military_technology",
			modifiers: [
				"Enables **Mysorean Rocket**",
				"**+5%** Artillery AP"
			],
			unlocks: function (usr) {
				usr.available_units.push("mysorean_rocket");
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
			}
		},
		grenadiers: {
			icon: "<:manpower:716817688705499177>",
			description: "Grenadiers, widely used during the Napoleonic Wars and late 18th century warfare, were soldiers that specialised in the throwing of grenades, alongside traditional musket warfare.",
			prerequisite_techs: ["improved_grenades","line_infantry"],
			research_cost: 900,
			category: "military_technology",
			modifiers: [
				"Enables **Grenadiers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("grenadiers");
			}
		},
		early_trenches: {
			icon: "<:workers:732730754735276124>",
			description: "Trenches and related earthworks began to first take shape around the time of line battle warfare, with earthworks being able to cover the firing infantry as they were reloading.",
			prerequisite_techs: ["line_infantry"],
			research_cost: 900,
			category: "military_technology",
			modifiers: [
				"**+10%** Infantry DP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.10;
			}
		},
		uhlans: {
			icon: "<:soldiers:732730754592669702>",
			description: "Uhlans were general-purpose cavalry units originating in Poland that eventually saw widespread use by the end of the 19th century as fast, mobile cavalry units that could enforce occupation of a territory quickly.",
			prerequisite_techs: ["dragoons"],
			research_cost: 900,
			category: "military_technology",
			modifiers: [
				"Enables **Uhlans**"
			],
			unlocks: function (usr) {
				usr.available_units.push("uhlans");
			}
		},
		indigenous_troops: {
			icon: "<:trade:716828677115084812>",
			description: "Indigenous troops were native soldiers that often played key supporting roles in colonial conflicts and were recruited with the promise of steady pay and higher social status.",
			prerequisite_techs: ["sepoys"],
			research_cost: 900,
			category: "military_technology",
			modifiers: [
				"**+3%** Non-Core Manpower",
				"**+5%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.non_core_manpower = usr.modifiers.non_core_manpower + 0.03;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
			}
		},
		dream_of_flight: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Since ancient times, man has dreamed of being able to fly. With modern advances and the discovery of lighter than air elements, the potential to fulfil this dream is more likely than ever ...",
			prerequisite_techs: ["regular_conscription","mysorean_rocket"],
			research_cost: 1000,
			category: "military_technology",
			modifiers: [
				"Enables **Aeroports**",
				"**+5%** Research Speed"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("aeroports");
				usr.modifiers.research_efficiency = usr.modifiers.research_efficiency + 0.05;
			}
		},
		light_infantry: {
			icon: "<:manpower:716817688705499177>",
			description: "Light infantry are specialised units that enable fast infiltration behind enemy lines and flanking manoeuvres, despite their light armaments.",
			prerequisite_techs: ["grenadiers"],
			research_cost: 1000,
			category: "military_technology",
			modifiers: [
				"Enables **Light Infantry**"
			],
			unlocks: function (usr) {
				usr.available_units.push("light_infantry");
			}
		},
		colonial_garrisons: {
			icon: "<:old_map:716821884867444746>",
			description: "By relying on colonial and indigenous manpower to defend our outposts, we can lessen the burden and army upkeep of ourselves, and save our manpower for our own purposes.",
			prerequisite_techs: ["indigenous_troops"],
			research_cost: 1000,
			category: "military_technology",
			modifiers: [
				"**+5%** Non-Core Manpower",
				"**-8%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.non_core_manpower = usr.modifiers.non_core_manpower + 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.08;
			}
		},
		conscription_and_mobilisation: {
			icon: "<:building:716827579650408538>",
			description: "By conducting censuses of all able-bodied men in our country, we can begin to mobilise increasingly large numbers of troops in time of war.",
			prerequisite_techs: ["dream_of_flight"],
			research_cost: 1200,
			category: "military_technology",
			modifiers: [
				"Unlocks **Mobilisation - Line Infantry**",
				"**+10%** National Manpower",
				"**-5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.enable_mobilisation = true;
				usr.mobilise_unit = "line_infantry";
				usr.modifiers.national_manpower = usr.modifiers.national_manpower + 0.10;
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency - 0.05;
			}
		},
		carronade: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Beginning in the late 18th century, carronades were light cannons that helped protect trade shipments, and could also double as highly mobile artipllery on conventional battlefields.",
			prerequisite_techs: ["mysorean_rocket"],
			research_cost: 1200,
			category: "military_technology",
			modifiers: [
				"Enables **Carronades**",
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.available_units.push("carronades");
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		fusiliers: {
			icon: "<:soldiers:732730754592669702>",
			description: "Fusiliers, typically armed with heavy infantry weapons that featured heavily during the Napoleonic Wars, typically referred to a type of elite infantry, and were originally used to guard artillery pieces.",
			prerequisite_techs: ["light_infantry"],
			research_cost: 1200,
			category: "military_technology",
			modifiers: [
				"Enables **Fusiliers**",
				"**+5%** Artillery DP"
			],
			unlocks: function (usr) {
				usr.available_units.push("fusiliers");
				usr.modifiers.ground_artillery_dp = usr.modifiers.ground_artillery_dp + 0.05;
			}
		},
		improved_bayonet: {
			icon: "<:lead:716791408840671322>",
			description: "The defensibility of line infantry improved drastically with the advent of the socket bayonet and improvements in metallurgy and steel refinement.",
			prerequisite_techs: ["early_trenches"],
			research_cost: 1200,
			category: "military_technology",
			modifiers: [
				"**+10%** Infantry DP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.10;
			}
		},
		levee_en_masse: {
			icon: "<:taxes:716817688781127810>",
			description: "The levee-en-masse, made possible by increasingly organised censuses, allowed entire countries to be mobilised in the span of only a few months, creating armies of unprecedented size.",
			prerequisite_techs: ["conscription_and_mobilisation"],
			research_cost: 1400,
			category: "military_technology",
			modifiers: [
				"Unlocks **Conscription** Reforms",
				"**+5%** National Manpower"
			],
			unlocks: function (usr) {
				unlockReform(usr.id, "conscription");
				usr.modifiers.national_manpower = usr.modifiers.national_manpower + 0.05;
			}
		},
		congreve_rocket: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "The Congreve Rocket, named after Sir William Congreve in classic 19th century style, was a British military weapon designed after the Mysorean rockets which contributed to the effective defeat of the British in India twice.",
			prerequisite_techs: ["carronade"],
			research_cost: 1400,
			category: "military_technology",
			modifiers: [
				"Enables **Congreve Rockets**",
				"Obsoletes **Mysorean Rockets**"
			],
			unlocks: function (usr) {
				usr.available_units.push("congreve_rockets");
				deleteElement(usr.available_units, "mysorean_rockets", [usr, "obsolete_units"]);
			}
		},
		napoleonic_arms: {
			icon: "<:active_personnel:716820390474940426>",
			description: "Napoleonic arms were improved infantry weapons developed during the French Revolutionary Wars and the Napoleonic Wars that allowed for large-scale production to fit and equip armies of millions of men.",
			prerequisite_techs: ["fusiliers","improved_bayonet"],
			research_cost: 1400,
			category: "military_technology",
			modifiers: [
				"Enables **Napoleonic Infantry**",
				"**+10%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.available_units.push("napoleonic_infantry");
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.10;
			}
		},
		rifled_barrels: {
			icon: "<:iron:716791408819961866>",
			description: "Beginning in the late 18th century, rifled barrels on muskets allowed infantrymen to shoot with improved accuracy, despite longer loading times as they now had to pound the musketball down the barrel instead of letting it slide.",
			prerequisite_techs: ["fusiliers","improved_bayonet"],
			research_cost: 1400,
			category: "military_technology",
			modifiers: [
				"**+5%** Infantry AP",
				"**+5%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.10;
			}
		},
		nation_in_arms: {
			icon: "<:manpower:716817688705499177>",
			description: "With increased nationalism, and the advent of the concept of nations-in-arms, wars could now be fought on truly devastating scales, one that could require all men of fighting age to be drafted.",
			prerequisite_techs: ["levee_en_masse"],
			research_cost: 1600,
			category: "military_technology",
			modifiers: [
				"Unlocks **Mobilisation - Napoleonic Infantry**",
				"**+5%** National Manpower",
				"**+1** Barracks per city"
			],
			unlocks: function (usr) {
				usr.mobilise_unit = "napoleonic_infantry";
				usr.modifiers.national_manpower = usr.modifiers.national_manpower + 0.05;
				usr.modifiers.barracks = usr.modifiers.barracks + 1;
			}
		},
		rangers: {
			icon: "<:provinces:716809229603700737>",
			description: "Rangers were a late early-modern unit that possessed the mobility of light infantry, and were tasked with hitting behind enemy lines, or manoeuvring through tightly wooded areas.",
			prerequisite_techs: ["napoleonic_arms"],
			research_cost: 1600,
			category: "military_technology",
			modifiers: [
				"Enables **Rangers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("rangers");
			}
		},
		improved_fortifications: {
			icon: "<:stone:716796878649426020>",
			description: "With the advent of large-calibre cannon, fortifications now had to be improved and expertly designed by military engineers, and on the field, improvised to maximise the defensive potential of the local garrisons and infantry.",
			prerequisite_techs: ["napoleonic_arms"],
			research_cost: 1600,
			category: "military_technology",
			modifiers: [
				"**+5%** Infantry DP",
				"**+10%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.10;
			}
		},
		early_balloons: {
			icon: "<:diplomacy:716827579323121666>",
			description: "The Montgolfier hot-air balloon quickly became a sensation in an era where man taking flight was still unthinkable, and many quickly realised the reconaissance potentials of such devices, as enemy troops could now be viewed from far up, and scientific instruments carried high into the air.",
			prerequisite_techs: ["dream_of_flight"],
			research_cost: 1800,
			category: "military_technology",
			modifiers: [
				"This will lead to further discoveries in the field of aviation ..."
			],
			unlocks: function (usr) {
			}
		},
		defeat_in_detail: {
			icon: "<:infamy:716817688453709905>",
			description: "By dispersing our forces unequally and pretending that one of them is comprised of more men and materiel than it really is, we can lure the enemy into distributing their forces equally before shattering them one by one in a tactic known as defeat-in-detail.",
			prerequisite_techs: ["nation_in_arms"],
			research_cost: 1800,
			category: "military_technology",
			modifiers: [
				"**+10%** Infantry AP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.10;
			}
		},
		smoothbores: {
			icon: "<:artillery:716821195055431681>",
			description: "Smoothbore artillery pieces were some of the first introduced, but saw increased usage during the early 19th century despite decreased accuracy compared to rifled cannons.",
			prerequisite_techs: ["congreve_rocket"],
			research_cost: 1800,
			category: "military_technology",
			modifiers: [
				"Enables **Smoothbores**",
				"**-5%** Artillery AP",
				"Obsoletes **Siege Artillery",
				"Obsoletes **Congreve Rockets**"
			],
			unlocks: function (usr) {
				usr.available_units.push("smoothbores");
				usr.modifiers.ground_artillery_dp = usr.modifiers.ground_artillery_dp - 0.05;
				deleteElement(usr.available_units, "siege_artillery", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "congreve_rockets", [usr, "obsolete_units"]);
			}
		},
		guards: {
			icon: "<:manpower:716817688705499177>",
			description: "Guards were improved heavy infantry used for defensive purposes that eventually became incorporated into regular armies.",
			prerequisite_techs: ["rangers"],
			research_cost: 1800,
			category: "military_technology",
			modifiers: [
				"Enables **Guards**",
				"**+5%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.available_units.push("guards");
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
			}
		},
		improved_logistics: {
			icon: "<:trade:716828677115084812>",
			description: "By establishing dedicated logistics teams for our armies, we can help ensure that our troops are as well-supplied and clothed as possible.",
			prerequisite_techs: ["rifled_barrels"],
			research_cost: 1800,
			category: "military_technology",
			modifiers: [
				"**-10%** Army Upkeep",
				"**-5%** Training Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.10;
				usr.modifiers.training_cost = usr.modifiers.training_cost - 0.05;
			}
		},
		mounted_rifles: {
			icon: "<:soldiers:732730754592669702>",
			description: "Mounted rifles are cavalry units that carry rifled weapons, similar to dragoons that were used up until World War I.",
			prerequisite_techs: ["rifled_barrels"],
			research_cost: 1800,
			category: "military_technology",
			modifiers: [
				"Enables **Mounted Rifles**",
				"Obsoletes **Cuirassiers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("mounted_rifles");
				deleteElement(usr.available_units, "cuirassiers", [usr, "obsolete_units"]);
			}
		},
		gurkhas: {
			icon: "<:active_personnel:716820390474940426>",
			description: "Gurkhas were elite colonial troops from the Himalayas known for their determination and bravery in battle.",
			prerequisite_techs: ["improved_fortifications"],
			research_cost: 1800,
			category: "military_technology",
			modifiers: [
				"**+5%** Non-Core Manpower"
			],
			unlocks: function (usr) {
				usr.modifiers.non_core_manpower = usr.modifiers.non_core_manpower + 0.05;
			}
		},
		reconaissance_balloons: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "One would only be wise to realise the potential hiding behind the invention of the hot air balloon, as it could be used for spotting enemy movements from far away, similar to lookout tower, but at a much greater altitude, and with minimal construction cost as it can be transported easily.",
			prerequisite_techs: ["early_balloons"],
			research_cost: 2000,
			category: "military_technology",
			modifiers: [
				"Enables **Reconnaisance Balloons**"
			],
			unlocks: function (usr) {
				usr.available_units.push("reconaissance_balloons");
			}
		},
		rapid_manoeuvre: {
			icon: "<:building:716827579650408538>",
			description: "By using forced march to its maximum extent and light infantry and cavalry, we can enable our units to manoeuvre rapidly in enemy battlefields and on the map, increasing overall manoeuvrability.",
			prerequisite_techs: ["defeat_in_detail"],
			research_cost: 2000,
			category: "military_technology",
			modifiers: [
				"**+10%** Army Movement Speed"
			],
			unlocks: function (usr) {
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed + 0.10;
			}
		},
		riflemen: {
			icon: "<:manpower:716817688705499177>",
			description: "With the advent of the rifle and the rifled barrel itself, our troops can now wield much more accurate weaponry by using rifles and cartridges that no longer require the time-consuming reload of the musket.",
			prerequisite_techs: ["guards"],
			research_cost: 2000,
			category: "military_technology",
			modifiers: [
				"Enables **Riflemen**",
				"Unlocks **Mobilisation - Riflemen**",
				"**+5%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.available_units.push("riflemen");
				usr.mobilise_unit = "riflemen";
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
			}
		},
		cavalry_logistics: {
			icon: "<:trade:716828677115084812>",
			description: "As our armies now increasingly rely on weaponry and food supplied from home, it would only be wise to expand our cavalry operations to supply too, as horses can now transport goods in large numbers to our frontline troops.",
			prerequisite_techs: ["mounted_rifles"],
			research_cost: 2000,
			category: "military_technology",
			modifiers: [
				"**+5%** Army Movement Speed",
				"**-10%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed + 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.10;
			}
		},
		colonial_elite_officers: {
			icon: "<:aristocrats:732730754643132457>",
			description: "By using home aristocrats to rule over foreign lands in 'compelementary service' to the native rulers, we can improve stability in our overseas provinces and areas that might not be so friendly to us otherwise.",
			prerequisite_techs: ["gurkhas"],
			research_cost: 2000,
			category: "military_technology",
			modifiers: [
				"**+5%** Stability",
				"**+3%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.stability = usr.stability + 5;
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.03;
			}
		},
		rifled_cannons: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "With improved accuracy and ease of loading, rifled cannons soon obsoleted most previous cannons, including smoothbores, which would not be reintroduced until the advent of the Main Battle Tank and fin stabilisers.",
			prerequisite_techs: ["smoothbores"],
			research_cost: 2500,
			category: "military_technology",
			modifiers: [
				"Enables **Rifled Cannons**",
				"Obsoletes **All Previous Artillery**"
			],
			unlocks: function (usr) {
				usr.available_units.push("rifled_cannons");
				deleteElement(usr.available_units, "smoothbores", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "congreve_rocket", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "carronades", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "mysorean_rockets", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "siege_artillery", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "minions", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "demi_culverins", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "field_cannon", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "demi_cannon", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "field_culverins", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "long_cannons", [usr, "obsolete_units"]);
			}
		},
		modern_marines: {
			icon: "<:active_personnel:716820390474940426>",
			description: "Modern marines, typically soldiers designed specifically for amphibious invasions, usually operate underneath an independent branch of a nation's military and are known for having undergone rigorous training.",
			prerequisite_techs: ["riflemen"],
			research_cost: 2500,
			category: "military_technology",
			modifiers: [
				"Enables **Marines**",
				"**+5%** Upkeep Cost"
			],
			unlocks: function (usr) {
				usr.available_units.push("marines");
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
			}
		},
		dirigibles: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Dirigible balloons are lighter than air aircraft that possess the ability to navigate through the air via engines located onboard. The predecessor to zeppelins, they were some of the first aircraft used for military purposes aside from reconaissance.",
			prerequisite_techs: ["reconaissance_balloons"],
			research_cost: 3000,
			category: "military_technology",
			modifiers: [
				"Enables **Dirigibles**"
			],
			unlocks: function (usr) {
				usr.available_units.push("dirigibles");
			}
		},
		railwayguns: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "With the improvement of railway technology, railwayguns began to appear throughout early 20th century Europe, and were artillery pieces of massive calibre that could only be moved by rail that possessed the capability to fire at targets over a hundred kilometres away.",
			prerequisite_techs: ["rifled_cannons"],
			research_cost: 3000,
			category: "military_technology",
			modifiers: [
				"Enables **Railwayguns**"
			],
			unlocks: function (usr) {
				usr.available_units.push("railwayguns");
			}
		},
		breechloaded_rifles: {
			icon: "<:manpower:716817688705499177>",
			description: "Breechloading rifles are firearms for which the user can simply insert a cartridge in order to reload, in comparison to earlier musket designs, which required a lengthy reloading process, and could only be reloaded as such standing up.",
			prerequisite_techs: ["rifled_cannons"],
			research_cost: 3000,
			category: "military_technology",
			modifiers: [
				"Enables **Breechloaded Infantry**",
				"Obsoletes **Guards**",
				"Obsoletes **Rangers**",
				"Obsoletes **Napoleonic Infantry**",
				"Obsoletes **Fusiliers**",
				"Obsoletes **Light Infantry**",
				"Obsoletes **Musketeers**",
				"Obsoletes **Flintlock Infantry**",
				"Obsoletes **Wheellock Infantry**"
			],
			unlocks: function (usr) {
				usr.available_units.push("breechloaded_infantry");
				deleteElement(usr.available_units, "guards", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "rangers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "napoleonic_infantry", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "fusiliers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "light_infantry", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "musketeers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "flintlock_infantry", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "wheellock_infantry", [usr, "obsolete_units"]);
			}
		},
		railway_logistics: {
			icon: "<:coal:716791408714973204>",
			description: "By using railways to ship goods to our frontline troops, we can reduce expenditures on other slower forms of transport. However, army movement speed will also slow down as railways, if sabotaged by the enemy, must be brought back up to pace and repaired in order to meet logistical needs.",
			prerequisite_techs: ["guards","improved_logistics"],
			research_cost: 3000,
			category: "military_technology",
			modifiers: [
				"**-5%** Army Movement Speed",
				"**-10%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed - 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.10;
			}
		},
		modern_cavalry: {
			icon: "<:manpower:716817688705499177>",
			description: "By bringing our cavalry up to date, we can hopefully use it to exploit breakthroughs caused by the infantry and artillery and rapidly enforce occupation of selected territories.",
			prerequisite_techs: ["cavalry_logistics"],
			research_cost: 3000,
			category: "military_technology",
			modifiers: [
				"Enables **Modern Cavalry**",
				"**+5%** Army Movement Speed",
				"This will lead to new innovations in armoured warfare ..."
			],
			unlocks: function (usr) {
				usr.available_units.push("modern_cavalry");
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed + 0.05;
			}
		},
		colonial_mobilisation: {
			icon: "<:building:716827579650408538>",
			description: "By improving records not just at home, but overseas, we can bring a colonial army to bear to help its mother nation in times of need.",
			prerequisite_techs: ["colonial_elite_officers"],
			research_cost: 3000,
			category: "military_technology",
			modifiers: [
				"**+10%** Non-Core Manpower"
			],
			unlocks: function (usr) {
				usr.modifiers.non_core_manpower = usr.modifiers.non_core_manpower + 0.10;
			}
		},
		zeppelins: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "The successor to dirigibles, zeppelins were solid-steel airships capable of bombing cities from great heights.",
			prerequisite_techs: ["dirigibles"],
			research_cost: 3500,
			category: "military_technology",
			modifiers: [
				"Enables **Zeppelins**"
			],
			unlocks: function (usr) {
				usr.available_units.push("zeppelins");
			}
		},
		early_railway_mobilisation: {
			icon: "<:coal:716791408714973204>",
			description: "By planning mobilisation manoeuvres and logistics around railway tracks, we can increase our mobilisation speed and quality of arms as logistical problems will be reduced.",
			prerequisite_techs: ["dirigibles"],
			research_cost: 3500,
			category: "military_technology",
			modifiers: [
				"Unlocks **Mobilisation - Breechloaded Infantry**",
				"**-5%** Army Upkeep",
				"**-5%** Training Cost"
			],
			unlocks: function (usr) {
				usr.mobilise_unit = "breechloaded_infantry";
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.05;
				usr.modifiers.training_cost = usr.modifiers.training_cost - 0.05;
			}
		},
		field_artillery: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Introducing new field artillery of better quality and larger quantity could have a great impact on the field, especially when manned by professional artillery crews in rear lines.",
			prerequisite_techs: ["railwayguns"],
			research_cost: 3500,
			category: "military_technology",
			modifiers: [
				"Enables **Field Artillery**",
				"**+5%** Army Upkeep",
				"Obsoletes **Rifled Cannons**"
			],
			unlocks: function (usr) {
				usr.available_units.push("field_artillery");
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
				deleteElement(usr.available_units, "rifled_cannons", [usr, "obsolete_units"]);
			}
		},
		franc_tireurs: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Franc-Tireurs, or Francs-Tireurs in French, literally meaning 'free shooters' were guerrilla fighters that operated from the Franco-Prussian War until the end of World War II known for wreaking havoc behind enemy lines by acting as civilian combatants.",
			prerequisite_techs: ["breechloaded_rifles"],
			research_cost: 3500,
			category: "military_technology",
			modifiers: [
				"Enables **Franc-Tireurs**, a unit that requires virtually only manpower."
			],
			unlocks: function (usr) {
				usr.available_units.push("franc_tireurs");
			}
		},
		advanced_trenches: {
			icon: "<:colonisation:716821194891853826>",
			description: "By planning out our trenches rather than building them hastily on the spot, and reinforcing them with wooden support posts, and ensuring right angles to minimise the shock of an artillery explosion or shrapnel, we can maximise defensive effectiveness in battle, especially if trench warfare takes hold ...",
			prerequisite_techs: ["railway_logistics"],
			research_cost: 3500,
			category: "military_technology",
			modifiers: [
				"**+15%** Infantry DP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.15;
			}
		},
		military_garrison: {
			icon: "<:soldiers:732730754592669702>",
			description: "Utilising overseas military garrisons in order to suppress revolts and maintain public order during times that the native colonial army is serving abroad could have great benefits in the realm of improving stability ...",
			prerequisite_techs: ["railway_logistics"],
			research_cost: 3500,
			category: "military_technology",
			modifiers: [
				"**+10%** Stability",
				"**+1** Barracks per city"
			],
			unlocks: function (usr) {
				usr.stability = usr.stability + 10;
				usr.modifiers.barracks = usr.modifiers.barracks + 1;
			}
		},
		biplanes: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Biplanes, the first heavier than air aircraft to ever have been used was developed in the earlier half of the 20th century and was used en masse for the first time in the Great War for reconaissance, bombing, and dogfighting.",
			prerequisite_techs: ["zeppelins"],
			research_cost: 4000,
			category: "military_technology",
			modifiers: [
				"Enables **Biplanes**",
				"**+5%** Air DP"
			],
			unlocks: function (usr) {
				usr.available_units.push("biplanes");
				usr.modifiers.aeroplanes_dp = usr.modifiers.aeroplanes_dp + 0.05;
			}
		},
		great_war_ncos: {
			icon: "<:aristocrats:732730754643132457>",
			description: "NCOs, or non-commissioned officers are officers not commissioned (through military academies and the like), but rather promoted on up through the regular ranks that came to serve great importance in modern warfare.",
			prerequisite_techs: ["early_railway_mobilisation"],
			research_cost: 4000,
			category: "military_technology",
			modifiers: [
				"**+5% Infantry DP",
				"**+5% Artillery AP",
				"**-5% Infantry AP",
				"**-5%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.05;
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.05;
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.05;
			}
		},
		logistics_companies: {
			icon: "<:trade:716828677115084812>",
			description: "Logistics companies are detachments of regular divisions in charge of organising and handling the logistical backend needed to keep armies well-supplied and fed.",
			prerequisite_techs: ["advanced_trenches"],
			research_cost: 4000,
			category: "military_technology",
			modifiers: [
				"**-5%** Army Movement Speed",
				"**-10%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed - 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.10;
			}
		},
		motor_war_cars: {
			icon: "<:government:716817688693047306>",
			description: "Motor War Cars were early experimental armoured cars that shielded the driver, and were often armed with machine guns. They were never used in combat.",
			prerequisite_techs: ["modern_cavalry"],
			research_cost: 4000,
			category: "military_technology",
			modifiers: [
				"Enables **Auto Plants**",
				"This will lead to further advancements in the field of armoured warfare ..."
			],
			unlocks: function (usr) {
				usr.available_buildings.push("auto_plants");
			}
		},
		incendiary_ammunition: {
			icon: "<:coal:716791408714973204>",
			description: "Incendiary ammunition allowed for improved defence of cities as zeppelin bombers no longer held the capability to bomb cities unimpeded.",
			prerequisite_techs: ["biplanes"],
			research_cost: 4500,
			category: "military_technology",
			modifiers: [
				"**+5%** Army Upkeep",
				"**+5%** Training Cost",
				"**-5%** Air AP",
				"**+10%** Air DP",
				"Obsoletes **Reconaissance Balloons**",
				"Obsoletes **Dirigibles**",
				"Obsoletes **Zeppelins**"
			],
			unlocks: function (usr) {
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
				usr.modifiers.training_cost = usr.modifiers.training_cost + 0.05;
				usr.modifiers.aeroplanes_ap = usr.modifiers.aeroplanes_ap - 0.05;
				usr.modifiers.aeroplanes_dp = usr.modifiers.aeroplanes_dp + 0.10;
				deleteElement(usr.available_units, "reconaissance_balloons", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "dirigibles", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "zeppelins", [usr, "obsolete_units"]);
			}
		},
		early_bombers: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Early bombers were often large biplanes that could carry a few bombs in their bomb load, and flew relatively low over enemy targets, often without fighter escorts.",
			prerequisite_techs: ["biplanes"],
			research_cost: 4500,
			category: "military_technology",
			modifiers: [
				"Enables **Early Bombers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("early_bombers");
			}
		},
		mobilisation_timetables: {
			icon: "<:building:716827579650408538>",
			description: "By planning mobilisations around strict timetables, general mobilisation of the population could now take place with rapidity, and with better arms as logistics had already been sorted out beforehand.",
			prerequisite_techs: ["great_war_ncos"],
			research_cost: 4500,
			category: "military_technology",
			modifiers: [
				"Unlocks **Mobilisation - Bolt Action Infantry**",
				"**+5%** Army Movement Speed"
			],
			unlocks: function (usr) {
				usr.mobilise_unit = "bolt_action_infantry";
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed + 0.05;
			}
		},
		artillery_howitzers: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Artillery howitzers were conventional artillery pieces used throughout the 20th century that shot projectiles over a long range, despite its short barrel.",
			prerequisite_techs: ["field_artillery"],
			research_cost: 4500,
			category: "military_technology",
			modifiers: [
				"Enables **Artillery Howitzers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("artillery_howitzers");
			}
		},
		bolt_action_infantry: {
			icon: "<:active_personnel:716820390474940426>",
			description: "Bolt-action rifles, known for their ease of use, served as a primary infantry weapon across European Continental armies during the Great War, but are typically used nowadays for guns of larger calibre.",
			prerequisite_techs: ["franc_tireurs","logistics_companies"],
			research_cost: 4500,
			category: "military_technology",
			modifiers: [
				"Enables **Bolt-Action Infantry**"
			],
			unlocks: function (usr) {
				usr.available_units.push("bolt_action_infantry");
			}
		},
		flamethrower_units: {
			icon: "<:cb:716828676855169107>",
			description: "Flamethrower units, often used for clearing out enemy trenches and occassional partisans were an effective way to intimidate enemies, despite the danger posed by using one.",
			prerequisite_techs: ["franc_tireurs","logistics_companies"],
			research_cost: 4500,
			category: "military_technology",
			modifiers: [
				"**+10%** Infantry AP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.10;
			}
		},
		armoured_cars: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "Armoured cars were land-based vehicles that often functioned as mobile strongpoints to protect infantry units and lead in charges, or in rather unsavoury circumstances, to serve as distraction for enemy artillery crews.",
			prerequisite_techs: ["motor_war_cars"],
			research_cost: 4500,
			category: "military_technology",
			modifiers: [
				"Enables **Armoured Cars**"
			],
			unlocks: function (usr) {
				usr.available_units.push("armoured_cars");
			}
		},
		improved_biplanes: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Later improvements in biplanes helped cement its dominance over the earlier observation balloons and dirigibles, eventually itself being replaced by monoplanes in the 1920s and 1930s.",
			prerequisite_techs: ["incendiary_ammunition"],
			research_cost: 5000,
			category: "military_technology",
			modifiers: [
				"Enables **Improved Biplanes**"
			],
			unlocks: function (usr) {
				usr.available_units.push("improved_biplanes");
			}
		},
		trench_warfare: {
			icon: "<:soldiers:732730754592669702>",
			description: "As war increasingly became more total, and armies of millions attempted to outflank armies of millions, perhaps it was only inevitable that war would grind to a halt, and that both sides would be forced to win it only one way - last man standing.",
			prerequisite_techs: ["mobilisation_timetables","artillery_howitzers"],
			research_cost: 5000,
			category: "military_technology",
			modifiers: [
				"**+15%** Infantry DP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.15;
			}
		},
		creeping_barrage: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "The creeping barrage is an artillery method that requires artillery pieces to be fired with great precision immediately in front of advancing troops so as to clear out enemy fortifications and defences. It was later improved using pre-sighting artillery.",
			prerequisite_techs: ["artillery_howitzers"],
			research_cost: 5000,
			category: "military_technology",
			modifiers: [
				"**+5%** Artillery AP",
				"**+10%** Training Cost",
				"**+5%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
				usr.modifiers.training_cost = usr.modifiers.training_cost + 0.10;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
			}
		},
		mg_companies: {
			icon: "<:active_personnel:716820390474940426>",
			description: "Machine gun companies, or MG companies for short, were companies that were given the special task of operating machine guns in order to improve the defensive capabilities of ordinary infantry in trenches. Ah, old colonial maxim, 'we have got the Maxim gun, and they do not'. Now everyone has them.",
			prerequisite_techs: ["bolt_action_infantry"],
			research_cost: 5000,
			category: "military_technology",
			modifiers: [
				"Enables **MG Companies**",
				"**+10%** Infantry DP"
			],
			unlocks: function (usr) {
				usr.available_units.push("mg_companies");
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.10;
			}
		},
		defence_in_depth: {
			icon: "<:old_map:716821884867444746>",
			description: "Defence-in-depth is a military tactic that attempts to stall the attacker by laying out layers of fortifications with the end goal of causing massive amounts of casualties on the opposing end.",
			prerequisite_techs: ["flamethrower_units"],
			research_cost: 5000,
			category: "military_technology",
			modifiers: [
				"**+5%** Infantry DP",
				"**+5%** Artillery DP",
				"**+10%** Army Upkeep",
				"**-5%** Army Movement Speed"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.05;
				usr.modifiers.ground_artillery_dp = usr.modifiers.ground_artillery_dp + 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.10;
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed - 0.05;
			}
		},
		landship: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "The landship was the name given to early tanks whose job was to roll over enemy trenches and smash holes in the lines for advancing infantry. They were often slow and cumbersome, and prone to malfunction.",
			prerequisite_techs: ["flamethrower_units"],
			research_cost: 5000,
			category: "military_technology",
			modifiers: [
				"Enables **Landships**"
			],
			unlocks: function (usr) {
				usr.available_units.push("landship");
			}
		},
		monoplane_fighters: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Monoplane fighters, lacking the fragility of earlier biplane fighters were first produced at the end of the First World War, but saw increased service throughout the 20s and 30s as they increasingly obsoleted earlier aircraft.",
			prerequisite_techs: ["improved_biplanes","early_bombers"],
			research_cost: 5500,
			category: "military_technology",
			modifiers: [
				"Enables **Monoplane Fighters**"
			],
			unlocks: function (usr) {
				usr.available_units.push("monoplane_fighters");
			}
		},
		monoplane_bombers: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Monoplane bombers, with extended fuel capacity and an improved bomb bay that could now hold multiple bombs, were capable of flying longer distances, and were first used in combat in the famous German Gotha raids on London.",
			prerequisite_techs: ["improved_biplanes","early_bombers"],
			research_cost: 5500,
			category: "military_technology",
			modifiers: [
				"Enables **Monoplane Bombers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("monoplane_bombers");
			}
		},
		modern_military_doctrine: {
			icon: "<:old_map:716821884867444746>",
			description: "Modern military doctrine, treating tactics and logistics as a science instead of an art, was borne out of the fire of the Great War, and eventually came to domineer the perspective on modern military thought.",
			prerequisite_techs: ["improved_biplanes","early_bombers","trench_warfare"],
			research_cost: 5500,
			category: "military_technology",
			modifiers: [
				"**+10%** Infantry AP",
				"**+5%** Artillery AP",
				"**+10%** Air AP",
				"**-5%** Army Upkeep",
				"**-10%** Infantry DP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.10;
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
				usr.modifiers.aeroplanes_ap = usr.modifiers.aeroplanes_ap + 0.10;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.05;
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp - 0.10;
			}
		},
		mobile_artillery: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Mobile artillery guns, often made mobile with the aid of a secondary motorised vehicle could be redeployed to needed sectors of the battlefield with relative speed, allowing for increased coverage with limited resources.",
			prerequisite_techs: ["creeping_barrage"],
			research_cost: 5500,
			category: "military_technology",
			modifiers: [
				"**+5%** Artillery AP",
				"**+5%** Army Movement Speed"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed + 0.05;
			}
		},
		great_war_infantry: {
			icon: "<:soldiers:732730754592669702>",
			description: "Infantrymen of the Great War were armed with a variety of different weapons, most of which were standard-issue and made by their respective countries. Over the course of the war, this equipment was adapted as new tactics and challenges became increasingly evident.",
			prerequisite_techs: ["mg_companies"],
			research_cost: 5500,
			category: "military_technology",
			modifiers: [
				"Enables **Great War Infantry**",
				"Obsoletes **Riflemen**",
				"Obsoletes **Breechloaded Infantry**"
			],
			unlocks: function (usr) {
				usr.available_units.push("great_war_infantry");
				deleteElement(usr.available_units, "riflemen", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "breechloaded_infantry", [usr, "obsolete_units"]);
			}
		},
		mobile_field_hospitals: {
			icon: "<:infamy:716817688453709905>",
			description: "During times of war, mobile field hospitals were often the only treatment that wounded soldiers could receive and served to treat serious injuries sustained on the battlefield in hopes of them making a speedy recovery and being able to return to the front.",
			prerequisite_techs: ["defence_in_depth"],
			research_cost: 5500,
			category: "military_technology",
			modifiers: [
				"**+2%** National Manpower",
				"**+5%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.national_manpower = usr.modifiers.national_manpower + 0.02;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
			}
		},
		motorised_infantry: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "Motorised infantry, or infantry travelling on motorised vehicles can help improve army movement speed and keep pace with breakthroughs and advances made by armoured vehicles.",
			prerequisite_techs: ["armoured_cars"],
			research_cost: 5500,
			category: "military_technology",
			modifiers: [
				"**+5%** Army Movement Speed"
			],
			unlocks: function (usr) {
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed + 0.05;
			}
		},
		light_tank: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "Light tanks, designed for speed and manoeuvrability, typically played supporting roles for the infantry.",
			prerequisite_techs: ["landship"],
			research_cost: 5500,
			category: "military_technology",
			modifiers: [
				"Enables **Light Tanks**"
			],
			unlocks: function (usr) {
				usr.available_units.push("light_tanks");
			}
		},
		superior_firepower: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Bullets are cheap, men are not. By overwhelming our enemy with artillery, we can ensure minimal casualties when our infantrymen do the mopping.",
			prerequisite_techs: ["modern_military_doctrine"],
			research_cost: 6000,
			category: "military_technology",
			modifiers: [
				"**+10%** Artillery AP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.10;
			}
		},
		ack_ack_guns: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Ack-ack guns, Archie, anti-aircraft guns, many words are used to describe the same weaponry necessary to shoot down aeroplanes. In order to avoid our civilian centres from being bombed, it is imperative that we manage to protect our cities properly.",
			prerequisite_techs: ["mobile_artillery"],
			research_cost: 6000,
			category: "military_technology",
			modifiers: [
				"Enables **Ack-Ack Guns** as a building in cities"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("ack_ack_guns");
			}
		},
		shock_troops: {
			icon: "<:soldiers:732730754592669702>",
			description: "Shock troops, mobile, elite soldiers specialised in hitting enemy defensive lines hard and fast without fear and scrambling from mound to mound for cover could help revolutionise the war effort by introducing new infantry tactics.",
			prerequisite_techs: ["mobile_artillery"],
			research_cost: 6000,
			category: "military_technology",
			modifiers: [
				"Enables **Shock Troops**",
				"**+10%** Infantry AP"
			],
			unlocks: function (usr) {
				usr.available_units.push("shock_troops");
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.10;
			}
		},
		chemical_cannisters: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Chemical cannisters, either released on the ground when winds are favourable, or served up as ammunition for our artillery howitzers, is an effective method in getting enemy troosp to panic before an advance is made.",
			prerequisite_techs: ["mobile_artillery"],
			research_cost: 6000,
			category: "military_technology",
			modifiers: [
				"**+5%** Infantry AP",
				"**+5%** Armoured AP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.05;
				usr.modifiers.ground_vehicles_ap = usr.modifiers.ground_vehicles_ap + 0.05;
			}
		},
		armoured_personnel_carriers: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "Armoured personnel carriers are not only transports designed to carry infantry rapidly, but to carry them whilst being protected. In addition, they come with some light armaments themselves, allowing for a light response to any enemy fire.",
			prerequisite_techs: ["mobile_artillery"],
			research_cost: 6000,
			category: "military_technology",
			modifiers: [
				"Enables **Armoured Personnel Carriers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("armoured_personnel_carriers");
			}
		},
		improved_tank_reliability: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "Despite a majority of tanks breaking down on the battlefield each time they are used, they have already shown their worth in combat, and so extra attention to improving their reliability should be made in order to further future advances.",
			prerequisite_techs: ["light_tank"],
			research_cost: 6000,
			category: "military_technology",
			modifiers: [
				"**+5% Armoured AP",
				"**+5%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_vehicles_ap = usr.modifiers.ground_vehicles_ap + 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
			}
		},
		propeller_fighters: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Propeller fighters, or fighters using the propeller as their main means of propulsion became increasingly common in the years leading up to the outbreak of the Second World War and came to be sme of the most widely recognised aircraft even today.",
			prerequisite_techs: ["monoplane_fighters"],
			research_cost: 6500,
			category: "military_technology",
			modifiers: [
				"Enables **Propeller Fighters**"
			],
			unlocks: function (usr) {
				usr.available_units.push("propeller_fighters");
			}
		},
		interwar_bombers: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Interwar bombers, or bombers built during the two decades of peace, increasingly became dominated by monoplane type bombers that held increased cargo capacity for bombs, resulting in more effective air raids as evidenced by the destruction of Guernica.",
			prerequisite_techs: ["monoplane_bombers"],
			research_cost: 6500,
			category: "military_technology",
			modifiers: [
				"Enables **Interwar Bombers**",
				"**+5%** Air AP"
			],
			unlocks: function (usr) {
				usr.available_units.push("interwar_bombers");
				usr.modifiers.aeroplanes_ap = usr.modifiers.aeroplanes_ap + 0.05;
			}
		},
		war_of_movement: {
			icon: "<:old_map:716821884867444746>",
			description: "War of movement was the beginning of the doctrine known as manoeuvre warfare, and was first employed in the closing days of the First World War, in the Hundred Days' Offensive as the Allied armies sought to beat back the German army via shock and disruption.",
			prerequisite_techs: ["superior_firepower"],
			research_cost: 6500,
			category: "military_technology",
			modifiers: [
				"**+10%** Infantry AP",
				"**+5%** Artillery AP",
				"**+10%** Armour AP",
				"**+10%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.10;
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
				usr.modifiers.ground_vehicles_ap = usr.modifiers.ground_vehicles_ap + 0.10;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.10;
			}
		},
		freikorps: {
			icon: "<:soldiers:732730754592669702>",
			description: "The German Freikorps were post-war volunteer troops often comprised of veterans of the Great War that were said to be the result of difficulty to readjust back to normal civilian life, and helped quash the German Revolution and the Spartacist Uprising. They were also known for their role in the Baltic conflicts.",
			prerequisite_techs: ["shock_troops"],
			research_cost: 6500,
			category: "military_technology",
			modifiers: [
				"Enables **Freikorps**"
			],
			unlocks: function (usr) {
				usr.available_units.push("freikorps");
			}
		},
		interwar_tanks: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "With new experiments being conducted, and the agreement that tanks should be designed around a central turret, interwar tanks became some of the first truly recognisable tanks in service, but continued to face reliability issues.",
			prerequisite_techs: ["improved_tank_reliability"],
			research_cost: 6500,
			category: "military_technology",
			modifiers: [
				"Enables **Interwar Tanks**",
				"Obsoletes **Landship**"
			],
			unlocks: function (usr) {
				usr.available_units.push("interwar_tanks");
				deleteElement(usr.available_units, "landship", [usr, "obsolete_units"]);
			}
		},
		fighters: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "At the outbreak of the Second World War, increasingly effective ways to intercept enemy bombers were developed, and the concept of bomber escorts were first suggested, leading to a competition between interception and escort range. The golden age of dogfighting begins ...",
			prerequisite_techs: ["improved_tank_reliability"],
			research_cost: 7000,
			category: "military_technology",
			modifiers: [
				"Enables **Fighters**",
				"Obsoletes **Biplanes**",
				"Obsoletes **Improved Biplanes**"
			],
			unlocks: function (usr) {
				usr.available_units.push("fighters");
				deleteElement(usr.available_units, "biplanes", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "improved_biplanes", [usr, "obsolete_units"]);
			}
		},
		combined_arms_doctrine: {
			icon: "<:old_map:716821884867444746>",
			description: "Combined arms doctrine is a military theory in which all available assets of a diverse nature at the disposal of an attacking country are employed in mass formations in order to attempt a successful breakthrough.",
			prerequisite_techs: ["war_of_movement"],
			research_cost: 7000,
			category: "military_technology",
			modifiers: [
				"**+5%** Infantry DP",
				"**+5%** Armoured AP",
				"**+3%** Artillery AP",
				"**+10%** Army Movement Speed",
				"**+1** Aeroport per city",
				"**+1** Barracks per city",
				"**+1** Artillery Factory per city",
				"**+1** Auto Plant per city",
				"**+5%** Army Upkeep",
				"**+5%** Training Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.05;
				usr.modifiers.ground_vehicles_ap = usr.modifiers.ground_vehicles_ap + 0.05;
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed + 0.10;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
				usr.modifiers.training_cost = usr.modifiers.training_cost + 0.05;
				usr.modifiers.aeroports = usr.modifiers.aeroports + 1;
				usr.modifiers.barracks = usr.modifiers.barracks + 1;
				usr.modifiers.artillery_factories = usr.modifiers.artillery_factories + 1;
				usr.modifiers.auto_plants = usr.modifiers.auto_plants + 1;
			}
		},
		long_range_artillery: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Long-range artillery, used exclusively for bombardment of distant targets, can prove to be a valuable tool when used en masse as a blunt instrument against enemy forces, a blunt instrument that does not require the expenditure of our own manpower.",
			prerequisite_techs: ["ack_ack_guns"],
			research_cost: 7000,
			category: "military_technology",
			modifiers: [
				"Enables **Long-Range Artillery**",
				"Obsoletes **Railwayguns**",
				"Obsoletes **Field Artillery**"
			],
			unlocks: function (usr) {
				usr.available_units.push("long_range_artillery");
				deleteElement(usr.available_units, "railwayguns", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "field_artillery", [usr, "obsolete_units"]);
			}
		},
		modern_military_engineering: {
			icon: "<:steel:716791408828088420>",
			description: "Modern military engineers should be a flexible and adapatable tool that are always needed, but also always reliable for overcoming adverse situations.",
			prerequisite_techs: ["shock_troops","chemical_cannisters"],
			research_cost: 7000,
			category: "military_technology",
			modifiers: [
				"**+10%** Infantry AP",
				"**+5%** Artillery AP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.10;
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
			}
		},
		half_track: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "Half-tracks are military vehicles that combine both regular tyred wheels at the front, and tracked wheels at the back for maximum manoeuvrability. They were typically armed with machine guns and carried on board various infantry soldiers.",
			prerequisite_techs: ["armoured_personnel_carriers"],
			research_cost: 7000,
			category: "military_technology",
			modifiers: [
				"Enables **Half Tracks**",
				"Obsoletes **All Previous Cavalry**"
			],
			unlocks: function (usr) {
				usr.available_units.push("half_tracks");
				deleteElement(usr.available_units, "lance_cavalry", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "heavy_cavalry", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "light_cavalry", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "cuirassiers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "hussars", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "dragoons", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "uhlans", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "mounted_rifles", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "modern_cavalry", [usr, "obsolete_units"]);
			}
		},
		medium_tank: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "The medium tank was the predecessor to the modern main battle tank that sought to keep the manoeuvrability and mobility of light tanks, and the armaments and armour of heavier ones. They tended to form the main bodies of armoured corps.",
			prerequisite_techs: ["interwar_tanks"],
			research_cost: 7000,
			category: "military_technology",
			modifiers: [
				"Enables **Medium Tanks**"
			],
			unlocks: function (usr) {
				usr.available_units.push("medium_tanks");
			}
		},
		advanced_fighters: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Advanced fighters were produced in the latter days of World War II and were primarily built to escort bombers instead of flying solo sorties over enemy airfields.",
			prerequisite_techs: ["fighters"],
			research_cost: 7500,
			category: "military_technology",
			modifiers: [
				"Enables **Advanced Fighters**",
				"**+5%** Air DP"
			],
			unlocks: function (usr) {
				usr.available_units.push("advanced_fighters");
				usr.modifiers.aeroplanes_dp = usr.modifiers.aeroplanes_dp + 0.05;
			}
		},
		bombers: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Strategic bombers meant to target civilian and industrial targets became increasingly common in the Second World War, as warfare reached new heights of totality, and bombs often fell kilometres off-target.",
			prerequisite_techs: ["interwar_bombers"],
			research_cost: 7500,
			category: "military_technology",
			modifiers: [
				"Enables **Bombers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("bombers");
			}
		},
		mobile_warfare_doctrine: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "Mobile warfare, a variant of manoeuvre warfare, is a military school of thought that believes in the capability of armoured units and aeroplanes to act as the initial instruments on which to acheive a breakthrough of the enemy lines. Thereafter, in order to reduce logistical problems, motorised infantry should be used.",
			prerequisite_techs: ["combined_arms_doctrine"],
			research_cost: 7500,
			category: "military_technology",
			modifiers: [
				"**+10%** Armoured AP",
				"**+5%** Air AP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_vehicles_ap = usr.modifiers.ground_vehicles_ap + 0.10;
				usr.modifiers.aeroplanes_ap = usr.modifiers.aeroplanes_ap + 0.05;
			}
		},
		modern_howitzers: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Modern howitzers typically featured rifled barrels and improved sights as well as longer barrels and are meant to be used in conjunction with motorised units.",
			prerequisite_techs: ["long_range_artillery"],
			research_cost: 7500,
			category: "military_technology",
			modifiers: [
				"Enables **Modern Howitzers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("modern_howitzers");
			}
		},
		paratroopers: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Paratroopers are light infantry units capable of infiltrating behind enemy lines to capture strategic targets, but do not come with much armament themselves, and cannot be used single-handedly to support offensives, as seen in Operation Market Garden.",
			prerequisite_techs: ["freikorps"],
			research_cost: 7500,
			category: "military_technology",
			modifiers: [
				"Enables **Paratroopers**",
				"**+5%** Infantry AP"
			],
			unlocks: function (usr) {
				usr.available_units.push("paratroopers");
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.05;
			}
		},
		support_companies: {
			icon: "<:trade:716828677115084812>",
			description: "Support companies are often used to supply modern armies, not just logistically, but with intelligence, anti-aircraft capabilities, and other secondary purposes.",
			prerequisite_techs: ["modern_military_engineering"],
			research_cost: 7500,
			category: "military_technology",
			modifiers: [
				"**-15%** Army Upkeep",
				"**+5%** Training Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.15;
				usr.modifiers.training_cost = usr.modifiers.training_cost + 0.05;
			}
		},
		heavy_tank: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "The heavy tank is a slow, lumbering vehicle, but is heavily armoured and capable of punching through the armour of any lower tank. They were to be the emperors of the battlefield, the battleships on which generals have so often hinged their offensives in the 20th century.",
			prerequisite_techs: ["medium_tank"],
			research_cost: 7500,
			category: "military_technology",
			modifiers: [
				"Enables **Heavy Tank**",
				"**+5%** Armour AP"
			],
			unlocks: function (usr) {
				usr.available_units.push("heavy_tank");
				usr.modifiers.ground_vehicles_ap = usr.modifiers.ground_vehicles_ap + 0.05;
			}
		},
		extended_air_range: {
			icon: "<:petroil:716791408748658739>",
			description: "With advancements in fuel efficiency, and engines of improved power, fighter escorts can now accompany bombers all the way to their target, resulting in further damages on enemy cities.",
			prerequisite_techs: ["advanced_fighters","bombers"],
			research_cost: 8000,
			category: "military_technology",
			modifiers: [
				"**+5%** Army Movement Speed",
				"**+5%** Air AP"
			],
			unlocks: function (usr) {
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed + 0.05;
				usr.modifiers.aeroplanes_ap = usr.modifiers.aeroplanes_ap + 0.05;
			}
		},
		mass_mobilisation: {
			icon: "<:old_map:716821884867444746>",
			description: "As new wars became wars of totality, it became imperative that the now cemented nation-state be able to mobilise its entire population in times of need, regardless of rank, race, or age. With modern military science and pre-prepared general mobilisation lists, larger populations than ever before could be drafted.",
			prerequisite_techs: ["mobile_warfare_doctrine"],
			research_cost: 8000,
			category: "military_technology",
			modifiers: [
				"**+5%** National Manpower",
				"**+5%** Non-Core Manpower",
				"Unlocks **Mobilisation - Modern Infantry**"
			],
			unlocks: function (usr) {
				usr.modifiers.national_manpower = usr.modifiers.national_manpower + 0.05;
				usr.modifiers.non_core_manpower = usr.modifiers.non_core_manpower + 0.05;
				usr.mobilise_unit = "modern_infantry";
			}
		},
		sp_artillery: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "SP Artillery, or self-propelled artillery is a type of artillery gun that does not rely on the necessity of an external motorised unit to transport it in battle. These vehicles typically come with adequate protection for the driver, and are fully enclosed.",
			prerequisite_techs: ["modern_howitzers"],
			research_cost: 8000,
			category: "military_technology",
			modifiers: [
				"Enables **Self-Propelled Artillery**"
			],
			unlocks: function (usr) {
				usr.available_units.push("self_propelled_artillery");
			}
		},
		special_forces: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Special forces, in many ways, the successor to shock troops, were used to fulfil missions that required unconventional methods to acheive the intended objective.",
			prerequisite_techs: ["modern_howitzers"],
			research_cost: 8000,
			category: "military_technology",
			modifiers: [
				"Enables **Special Forces**",
				"**+5%** Infantry AP",
				"Obsoletes **Shock Troops**"
			],
			unlocks: function (usr) {
				usr.available_units.push("special_forces");
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.05;
				deleteElement(usr.available_units, "shock_troops", [usr, "obsolete_units"]);
			}
		},
		signal_companies: {
			icon: "<:checkmark:725550245051760671>",
			description: "Signal companies are support detachments that allow conventional regiments to communicate with each other more effectively, even without infrastructure, via wireless radio.",
			prerequisite_techs: ["support_companies"],
			research_cost: 8000,
			category: "military_technology",
			modifiers: [
				"**-10%** Army Upkeep",
				"**+5%** Army Movement Speed",
				"**+10%** Training Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.10;
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed + 0.05;
				usr.modifiers.training_cost = usr.modifiers.training_cost + 0.10;
			}
		},
		tank_destroyers: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "Tank destroyers, based off of light tanks, often did not have full enclosure, but had the speed and armaments needed to counter even the heaviest of tanks, and served as mobile anti-tank units.",
			prerequisite_techs: ["heavy_tank"],
			research_cost: 8000,
			category: "military_technology",
			modifiers: [
				"Enables **Tank Destroyer**"
			],
			unlocks: function (usr) {
				usr.available_units.push("tank_destroyers");
			}
		},
		rocket_interceptor: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Rocket interceptors were the first jet-powered aircraft to be used in a military context and were used to shoot down bomber aeroplanes in the closing days of World War II.",
			prerequisite_techs: ["extended_air_range"],
			research_cost: 8500,
			category: "military_technology",
			modifiers: [
				"Enables **Rocket Interceptors**"
			],
			unlocks: function (usr) {
				usr.available_units.push("rocket_interceptors");
			}
		},
		strategic_bombers: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Strategic bombers are aircraft capable of carrying massive payloads over long distances, typically to drop on civilian targets, but also on military.",
			prerequisite_techs: ["extended_air_range"],
			research_cost: 8500,
			category: "military_technology",
			modifiers: [
				"Enables **Strategic Bombers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("strategic_bombers");
			}
		},
		rocket_artillery: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Rocket artillery are a type of motorised artillery capable of firing rockets, eventually being armed with guided missiles that were able to strike targets with increasing accuracy.",
			prerequisite_techs: ["sp_artillery"],
			research_cost: 8500,
			category: "military_technology",
			modifiers: [
				"Enables **Rocket Artillery**",
				"**+5%** Artillery AP",
				"**+10% Army Upkeep"
			],
			unlocks: function (usr) {
				usr.available_units.push("rocket_artillery");
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.10;
			}
		},
		modern_infantry: {
			icon: "<:soldiers:732730754592669702>",
			description: "Modern infantry are meant to serve in general-purpose environments and storm cities and other dense environments where defensability is more feasible.",
			prerequisite_techs: ["special_forces","signal_companies"],
			research_cost: 8500,
			category: "military_technology",
			modifiers: [
				"Enables **Modern Infantry**",
				"Obsoletes **Freikorps**",
				"Obsoletes **Bolt Action Infantry**",
				"Obsoletes **Great War Infantry**"
			],
			unlocks: function (usr) {
				usr.available_units.push("modern_infantry");
				deleteElement(usr.available_units, "freikorps", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "bolt_action_infantry", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "great_war_infantry", [usr, "obsolete_units"]);
			}
		},
		troop_carriers: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "Troop carriers are motorised units specialising in rapid transport of infantry across vast swaths of terrain, allowing for improved mobility of armies.",
			prerequisite_techs: ["half_track"],
			research_cost: 8500,
			category: "military_technology",
			modifiers: [
				"Enables **Troop Carriers**",
				"**+5%** Army Movement Speed"
			],
			unlocks: function (usr) {
				usr.available_units.push("troop_carriers");
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed + 0.05;
			}
		},
		improved_medium_tank: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "Improved medium tanks, the forerunner to modern tanks, were built with increased precision sighting and armament, such that they were capable of piercing enemy targets from long distances.",
			prerequisite_techs: ["tank_destroyers"],
			research_cost: 8500,
			category: "military_technology",
			modifiers: [
				"Enables **Improved Medium Tanks**"
			],
			unlocks: function (usr) {
				usr.available_units.push("improved_medium_tanks");
			}
		},
		scout_helicopters: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Scout helicopters, typically primtive helicopters with little to no protection, were low-flying vehicles capable of moving rapidly to scout out enemy positions.",
			prerequisite_techs: ["rocket_interceptor"],
			research_cost: 9000,
			category: "military_technology",
			modifiers: [
				"Enables **Scout Helicopters**"
			],
			unlocks: function (usr) {
				usr.available_units.push("scout_helicopters");
			}
		},
		jet_fighters: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Fighter jets are modern aeroplanes, are fixed-wing aircraft often capable of acheiving of immediate subsonic, or supersonic speed and are built to establish air superiority over a battlefield.",
			prerequisite_techs: ["rocket_interceptor"],
			research_cost: 9000,
			category: "military_technology",
			modifiers: [
				"Enables **Jet Fighters**",
				"**+5%** Air AP"
			],
			unlocks: function (usr) {
				usr.available_units.push("jet_fighters");
				usr.modifiers.aeroplanes_ap = usr.modifiers.aeroplanes_ap + 0.05;
			}
		},
		counterterrorism: {
			icon: "<:cb:716828676855169107>",
			description: "With the rise of attacks on civilian targets during times of peace, efforts must be made to prevent and halt terrorists, especially in high-profile hostage situations, in order to reduce public fear.",
			prerequisite_techs: ["mass_mobilisation"],
			research_cost: 9000,
			category: "military_technology",
			modifiers: [
				"**+10%** Infantry DP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.10;
			}
		},
		precision_guidance_systems: {
			icon: "<:cb:716828676855169107>",
			description: "Through the creation of guided missile systems, artillery accuracy on the ground can be drastically improved, allowing for future extensions not just in range, but in the effectiveness of artillery as a whole.",
			prerequisite_techs: ["rocket_artillery"],
			research_cost: 9000,
			category: "military_technology",
			modifiers: [
				"**+10%** Artillery AP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.10;
			}
		},
		modern_armoured_car: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "The modern armoured car often has large armaments with only light armour, allowing them to penetrate heavy tanks. Unlike tank destroyers, however, the majority are fully enclosed and also built to carry personnel.",
			prerequisite_techs: ["troop_carriers"],
			research_cost: 9000,
			category: "military_technology",
			modifiers: [
				"Enables **Modern Armoured Cars**",
				"Obsoletes **Armoured Cars**"
			],
			unlocks: function (usr) {
				usr.available_units.push("modern_armoured_cars");
				deleteElement(usr.available_units, "armoured_cars", [usr, "obsolete_units"]);
			}
		},
		modern_tank: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "The advent of the moern tank, the immediate forerunner to the MBT, quickly rendered previous tanks obsolete as they featured a direct compromise between armour, armaments, and speed and were able to balance all effectively.",
			prerequisite_techs: ["improved_medium_tank"],
			research_cost: 9000,
			category: "military_technology",
			modifiers: [
				"Enables **Modern Tanks**",
				"Obsoletes **All Previous Armoured Units**"
			],
			unlocks: function (usr) {
				usr.available_units.push("modern_tanks");
				deleteElement(usr.available_units, "improved_medium_tanks", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "tank_destroyers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "heavy_tanks", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "medium_tanks", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "interwar_tanks", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "light_tanks", [usr, "obsolete_units"]);
			}
		},
		multirole_helicopters: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Multirole helicopters, first built during the Vietnam war, were helicopters designed for enemy suppression, airmobile tactics, and logistical purposes.",
			prerequisite_techs: ["scout_helicopters"],
			research_cost: 9500,
			category: "military_technology",
			modifiers: [
				"Enables **Multirole Helicopters**",
				"Obsoletes **Scout Helicopters**"
			],
			unlocks: function (usr) {
				usr.available_units.push("multirole_helicopters");
				deleteElement(usr.available_units, "scout_helicopters", [usr, "obsolete_units"]);
			}
		},
		multirole_fighters: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Multirole fighters, designed to handle a variety of tasks quickly came to replace earlier fighters as they could now be used for dogfighting purposes, as strike aircraft, or for payload delivery.",
			prerequisite_techs: ["jet_fighters"],
			research_cost: 9500,
			category: "military_technology",
			modifiers: [
				"Enables **Multirole Fighters**",
				"Obsoletes **All Previous Aeroplanes (Except for Jet Fighters and Strategic Bombers)**"
			],
			unlocks: function (usr) {
				usr.available_units.push("multirole_fighters");
				deleteElement(usr.available_units, "rocket_interceptors", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "advanced_fighters", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "fighters", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "propeller_fighters", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "monoplane_fighters", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "improved_biplanes", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "biplanes", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "early_bombers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "monoplane_bombers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "interwar_bombers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "bombers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "torpedo_bombers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "naval_bombers", [usr, "obsolete_units"]);
			}
		},
		stealth_bombers: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Designed to carry massive payloads from high altitudes without fear of being detected, stealth bombers are able to fly over extended durations of time and inflict massive amounts of damage on opponents, despite their cost.",
			prerequisite_techs: ["strategic_bombers"],
			research_cost: 9500,
			category: "military_technology",
			modifiers: [
				"Enables **Stealth Bombers**",
				"**+5%** Air AP"
			],
			unlocks: function (usr) {
				usr.available_units.push("stealth_bombers");
				usr.modifiers.aeroplanes_ap = usr.modifiers.aeroplanes_ap + 0.05;
			}
		},
		asymmetric_land_warfare: {
			icon: "<:old_map:716821884867444746>>",
			description: "Warfare is no longer confined to a singular dimension fought over land by conventional armies, but is now a matter of completely differing tactics and rules of war between different powers, often ending in unconventional warfare.",
			prerequisite_techs: ["counterterrorism"],
			research_cost: 9500,
			category: "military_technology",
			modifiers: [
				"**+10%** Infantry DP",
				"**+5%** Armour AP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.10;
				usr.modifiers.ground_vehicles_ap = usr.modifiers.ground_vehicles_ap + 0.05;
			}
		},
		combined_arms_infantry: {
			icon: "<:manpower:716817688705499177>",
			description: "By integrating anti-air and anti-tank capabilities into our soldiers, and combining them with other types of equipment such as IFVs and the capability to call in precision airstrikes, we can afford to adopt a combined arms mentality for them.",
			prerequisite_techs: ["modern_infantry"],
			research_cost: 9500,
			category: "military_technology",
			modifiers: [
				"Enables **Combined Arms Infantry**",
				"**+10%** Army Upkeep",
				"Obsoletes **Modern Infantry**"
			],
			unlocks: function (usr) {
				usr.available_units.push("combined_arms_infantry");
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.10;
				deleteElement(usr.available_units, "modern_infantry", [usr, "obsolete_units"]);
			}
		},
		modern_apc: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "Modern Armoured Personnel Carriers are typically meant to transport infantry safely whilst providing some form of protective cover from mines and other hazards. This will help improve our army mobility as our fleet of APCs are becoming increasingly outdated and obsolete.",
			prerequisite_techs: ["modern_armoured_car"],
			research_cost: 9500,
			category: "military_technology",
			modifiers: [
				"Enables **Modern APCs**",
				"**+10%** Army Movement Speed",
				"**+5%** Army Upkeep",
				"Obsoletes **Armoured Personnel Carriers**",
				"Obsoletes **Troop Carriers**",
				"Obsoletes **Half-Tracks**"
			],
			unlocks: function (usr) {
				usr.available_units.push("modern_apcs");
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed + 0.10;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
				deleteElement(usr.available_units, "armoured_personnel_carriers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "troop_carriers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "half_tracks", [usr, "obsolete_units"]);
			}
		},
		main_battle_tank: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "The Main Battle Tank (MBT) is a multipurpose unit designed for a variety of roles, including suppressive fire and offensive manoeuvres. Despite their fuel and production costs, they are typically robust units capable of attacking the enemy head-on.",
			prerequisite_techs: ["modern_tank"],
			research_cost: 9500,
			category: "military_technology",
			modifiers: [
				"Enables **MBTs**",
				"**+5%** Army Movement Speed",
				"**+10%** Army Upkeep",
				"**+5%** Unit Cost"
			],
			unlocks: function (usr) {
				usr.available_units.push("main_battle_tanks");
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed + 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.10;
				usr.modifiers.unit_cost = usr.modifiers.unit_cost + 0.05;
			}
		},
		drones: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Drones, or UAV's, are unmanned aerial vehicles capable of striking deep into enemy territory whilst being remote-controlled from a distance.",
			prerequisite_techs: ["multirole_fighters"],
			research_cost: 10000,
			category: "military_technology",
			modifiers: [
				"Enables **Drones**"
			],
			unlocks: function (usr) {
				usr.available_units.push("drones");
			}
		},
		contemporary_armies: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "The dawn of modern military thought has offered us new tactics regarding the role of infantry in warfare, and the various units appropriate for different types of terrain. By exploiting these advantages, we can gain a significant combat lead over our enemy. Unconventional warfare and hearts and minds are also being explored as well.",
			prerequisite_techs: ["stealth_bombers","asymmetric_land_warfare","precision_guidance_systems","combined_arms_infantry"],
			research_cost: 10000,
			category: "military_technology",
			modifiers: [
				"Unlocks **Mobilisation - Combined Arms Infantry**",
				"**+5%** Infantry DP"
			],
			unlocks: function (usr) {
				usr.mobilise_unit = "combined_arms_infantry";
				usr.modifiers.ground_units_dp = usr.modifiers.ground_units_dp + 0.05;
			}
		},
		contemporary_infantry: {
			icon: "<:manpower:716817688705499177>",
			description: "Modern infantry, borrowing from asymmetric warfare, must learn and adapt in order to suppress revolts and insurgencies often driven by unlawful combatants and terrorist organisations. As new threats to our renewed national security continue to present themselves, we must change our military doctrine accordingly.",
			prerequisite_techs: ["asymmetric_land_warfare","combined_arms_infantry"],
			research_cost: 10000,
			category: "military_technology",
			modifiers: [
				"Enables **Contemporary Infantry**"
			],
			unlocks: function (usr) {
				usr.available_units.push("contemporary_infantry");
			}
		},
		modern_support_companies: {
			icon: "<:active_personnel:716820390474940426>",
			description: "Modern support companies typically carry specialised equipment and are tasked with a wide range of roles in order to overcome any obstacles that a normal infantry battalion might face.",
			prerequisite_techs: ["signal_companies"],
			research_cost: 10000,
			category: "military_technology",
			modifiers: [
				"**+15%** Infantry AP",
				"**+5%** Artillery AP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.15;
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
			}
		},
		chobham_armour: {
			icon: "<:steel:716791408828088420>",
			description: "Chobham Armour is a type of composite armour originating in the U.K. that took advantage of the sheer hardness of ceramics to shatter enemy projectiles upon impact. The exact nature of this armour remains classified.",
			prerequisite_techs: ["modern_apc"],
			research_cost: 10000,
			category: "military_technology",
			modifiers: [
				"**+5%** Armour DP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_vehicles_dp = usr.modifiers.ground_vehicles_dp + 0.05;
			}
		},
		improved_sights: {
			icon: "<:government:716817688693047306>",
			description: "By improving our sights and adding night vision and thermal cameras, we can ensure that our tank crews are adequately equipped to deal with any situation where conventional vision alone is not enough.",
			prerequisite_techs: ["main_battle_tank"],
			research_cost: 10000,
			category: "military_technology",
			modifiers: [
				"**+10%** Armour AP"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_vehicles_ap = usr.modifiers.ground_vehicles_ap + 0.10;
			}
		},
		modern_helicopters: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Modern helicopters equipped with thermal sighting and missiles, are fast and quick aircraft meant for closer battlefield manoeuvres, although they remain distinctly vulnerable to infantry equipment such as MANPADS.",
			prerequisite_techs: ["multirole_helicopters"],
			research_cost: 10500,
			category: "military_technology",
			modifiers: [
				"Enables **Modern Helicopters**"
			],
			unlocks: function (usr) {
				usr.available_units.push("modern_helicopters");
			}
		},
		stealth_fighters: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Stealth fighters, designed to dodge radar and travel at supersonic speeds are fifth-generation jet fighters designed to establish aerial supremacy and drop ordnance on approaching targets.",
			prerequisite_techs: ["drones","stealth_bombers"],
			research_cost: 10500,
			category: "military_technology",
			modifiers: [
				"Enables **Stealth Fighters**"
			],
			unlocks: function (usr) {
				usr.available_units.push("stealth_fighters");
			}
		},
		cyberwarfare: {
			icon: "<:building:716827579650408538>",
			description: "Cyberwarfare is the militarised use of digital infrastructure with the express purpose of incapacitating an enemy belligerent. Such attacks typically target both civilian and military sectors reliant on electronic mediums.",
			prerequisite_techs: ["contemporary_armies"],
			research_cost: 10500,
			category: "military_technology",
			modifiers: [
				"**+10%** Infantry AP",
				"**+10%** Armour AP",
				"**+10%** Air AP",
				"**-10%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.ground_units_ap = usr.modifiers.ground_units_ap + 0.10;
				usr.modifiers.ground_vehicles_ap = usr.modifiers.ground_vehicles_ap + 0.10;
				usr.modifiers.aeroplanes_ap = usr.modifiers.aeroplanes_ap + 0.10;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.10;
			}
		},
		modern_mbt: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "In order to ensure that our tanks are able to remain competitive on the battlefield, we should consider installing upgraded armaments and weaponry onto them to make sure that they retain their edge, lest it be overtaken by other forces.",
			prerequisite_techs: ["chobham_armour","improved_sights"],
			research_cost: 10500,
			category: "military_technology",
			modifiers: [
				"Enables **Modern MBT**",
				"Obsoletes **Modern Tanks**",
				"Obsoletes **Main Battle Tanks**"
			],
			unlocks: function (usr) {
				usr.available_units.push("modern_mbts");
				deleteElement(usr.available_units, "modern_tanks", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "main_battle_tanks", [usr, "obsolete_units"]);
			}
		},
		railguns: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Railguns are pieces of artillery that use electromagneticism to launch kinetic projectiles at speeds of more than 3 kilometres a second. The damage itself relies purely on the shape, velocity and mass of the projectile fired.",
			prerequisite_techs: ["contemporary_armies"],
			research_cost: 10500,
			category: "military_technology",
			modifiers: [
				"Enables **Railguns**",
				"**+5%** Artillery AP"
			],
			unlocks: function (usr) {
				usr.available_units.push("railguns");
				usr.modifiers.ground_artillery_ap = usr.modifiers.ground_artillery_ap + 0.05;
			}
		},
		cyberwarfare_units: {
			icon: "<:manpower:716817688705499177>",
			description: "By creating entire battalions of organised cadres of hackers and cybersecurity experts, we can hope to inflict maximum damage upon our enemy's military and industrial capacity whilst preserving our own.",
			prerequisite_techs: ["modern_support_companies"],
			research_cost: 10500,
			category: "military_technology",
			modifiers: [
				"**-10%** Upkeep Cost",
				"**+2%** War Exhaustion Rate"
			],
			unlocks: function (usr) {
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.10;
				usr.modifiers.war_exhaustion_rate = usr.modifiers.war_exhaustion_rate + 0.02;
			}
		},
		ai_multirole_fighters: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "AI Multirole Fighters are seventh-generational fighter jets capable of attacking targets completely autonomously without any human input whatsoever. As their target recognition systems are highly advanced, they cost significantly more to train and maintain than normal fighter jets.",
			prerequisite_techs: ["stealth_fighters"],
			research_cost: 11000,
			category: "military_technology",
			modifiers: [
				"Enables **AI Multirole Fighters**",
				"**+5%** Upkeep Cost"
			],
			unlocks: function (usr) {
				usr.available_units.push("ai_multirole_fighters");
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
			}
		},
		ai_bombers: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "AI Stealth Bombers are able to identify and attack targets with lightning fast speed and precision, and unlike other earlier UAVs, do not require human control. Despite the innate dangers of using and fielding such weapons, they can give us an unprecedented edge on the battlefield.",
			prerequisite_techs: ["drones","stealth_bombers"],
			research_cost: 11000,
			category: "military_technology",
			modifiers: [
				"Enables **AI Bombers**",
				"**+10%** Air AP",
				"**+5%** Upkeep Cost"
			],
			unlocks: function (usr) {
				usr.available_units.push("ai_bombers");
				usr.modifiers.aeroplanes_ap = usr.modifiers.aeroplanes_ap + 0.10;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
			}
		},
		directed_heat_weaponry: {
			icon: "<:infamy:716817688453709905>",
			description: "Directed heat weaponry, long the realm of science fiction has become possible as a non-lethal alternative to conventional weapons, albeit immensely painful. It can be used for internal security purposes, or incapacitating enemy soldiers.",
			prerequisite_techs: ["railguns"],
			research_cost: 11000,
			category: "military_technology",
			modifiers: [
				"Enables **Directed Heat Weapons**",
				"**+5%** Stability"
			],
			unlocks: function (usr) {
				usr.available_units.push("directed_heat_weapons");
				usr.stability = usr.stability + 5;
			}
		},
		augmented_infantry: {
			icon: "<:active_personnel:716820390474940426>",
			description: "Augmented infantry are units lent a helping hand by cutting edge robots and AI that enable them to conduct missions and possess capabilities that could otherwise have never been held by ordinary infantry units, allowing them to take the offensive.",
			prerequisite_techs: ["contemporary_infantry"],
			research_cost: 11000,
			category: "military_technology",
			modifiers: [
				"Enables **Augmented Infantry**"
			],
			unlocks: function (usr) {
				usr.available_units.push("augmented_infantry");
			}
		},
		multirole_mbt: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "In response to the ever changing dynamics of the battlefield, our tankers should be given the finest weaponry and AI assistance that can be afforded. Our tanks shall now possess anti-aircraft capabilities, and function as mobile artillery when needed - a truly versatile material crucial to forge the victories of tomorrow.",
			prerequisite_techs: ["modern_mbt"],
			research_cost: 11000,
			category: "military_technology",
			modifiers: [
				"Enables **Multirole MBT**",
				"**+10%** Armour DP"
			],
			unlocks: function (usr) {
				usr.available_units.push("multirole_mbts");
				usr.modifiers.ground_vehicles_dp = usr.modifiers.ground_vehicles_dp + 0.10;
			}
		},
		privateering: {
			icon: "<:taxes:716817688781127810>",
			description: "By subsidising our naval income with the loot managed to be scraped off of merchant ships via piracy, and the contracts of naval mercenaries, we can bolster our naval effectiveness ... at a price in infamy, of course.",
			research_cost: 20,
			category: "naval_technology",
			modifiers: [
				"**+2%** Tax Efficiency",
				"**+1%** Infamy Loss"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.02;
				usr.modifiers.infamy_loss = usr.modifiers.infamy_loss + 0.01;
			}
		},
		the_caravel: {
			icon: "<:paper:759161240987369522>",
			description: "Through the development of the triangular sail, the Caravel was one of the first vessels capable of beating upwind, allowing it to travel against the currents of the air and increasingly long distances overseas.",
			research_cost: 20,
			category: "naval_technology",
			modifiers: [
				"Enables **Caravels**",
				"**+5%** Colonist Travel Speed"
			],
			unlocks: function (usr) {
				usr.available_units.push("caravels");
				usr.modifiers.colonist_travel_speed = usr.modifiers.colonist_travel_speed + 0.05;
			}
		},
		improved_astrolabe: {
			icon: "<:globe:716811246556545035>",
			description: "An improved astrolabe will allow our sailors to travel faster at sea and with more precision as improvements in cartography make life easier for mariners.",
			prerequisite_techs: ["the_caravel"],
			research_cost: 50,
			category: "naval_technology",
			modifiers: [
				"**+5%** Tax Efficiency",
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		maritime_cartography: {
			icon: "<:old_map:716821884867444746>",
			description: "By viewing maps less as pieces of art, and more as navigational instruments, we can help ensure that great care is taken in accurately portraying the discoveries of our explorers, leading to a more reliable voyage for both civilian and military naval traffic.",
			prerequisite_techs: ["the_caravel"],
			research_cost: 50,
			category: "naval_technology",
			modifiers: [
				"**-5%** Shipment Time",
				"**+5%** Naval DP",
				"**+5%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_dp = usr.modifiers.naval_units_dp + 0.05;
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		backstaff: {
			icon: "<:old_map:716821884867444746>",
			description: "The backstaff was a navigational instrument that allowed for more accurate observations of solar altitudes, enabling more accurate astrolabe readings.",
			prerequisite_techs: ["improved_astrolabe","maritime_cartography"],
			research_cost: 75,
			category: "naval_technology",
			modifiers: [
				"**+1** Maximum Expeditions"
			],
			unlocks: function (usr) {
				usr.modifiers.maximum_expeditions = usr.modifiers.maximum_expeditions + 1;
			}
		},
		the_galleon: {
			icon: "<:naval_units:716821195277729832>",
			description: "With multiple decks outfitted for cannons, and three or more masts being carried per ship, the galleon quickly became the mainstay of European continental navies, before purpose-built men-of-war were commissioned for European fleets.",
			prerequisite_techs: ["improved_astrolabe","maritime_cartography"],
			research_cost: 75,
			category: "naval_technology",
			modifiers: [
				"Enables **Galleons**",
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.available_units.push("galleons");
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		trading_ports: {
			icon: "<:trade:716828677115084812>",
			description: "By establishing and securing ports of trade in foreign lands, we can ensure that our trade is regularly protected and that more shipments can flow between us and any potential colonies.",
			prerequisite_techs: ["improved_astrolabe","maritime_cartography"],
			research_cost: 100,
			category: "naval_technology",
			modifiers: [
				"**+5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
			}
		},
		circumnavigation: {
			icon: "<:globe:716811246556545035>",
			description: "Circumnavigating the globe will not only help boost our national prestige, but will enable us to conduct studies of far-away lands and bring back exotic flora and fauna for research.",
			prerequisite_techs: ["the_galleon"],
			research_cost: 100,
			category: "naval_technology",
			modifiers: [
				"**+10%** Research Efficiency",
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.research_efficiency = usr.modifiers.research_efficiency + 0.10;
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		armed_merchants: {
			icon: "<:artillery:716821195055431681>",
			description: "Through arming our merchants to the teeth, we can protect our civilian traffic fleet from piracy attacks and privateering from foreign powers.",
			prerequisite_techs: ["trading_ports","circumnavigation"],
			research_cost: 150,
			category: "naval_technology",
			modifiers: [
				"**+5%** Tax Efficiency",
				"**+10%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
				usr.modifiers.shipment_time = usr.modifiers.shipment_time + 0.10;
			}
		},
		fleet_in_being: {
			icon: "<:artillery:716821195055431681>",
			description: "When put at a disadvantage, we should always afford ourselves the option to hole our fleet up in port so as to always be able to counter the enemy and present a constant threat by drawing their naval resources thin.",
			prerequisite_techs: ["trading_ports","circumnavigation"],
			research_cost: 200,
			category: "naval_technology",
			modifiers: [
				"**+10%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.10;
			}
		},
		impressment: {
			icon: "<:taxes:716817688781127810>",
			description: "By forcing sailors into our navy, we can bolster our manpower and reduce naval training costs, although it may come at a slight cost in stability.",
			prerequisite_techs: ["fleet_in_being"],
			research_cost: 250,
			category: "naval_technology",
			modifiers: [
				"**+2%** National Manpower",
				"**-10%** Unit Cost",
				"**-10%** Training Cost",
				"**-5%** Stability"
			],
			unlocks: function (usr) {
				usr.modifiers.national_manpower = usr.modifiers.national_manpower + 0.02;
				usr.modifiers.unit_cost = usr.modifiers.unit_cost - 0.10;
				usr.modifiers.training_cost = usr.modifiers.training_cost - 0.10;
				usr.stability = usr.stability - 0.05;
			}
		},
		men_of_war: {
			icon: "<:taxes:716817688781127810>",
			description: "Men-of-war, outfitted with square rigging and three decks of cannons have increasingly become the premier ships in naval warfare, capable of projecting power across the world. Although expensive, they wield a significant advantage in battle ...",
			prerequisite_techs: ["fleet_in_being"],
			research_cost: 250,
			category: "naval_technology",
			modifiers: [
				"Enables **Men-of-War**",
				"**-5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.available_units.push("men_of_war");
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency - 0.05;
			}
		},
		mercantile_fleet: {
			icon: "<:taxes:716817688781127810>",
			description: "Men-of-war, outfitted with square rigging and three decks of cannons have increasingly become the premier ships in naval warfare, capable of projecting power across the world. Although expensive, they wield a significant advantage in battle ...",
			prerequisite_techs: ["fleet_in_being"],
			research_cost: 250,
			category: "naval_technology",
			modifiers: [
				"**+5%** Tax Efficiency",
				"**-4%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.04;
			}
		},
		naval_administration: {
			icon: "<:development:716811992421367869>",
			description: "By affording ourselves increased anchorage capacity and dockyards, we can continue to produce ships at a faster rate, provided that the steady flow of resources continues trickling in ...",
			prerequisite_techs: ["impressment"],
			research_cost: 350,
			category: "naval_technology",
			modifiers: [
				"**+1** Maximum Dockyards per city"
			],
			unlocks: function (usr) {
				usr.modifiers.dockyards = usr.modifiers.dockyards + 1;
			}
		},
		naval_autonomy: {
			icon: "<:old_scroll:716828676880334881>",
			description: "To cement full control over the riches of the New World and Cathay will take a strong navy, one that must be separated from the army as its duties, disciplines and traditions grow ever more distant, allowing for more effective command and administration.",
			prerequisite_techs: ["naval_administration"],
			research_cost: 500,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval AP",
				"**+5%** Naval DP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
				usr.modifiers.naval_units_dp = usr.modifiers.naval_units_dp + 0.05;
			}
		},
		standards_of_ordnance: {
			icon: "<:coal:716791408714973204>",
			description: "Standardising the different weights and sizes of ordnance to be brought into cannons could have a huge impact on the battlefield as our cannons can now fire more reliably and safely than before. In addition, logistical burdens will be decreased as ironsmiths will have a more concrete idea of what types of projectiles to make.",
			prerequisite_techs: ["naval_administration"],
			research_cost: 500,
			category: "naval_technology",
			modifiers: [
				"**+10%** Naval AP",
				"**-5%** Unit Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.10;
				usr.modifiers.unit_cost = usr.modifiers.unit_cost - 0.05;
			}
		},
		reflecting_quadrant: {
			icon: "<:globe:716811246556545035>",
			description: "The reflecting quadrant was an important tool of navigation that enabled more effective starsighting, thereby enabling captains to jot down accurate measurements of their current latitude.",
			prerequisite_techs: ["mercantile_fleet"],
			research_cost: 500,
			category: "naval_technology",
			modifiers: [
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		ships_of_the_line: {
			icon: "<:naval_units:716821195277729832>",
			description: "Ships of the line were diversified naval warships that formed the bulk of European continental navies, and were divided into class based on the number of decks each ship held.",
			prerequisite_techs: ["standards_of_ordnance","men_of_war"],
			research_cost: 650,
			category: "naval_technology",
			modifiers: [
				"Enables **Ships-of-the-Line**",
				"Obsoletes **Galleons**",
				"Obsoletes **Caravels**"
			],
			unlocks: function (usr) {
				usr.available_units.push("ships_of_the_line");
				deleteElement(usr.available_units, "galleons", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "caravels", [usr, "obsolete_units"]);
			}
		},
		naval_charting: {
			icon: "<:old_map:716821884867444746>",
			description: "Naval charts specialising in bathymetry will help merchants and captains alike to avoid the environmental dangers posed by certain areas.",
			prerequisite_techs: ["reflecting_quadrant"],
			research_cost: 650,
			category: "naval_technology",
			modifiers: [
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		global_operations: {
			icon: "<:naval_units:716821195277729832>",
			description: "Ships of the line were diversified naval warships that formed the bulk of European continental navies, and were divided into class based on the number of decks each ship held.",
			prerequisite_techs: ["naval_autonomy"],
			research_cost: 750,
			category: "naval_technology",
			modifiers: [
				"**+1** Maximum Dockyards per city",
				"**-10%** Colonist Travel Time"
			],
			unlocks: function (usr) {
				usr.modifiers.dockyards = usr.modifiers.dockyards + 1;
				usr.modifiers.colonist_travel_speed = usr.modifiers.colonist_travel_speed - 0.10;
			}
		},
		sextant: {
			icon: "<:steel:716791408828088420>",
			description: "The sextant, first invented in the early 18th century, was a reflective device purpose built for the measurement of angular distance between stellar objects. It can be used to estimate both latitude and longitude, albeit not precisely until the advent of the chronometer.",
			prerequisite_techs: ["ships_of_the_line","naval_charting"],
			research_cost: 750,
			category: "naval_technology",
			modifiers: [
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		naval_blockades: {
			icon: "<:blockade:716817688592252979>",
			description: "Although we have not had the capability to enforce this on such a total scale until recently, a naval blockade in theory has existed for a long time, referring to the cutting off of an entire belligerent nation from sources of trade using a naval fleet. Although the logistical costs are immense, so too can the rewards ...",
			prerequisite_techs: ["global_operations"],
			research_cost: 900,
			category: "naval_technology",
			modifiers: [
				"Unlocks **Naval Blockades**",
				"**+2%** War Exhaustion Rate",
				"**-5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.enable_blockades = true;
				usr.modifiers.war_exhaustion_rate = usr.modifiers.war_exhaustion_rate + 0.02;
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency - 0.05;
			}
		},
		copper_plating: {
			icon: "<:blockade:716817688592252979>",
			description: "By both waterproofing our ships' hulls with tar, and plating them in copper, we can help prevent rotting wood whilst also obsoleting enemy ramming as they can no longer simply ram through metal as they could with wood. Although, unit cost will invariably rise ...",
			prerequisite_techs: ["sextant","copper_plating"],
			research_cost: 900,
			category: "naval_technology",
			modifiers: [
				"**+10%** Naval DP",
				"**+5%** Unit Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_dp = usr.modifiers.naval_units_dp + 0.10;
				usr.modifiers.unit_cost = usr.modifiers.unit_cost + 0.05;
			}
		},
		square_rigging: {
			icon: "<:paper:759161240987369522>",
			description: "Square rigging is a sailing configuration that seeks to maximise the surface area upon which the wind can push to improve travel speed. Although difficult to maintain, the boost in speed is surely worth it ...",
			prerequisite_techs: ["sextant"],
			research_cost: 900,
			category: "naval_technology",
			modifiers: [
				"**-5%** Shipment Time",
				"**+5%** Training Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
				usr.modifiers.training_cost = usr.modifiers.training_cost + 0.05;
			}
		},
		amphibious_descent: {
			icon: "<:soldiers:732730754592669702>",
			description: "The purpose of the amphibious descent, or rather amphibious landing as it is in modern parlance, is to secure the enemy's port facilities in and around a concentrated area so as to be able to secure further shipments of troops.",
			prerequisite_techs: ["naval_blockades"],
			research_cost: 1000,
			category: "naval_technology",
			modifiers: [
				"**+10%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.10;
			}
		},
		naval_carronade: {
			icon: "<:artillery:716821195055431681>",
			description: "A naval carronade is a light artillery piece meant for transport aboard merchant ships that can be pulled out in times of battle. It became popular during the American War of Independence, and was used throughout the later part of 18th and early 19th centuries.",
			prerequisite_techs: ["standards_of_ordnance"],
			research_cost: 1000,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval DP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_dp = usr.modifiers.naval_units_dp + 0.05;
			}
		},
		first_rate: {
			icon: "<:naval_units:716821195277729832>",
			description: "A first-rate was the largest type of man-of-war available, capable of carrying up to a hundred guns. Although expensive, they revolutionised the naval battlefield when first launched.",
			prerequisite_techs: ["copper_plating"],
			research_cost: 1000,
			category: "naval_technology",
			modifiers: [
				"Enables **First-Rates**",
				"**+5%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.available_units.push("first_rate");
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.05;
			}
		},
		discovery_of_magnetic_variation: {
			icon: "<:old_scroll:716828676880334881>",
			description: "The discovery of magnetic variation enabled compass readings to be taken more accurately, with seafarers now realising a difference between true north and magnetic north.",
			prerequisite_techs: ["square_rigging"],
			research_cost: 1000,
			category: "naval_technology",
			modifiers: [
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		thirtysix_pounder_long_gun: {
			icon: "<:artillery:716821195055431681>",
			description: "The 36-pounder long-gun was amongst the heaviest artillery pieces carried on seafaring vessels, capable of shore bombardment and naval support of amphibious landings.",
			prerequisite_techs: ["naval_carronade"],
			research_cost: 1200,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
			}
		},
		frigates: {
			icon: "<:naval_units:716821195277729832>",
			description: "Frigates are lower-tier capital ships meant to protect oceangoing trade and military vessels from unconventional attacks. They can also be used in supporting roles.",
			prerequisite_techs: ["first_rate"],
			research_cost: 1200,
			category: "naval_technology",
			modifiers: [
				"Enables **Frigates**"
			],
			unlocks: function (usr) {
				usr.available_units.push("frigates");
			}
		},
		marine_chronometer: {
			icon: "<:government:716817688693047306>",
			description: "Marine chronometers are devices capable of accurately measuring time, and therefore capable of deducing longitudinal meridians necessary to navigation.",
			prerequisite_techs: ["discovery_of_magnetic_variation"],
			research_cost: 1200,
			category: "naval_technology",
			modifiers: [
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		naval_doctrine: {
			icon: "<:naval_units:716821195277729832>",
			description: "By creating official protocols by which our navy should abide and adopting tactics into field manuals, our admirals can be better suited to naval warfare when encountering enemies.",
			prerequisite_techs: ["amphibious_descent"],
			research_cost: 1400,
			category: "naval_technology",
			modifiers: [
				"**-10%** Training Cost",
				"**-5%** Unit Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.training_cost = usr.modifiers.training_cost - 0.10;
				usr.modifiers.unit_cost = usr.modifiers.unit_cost - 0.05;
			}
		},
		primitive_submarines: {
			icon: "<:naval_units:716821195277729832>",
			description: "Although no one sure likes being cooped up in a barrel of death that may or may not be rapidly running out of oxygen, submarines of the future may help provide new ways of transforming the naval arena ...",
			prerequisite_techs: ["36_pounder_long_gun","frigates"],
			research_cost: 1400,
			category: "naval_technology",
			modifiers: [
				"This will lead to further advances in naval technology ..."
			],
			unlocks: function (usr) {
			}
		},
		paddle_wheel: {
			icon: "<:steel:716791408828088420>",
			description: "The paddle wheel was a method of propulsion for steamers relying on rotational motion to push forwards a ship. Despite its inherent inefficiencies, it continued being used up until the invention of the propeller.",
			prerequisite_techs: ["marine_chronometer"],
			research_cost: 1400,
			category: "naval_technology",
			modifiers: [
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		blockade_running: {
			icon: "<:infamy:716817688453709905>",
			description: "Although risky, during times of war, civilian merchant steamers could be used to run blockades, even under neutral banners. This way, we can ensure lower war exhaustion as food shipments, though minimal, may continue.",
			prerequisite_techs: ["naval_doctrine"],
			research_cost: 1600,
			category: "naval_technology",
			modifiers: [
				"**-4%** War Exhaustion Rate"
			],
			unlocks: function (usr) {
				usr.modifiers.war_exhaustion_rate = usr.modifiers.war_exhaustion_rate - 0.04;
			}
		},
		twentyfour_pounder_long_gun: {
			icon: "<:artillery:716821195055431681>",
			description: "The 24-pounder long gun was a piece of naval artillery of medium calibre, typically used for naval combat. It became a mainstay of lighter capital ships before the introduction of rotational turrets.",
			prerequisite_techs: ["primitive_submarines"],
			research_cost: 1600,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
			}
		},
		steamboat: {
			icon: "<:naval_units:716821195277729832>",
			description: "The first ship to rely completely on steam power, the steamboat used coal as its main means of propulsion, and no longer relied on the wind. Although initially invented as a cviilian trade vessel, there is nothing preventing the nations of the world from militarising its use ...",
			prerequisite_techs: ["36_pounder_long_gun","frigates","paddle_wheel"],
			research_cost: 1600,
			category: "naval_technology",
			modifiers: [
				"Enables **Steamboats**"
			],
			unlocks: function (usr) {
				usr.available_units.push("steamboats");
			}
		},
		clipper_ship: {
			icon: "<:naval_units:716821195277729832>",
			description: "The last great ship of the Age of Sail, clipper ships were used as naval transports and carried several sails, sometimes in combination with a steam engine, in order to maximise speed.",
			prerequisite_techs: ["steamboat"],
			research_cost: 1800,
			category: "naval_technology",
			modifiers: [
				"Enables **Clippers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("clippers");
			}
		},
		organised_salvo: {
			icon: "<:naval_units:716821195277729832>",
			description: "By bringing our naval guns to bear instead of firing ragged volleys, we can unleash a devastating salvo onto a still unsuspecting enemy, leading to the complete destruction of their ship. Although it may take a while to re-arm, it would surely be more effective than our current modus operandi.",
			prerequisite_techs: ["blockade_running","24_pounder_long_gun"],
			research_cost: 2000,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval AP",
				"**-2%** Naval DP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
				usr.modifiers.naval_units_dp = usr.modifiers.naval_units_dp - 0.02;
			}
		},
		increased_firing_range: {
			icon: "<:artillery:716821195055431681>",
			description: "With the advent of large-calibre artillery being placed on ships, we can increase our firing range beyond what would normally be possible with broadsides from the Age of Sail.",
			prerequisite_techs: ["blockade_running","24_pounder_long_gun"],
			research_cost: 2000,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
			}
		},
		precision_cartography: {
			icon: "<:old_map:716821884867444746>",
			description: "Applying surveying techniques to maritime cartography could result in unparallelled accuracy, even with the storms and waves of the high seas.",
			prerequisite_techs: ["frigates","paddle_wheel"],
			research_cost: 2000,
			category: "naval_technology",
			modifiers: [
				"**+3%** Research Efficiency",
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.research_efficiency = usr.modifiers.research_efficiency + 0.03;
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		gunboat: {
			icon: "<:naval_units:716821195277729832>",
			description: "The gunboat is a light ship capable of a high rate of travel, and the first real steamship used exclusively in a military context.",
			prerequisite_techs: ["organised_salvo","increased_firing_range","clipper_ship"],
			research_cost: 2500,
			category: "naval_technology",
			modifiers: [
				"Enables **Gunboat**"
			],
			unlocks: function (usr) {
				usr.available_units.push("gunboats");
			}
		},
		international_standard_of_maritime_flags: {
			icon: "<:infamy:716817688453709905>",
			description: "Through creating an international standard of maritime flags for communication, we can ensure that distress signals can be properly conveyed, and that accidental sinkings in times of war are reduced.",
			prerequisite_techs: ["precision_cartography"],
			research_cost: 2500,
			category: "naval_technology",
			modifiers: [
				"**+5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
			}
		},
		crossing_the_t: {
			icon: "<:iron:716791408819961866>",
			description: "Crossing the T is a naval tactic that allows us to position a ship in favour to an enemy belligerent's, by exposing our entire side, whereas only the bow or the rear of the enemy is exposed. Thereby, we can fire an entire broadside, whereas the enemy is only capable of firing their frontal guns.",
			prerequisite_techs: ["organised_salvo","increased_firing_range"],
			research_cost: 3000,
			category: "naval_technology",
			modifiers: [
				"**+3%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.03;
			}
		},
		casemates: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Casemates are protective fortifications for artillery that lessen the vulnerabilities of the gunners inside.",
			prerequisite_techs: ["increased_firing_range"],
			research_cost: 3000,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval DP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_dp = usr.modifiers.naval_units_dp + 0.05;
			}
		},
		ironclads: {
			icon: "<:naval_units:716821195277729832>",
			description: "Ironclads are heavy ships-of-the-line that immediately obsoleted ships with wooden hulls, as they were impervious to traditional cannons with their sloped armour.",
			prerequisite_techs: ["gunboat"],
			research_cost: 3000,
			category: "naval_technology",
			modifiers: [
				"Enables **Ironclads**",
				"Obsoletes **Clippers**",
				"Obsoletes **Steamboats**",
				"Obsoletes **Frigates**",
				"Obsoletes **First Rates**",
				"Obsoletes **Ships-of-the-Line**",
				"Obsoletes **Men-of-War**"
			],
			unlocks: function (usr) {
				usr.available_units.push("ironclads");
				deleteElement(usr.available_units, "clippers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "steamboats", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "frigates", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "first_rate", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "ships_of_the_line", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "men_of_war", [usr, "obsolete_units"]);
			}
		},
		rotational_turrets: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Rotational turrets, fitted into position by gravity, help to increase the various coverage provided by a single gun, allowing for guns of huge calibre as opposed to traditional cannons, which were locked into place.",
			prerequisite_techs: ["casemates"],
			research_cost: 3500,
			category: "naval_technology",
			modifiers: [
				"**+10%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.10;
			}
		},
		breastwork_monitor: {
			icon: "<:naval_units:716821195277729832>",
			description: "The breastwork monitor was an advanced ironclad fitted with rotational turrets. Although initial monitors benefitted from a low profile, as they could not easily be shot at, it also enabled ocean currents to sweep onto the ship and potentially find its way into the hull through openings on its deck. By adding a breastwork to ring the ship, these vulnerabilities can be reduced, as the water would have to splash over the breastworks instead.",
			prerequisite_techs: ["ironclads"],
			research_cost: 3500,
			category: "naval_technology",
			modifiers: [
				"Enables **Breastwork Monitors**"
			],
			unlocks: function (usr) {
				usr.available_units.push("breastwork_monitors");
			}
		},
		naval_mines: {
			icon: "<:coal:716791408714973204>",
			description: "Naval mines, in contrast to fire ships, are a safer way to keep our seas protected, as well as to lay down blockade zones as they can pose a constant hazard even without the active presence of other ships.",
			prerequisite_techs: ["rotational_turrets"],
			research_cost: 4000,
			category: "naval_technology",
			modifiers: [
				"**-5%** Army Upkeep",
				"**+1%** War Exhaustion Rate"
			],
			unlocks: function (usr) {
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.05;
				usr.modifiers.war_exhaustion_rate = usr.modifiers.war_exhaustion_rate + 0.01;
			}
		},
		cruisers: {
			icon: "<:naval_units:716821195277729832>",
			description: "Cruisers are large capital ships tasked with guarding the waters surrounding a primary ship, and sometimes operate independently as flagships on certain missions.",
			prerequisite_techs: ["crossing_the_t","breastwork_monitor"],
			research_cost: 4000,
			category: "naval_technology",
			modifiers: [
				"Enables **Cruisers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("cruisers");
			}
		},
		destroyers: {
			icon: "<:naval_units:716821195277729832>",
			description: "Destroyers are light escort ships capable of conducting anti-submarine warfare and duties.",
			prerequisite_techs: ["rotational_turrets","breastwork_monitor"],
			research_cost: 4000,
			category: "naval_technology",
			modifiers: [
				"Enables **Destroyers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("destroyers");
			}
		},
		torpedo: {
			icon: "<:coal:716791408714973204>",
			description: "Although the inaccuracies regarding the torpedo and its inherent disadvantages are many, by ironing out some of the more extreme ones (e.g. the circular torpedo), we can introduce it into service for certain naval craft.",
			prerequisite_techs: ["naval_mines"],
			research_cost: 4500,
			category: "naval_technology",
			modifiers: [
				"**+2%** Naval AP",
				"This will lead to further advances in the field of naval armaments ..."
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.02;
			}
		},
		pre_dreadnought: {
			icon: "<:naval_units:716821195277729832>",
			description: "Pre-dreadnoughts, the first true battleships of the modern age made up the capital ships of the premier powers of the world before the invention of the dreadnought, which immediately rendered it obsolete outside of secondary duties.",
			prerequisite_techs: ["cruisers"],
			research_cost: 4500,
			category: "naval_technology",
			modifiers: [
				"Enables **Pre-Dreadnoughts**"
			],
			unlocks: function (usr) {
				usr.available_units.push("pre_dreadnoughts");
			}
		},
		wireless_telegraphy: {
			icon: "<:building:716827579650408538>",
			description: "Wireless telegraphy allowed ships at sea to communicate instantaneously over radio for the first time, saving them from accidents, and helping to coordinate manoeuvres.",
			prerequisite_techs: ["international_standard_of_maritime_flags"],
			research_cost: 4500,
			category: "naval_technology",
			modifiers: [
				"**-10%** Colonist Travel Time",
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.colonist_travel_speed = usr.modifiers.colonist_travel_speed - 0.10;
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		naval_bombardment: {
			icon: "<:infamy:716817688453709905>",
			description: "Naval bombardment, whilst expensive, can suppress an enemy on the coast if sustained, allowing us to take the area with minimal casualties, ideally.",
			prerequisite_techs: ["crossing_the_t","rotational_turrets"],
			research_cost: 5000,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
			}
		},
		torpedo_boats: {
			icon: "<:naval_units:716821195277729832>",
			description: "Torpedo boats are fast and nimble ships capable of launching torpedoes at heavier armoured targets in the hopes of sinking them.",
			prerequisite_techs: ["torpedo"],
			research_cost: 5000,
			category: "naval_technology",
			modifiers: [
				"Enables **Torpedo Boats**"
			],
			unlocks: function (usr) {
				usr.available_units.push("torpedo_boats");
			}
		},
		dreadnought: {
			icon: "<:naval_units:716821195277729832>",
			description: "The Dreadnought, a true behemoth of the sea, immediately outclassed every other ship that came before it, similar to the ironclad. From that point on, they were relegated to secondary naval duties.",
			prerequisite_techs: ["pre_dreadnought","wireless_telegraphy"],
			research_cost: 5000,
			category: "naval_technology",
			modifiers: [
				"Enables **Dreadnoughts**",
				"Obsoletes **Breastwork-Monitors**",
				"Obsoletes **Ironclads**",
				"Obsoletes **Gunboats**",
				"Obsoletes **Clippers**",
				"Obsoletes **Steamboats**",
				"Obsoletes **Pre-Dreadnoughts**"
			],
			unlocks: function (usr) {
				usr.available_units.push("dreadnoughts");
				deleteElement(usr.available_units, "breastwork_monitors", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "ironclads", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "gunboats", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "clippers", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "steamboats", [usr, "obsolete_units"]);
				deleteElement(usr.available_units, "pre_dreadnoughts", [usr, "obsolete_units"]);
			}
		},
		convoy_interception: {
			icon: "<:trade:716828677115084812>",
			description: "By allowing for trade interdiction, we can intercept and sink merchant shipping from underneath the high seas, allowing for a decisive edge over our opponent, even if they hold a monopoly over the surface.",
			prerequisite_techs: ["naval_bombardment"],
			research_cost: 5500,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
			}
		},
		torpedo_guidance_systems: {
			icon: "<:government:716817688693047306>",
			description: "Through improving the reliability of torpedoes and allowing an independent guidance system, we can ensure that they will remain steady on course to the target once launched from a submarine, before detonating beneath the ship. ",
			prerequisite_techs: ["torpedo_boats"],
			research_cost: 5500,
			category: "naval_technology",
			modifiers: [
				"This will lead to further advancements regarding submarine warfare ..."
			],
			unlocks: function (usr) {
			}
		},
		battlecruisers: {
			icon: "<:naval_units:716821195277729832>",
			description: "Battlecruisers, with the armament of a battleship, and the armour of a cruiser, are capital ships that attempt to both improve manoeuvrability and maintain speed.",
			prerequisite_techs: ["dreadnought"],
			research_cost: 5500,
			category: "naval_technology",
			modifiers: [
				"Enables **Battlecruisers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("battlecruisers");
			}
		},
		wireless_radio: {
			icon: "<:old_scroll:716828676880334881>",
			description: "Wireless radio, a step forwards from mere telegraphy, will allow auditory messages to be sent to nearby ships in the vicinity, allowing for improved and faster communication.",
			prerequisite_techs: ["wireless_telegraphy"],
			research_cost: 5500,
			category: "naval_technology",
			modifiers: [
				"**-3%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.03;
			}
		},
		naval_catapults: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Naval catapults are mechanisms that allow for the takeoff of aeroplanes from battleships, helping to improve air coverage.",
			prerequisite_techs: ["torpedo_guidance_systems","battlecruisers"],
			research_cost: 6000,
			category: "naval_technology",
			modifiers: [
				"This will lead to further developments for naval aeroplanes ..."
			],
			unlocks: function (usr) {
			}
		},
		submarines: {
			icon: "<:naval_units:716821195277729832>",
			description: "Submarines, ever present beneath the surface offer a completely new method of conducting naval warfare by starving out an opponent through sinking merchant shipping. Although sometimes frowned upon as not precisely ethical, its practical abilities are nearly limitless.",
			prerequisite_techs: ["torpedo_guidance_systems","battlecruisers"],
			research_cost: 6000,
			category: "naval_technology",
			modifiers: [
				"Enables **Submarines**",
				"Obsoletes **Torpedo Boats**"
			],
			unlocks: function (usr) {
				usr.available_units.push("submarines");
				deleteElement(usr.available_units, "torpedo_boats", [usr, "obsolete_units"]);
			}
		},
		electric_signalling: {
			icon: "<:technology:716812861514711040>",
			description: "Electric signalling, although initially conceived as a means of last resort, can help reduce the dangers faced by ships at night, and allow ships to see nearby vessels and emergencies.",
			prerequisite_techs: ["wireless_radio"],
			research_cost: 6000,
			category: "naval_technology",
			modifiers: [
				"**-3%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.03;
			}
		},
		modern_arresting_gear: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "By stopping aeroplanes with a strong steel cord, we can reduce the possibilities of pilots crashing overboard, and reduce aeroplane losses at sea, ultimately driving down unit and training costs.",
			prerequisite_techs: ["naval_catapults","electric_signalling"],
			research_cost: 6500,
			category: "naval_technology",
			modifiers: [
				"**-2%** Army Upkeep",
				"**-5%** Training Cost",
				"This will lead to further advances for naval aeroplanes ..."
			],
			unlocks: function (usr) {
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.02;
				usr.modifiers.training_cost = usr.modifiers.training_cost - 0.05;
			}
		},
		aircarrier: {
			icon: "<:naval_units:716821195277729832>",
			description: "The air carrier is a virtual hangar at sea that allows us to take off and land aeroplanes, allowing us to project the power of air into conflict zones by sea where it might not otherwise be possible.",
			prerequisite_techs: ["naval_catapults","submarines","electric_signalling"],
			research_cost: 6500,
			category: "naval_technology",
			modifiers: [
				"Enables **Air carriers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("air_carriers");
			}
		},
		naval_logistics: {
			icon: "<:trade:716828677115084812>",
			description: "Naval logistics is the concept by which certain storages of food and other provisions aboard ships should be taken into account, as well as facilities for repair.",
			prerequisite_techs: ["convoy_interception"],
			research_cost: 7000,
			category: "naval_technology",
			modifiers: [
				"**-10%** Army Upkeep",
				"**+1** Dockyards per city"
			],
			unlocks: function (usr) {
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.10;
				usr.modifiers.dockyards = usr.modifiers.dockyards + 1;
			}
		},
		battleship: {
			icon: "<:naval_units:716821195277729832>",
			description: "The battleship, the successor to the dreadnought, was by far the heaviest capital unit type to ever be created. They featured huge guns capable of shooting dozens of kilometres either inland or at other oceangoing targets. They died with the sinking of the Prince of Wales and Repulse, as well as Pearl Harbour. They were gradually phased out, and by the end of the Cold War, none remained in active service.",
			prerequisite_techs: ["aircarrier"],
			research_cost: 7000,
			category: "naval_technology",
			modifiers: [
				"Enables **Battleships**",
				"Obsoletes **Dreadnoughts**"
			],
			unlocks: function (usr) {
				usr.available_units.push("battleships");
				deleteElement(usr.available_units, "dreadnoughts", [usr, "obsolete_units"]);
			}
		},
		strike_force: {
			icon: "<:old_map:716821884867444746>",
			description: "By maintaining a concentrated mass of ships centred around a flagship, we can project naval power into any conflict zone, although it might take a matter of months before such a capability is possible.",
			prerequisite_techs: ["naval_logistics"],
			research_cost: 7500,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
			}
		},
		torpedo_bombers: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Torpedo bombers are aeroplanes that maintain low altitude in order to drop a torpedo, which can then head towards a moving target. They are typically fast and nimble, but are liable to be shot down by ack-ack.",
			prerequisite_techs: ["modern_arresting_gear","battleship"],
			research_cost: 7500,
			category: "naval_technology",
			modifiers: [
				"Enables **Torpedo Bombers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("torpedo_bombers");
			}
		},
		aircraft_carrier: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "The aircraft carrier is quickly becoming the dominant ship on the high seas, and so our nation should take steps to, if not produce one, at least acknowledge the existence of them and attempt to develop tactics to counter their ascendant rise.",
			prerequisite_techs: ["modern_arresting_gear","battleship"],
			research_cost: 7500,
			category: "naval_technology",
			modifiers: [
				"Enables **Aircraft Carriers**",
				"Obsoletes **Air Carriers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("aircraft_carriers");
				deleteElement(usr.available_units, "air_carriers", [usr, "obsolete_units"]);
			}
		},
		cavity_magnetron_radar: {
			icon: "<:government:716817688693047306>",
			description: "The Cavity Magnetron RADAR was a highly capable British radar that was produced in extremely compact sizes during the Second World War. They were put on board ships and aeroplanes, and helped detect incoming enemy aircraft earlier.",
			prerequisite_techs: ["modern_arresting_gear","battleship"],
			research_cost: 7500,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval DP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_dp = usr.modifiers.naval_units_dp + 0.05;
			}
		},
		island_hopping: {
			icon: "<:provinces:716809229603700737>",
			description: "Island hopping is the tactic of using each consecutive island as a staging ground for invading the next one, in such a manner that eventually whole island chains are taken by friendly forces, helping lower logistical burdens.",
			prerequisite_techs: ["strike_force"],
			research_cost: 8000,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval AP",
				"**-2%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.02;
			}
		},
		naval_bombers: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Naval bombers are aircraft specifically designed for naval combat that are meant to take off of aircraft carriers and relatively short runways. As such, they do not carry large payloads, but are designed instead to drop them over enemy ships.",
			prerequisite_techs: ["strike_force"],
			research_cost: 8000,
			category: "naval_technology",
			modifiers: [
				"Enables **Naval Bombers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("naval_bombers");
			}
		},
		sonar: {
			icon: "<:technology:716812861514711040>",
			description: "SONAR, a mirror of its above-surface counterpart RADAR, is meant to detect submarines and other threats lurking beneath the oceans. They are also used on submarines for both navigation purposes, and for targeting enemy ships and subs.",
			prerequisite_techs: ["cavity_magnetron_radar"],
			research_cost: 8000,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval DP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_dp = usr.modifiers.naval_units_dp + 0.05;
			}
		},
		aerial_supremacy: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "Aerial supremacy, when ingrained as a naval doctrine, believes that aircraft carriers are the key ships around which naval battles pivot, and that aeroplanes should be used as the main weapons of waging naval warfare, and as a means to quickly project power into a conflict.",
			prerequisite_techs: ["island_hopping"],
			research_cost: 8500,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
			}
		},
		slbms: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "SLBMs, or Submarine Launched Ballistic Missiles in its expanded form, can be launched from underwater, making detection minimal, and allowing us to strike coastal cities within minutes.",
			prerequisite_techs: ["island_hopping"],
			research_cost: 8500,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
			}
		},
		portable_nuclear_reactor: {
			icon: "<:coal:716791408714973204>",
			description: "Portable nuclear reactors are capable of generating tremendous amounts of power for sustained durations of time without the need to refuel, unlike conventional diesel generators.",
			prerequisite_techs: ["island_hopping"],
			research_cost: 8500,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval DP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_dp = usr.modifiers.naval_units_dp + 0.05;
			}
		},
		nuclear_triad: {
			icon: "<:infamy:716817688453709905>",
			description: "In order to maintain first-strike capability, our nation must first possess the nuclear triad - namely the ability to deliver nuclear warheads to a recipient nation via strategic bombers, nuclear missiles, and nuclear submarines. Of course, we will have to pay for the extra logistical capacity ...",
			prerequisite_techs: ["aerial_supremacy"],
			research_cost: 9000,
			category: "naval_technology",
			modifiers: [
				"**+1** Dockyards per city",
				"**+10%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.dockyards = usr.modifiers.dockyards + 1;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep + 0.10;
			}
		},
		nuclear_submarine: {
			icon: "<:naval_units:716821195277729832>",
			description: "The nuclear submarine is a submersible vehicle that can stay underwater on extended missions for months or potentially even years at a time without need to stop for refueling, as it relies completely on nuclear power.",
			prerequisite_techs: ["aerial_supremacy"],
			research_cost: 9000,
			category: "naval_technology",
			modifiers: [
				"Enables **Nuclear Submarines**"
			],
			unlocks: function (usr) {
				usr.available_units.push("nuclear_submarines");
			}
		},
		organised_taskforces: {
			icon: "<:naval_units:716821195277729832>",
			description: "By organising our naval strike groups into task forces centred around a single aircraft carrier, we can quickly move additional forces into a conflict zone in a matter of weeks.",
			prerequisite_techs: ["nuclear_triad"],
			research_cost: 9500,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
			}
		},
		vtol_aircraft: {
			icon: "<:aeroplanes:716821195407884358>",
			description: "VTOL Aircraft, standing for Vertical Take-Off and Landing, are aeroplanes capable of taking off vertically from ship decks, specifically aircraft carriers, or lighter vehicles such as escort carriers or helicopter carriers.",
			prerequisite_techs: ["nuclear_triad"],
			research_cost: 9500,
			category: "naval_technology",
			modifiers: [
				"**+10%** Air AP"
			],
			unlocks: function (usr) {
				usr.modifiers.aeroplanes_ap = usr.modifiers.aeroplanes_ap + 0.10;
			}
		},
		supercarriers: {
			icon: "<:naval_units:716821195277729832>",
			description: "Supercarriers are classified as capital ships, although they should be completely distinct from them, as they are the central assets upon which entire countries depend, and have huge carrier capacities.",
			prerequisite_techs: ["slbms","portable_nuclear_reactor"],
			research_cost: 9500,
			category: "naval_technology",
			modifiers: [
				"Enables **Supercarriers**",
				"Obsoletes **Battleships**"
			],
			unlocks: function (usr) {
				usr.available_units.push("supercarriers");
				deleteElement(usr.available_units, "battleships", [usr, "obsolete_units"]);
			}
		},
		modern_cruisers_and_frigates: {
			icon: "<:naval_units:716821195277729832>",
			description: "By modernising the secondary capital ships of our nation, we will be able to bring them up to date to adapt to ever evolving threats posed by foreign nations.",
			prerequisite_techs: ["supercarriers"],
			research_cost: 10000,
			category: "naval_technology",
			modifiers: [
				"Enables **Modern Cruisers**",
				"Enables **Modern Frigates**",
				"Obsoletes **Cruisers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("modern_cruisers");
				usr.available_units.push("modern_frigates");
				deleteElement(usr.available_units, "cruisers", [usr, "obsolete_units"]);
			}
		},
		electronic_guidance_systems: {
			icon: "<:technology:716812861514711040>",
			description: "Electronic guidance systems provide a path for naval ordnance and payloads to be delivered more effectively and in a more concise manner than currently possible with traditional rotational turrets.",
			prerequisite_techs: ["supercarriers"],
			research_cost: 10000,
			category: "naval_technology",
			modifiers: [
				"**+10%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.10;
			}
		},
		modern_naval_doctrine: {
			icon: "<:globe:716811246556545035>",
			description: "By focusing our navy either on protecting our shoreline, or projecting our power abroad, we can ensure that it remains a flexible force to be reckoned with far into the future.",
			prerequisite_techs: ["organised_taskforces", "modern_cruisers_and_frigates"],
			research_cost: 10500,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
			}
		},
		rc_autocannon: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "RC Autocannon are anti-aircraft chainguns controlled remotely that allow for improved defence against low-flying aircraft.",
			prerequisite_techs: ["modern_cruisers_and_frigates"],
			research_cost: 10500,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval DP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_dp = usr.modifiers.naval_units_dp + 0.05;
			}
		},
		asymmetric_naval_warfare: {
			icon: "<:back_button:716829986266546187>",
			description: "By learning to deal with enemies of a more unconventional nature on the high seas, we can protect our merchant fleet from resurgent threats and terrorism.",
			prerequisite_techs: ["modern_naval_doctrine"],
			research_cost: 11000,
			category: "naval_technology",
			modifiers: [
				"**+5%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.05;
			}
		},
		electromagnetic_propulsion: {
			icon: "<:artillery_piece:759161240999952445>",
			description: "Electromagnetic propulsion will allow for future naval units to feature experimental Gauss Guns, which are capable of accelerating kinetic projectiles to fantastic speeds without the need for a visible heat signature.",
			prerequisite_techs: ["rc_autocannon"],
			research_cost: 11000,
			category: "naval_technology",
			modifiers: [
				"**+15%** Naval AP"
			],
			unlocks: function (usr) {
				usr.modifiers.naval_units_ap = usr.modifiers.naval_units_ap + 0.15;
			}
		},
		railgun_cruisers: {
			icon: "<:naval_units:716821195277729832>",
			description: "Railgun cruisers are next-generation, state-of-the-art capital ships that can fire hypersonic projectiles capable of reaching speeds of over 3km/s.",
			prerequisite_techs: ["modern_cruisers_and_frigates","vtol_aircraft","organised_taskforces"],
			research_cost: 11000,
			category: "naval_technology",
			modifiers: [
				"Enables **Railgun Cruisers**"
			],
			unlocks: function (usr) {
				usr.available_units.push("railgun_cruisers");
			}
		},
		cottage_industry: {
			icon: "<:factory:759161240601493525>",
			description: "The cottage industry, or putting-out system allowed workers to work from home, particularly in the industries of textiles, manufacturing, or agriculture.",
			research_cost: 20,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
			}
		},
		the_workshop: {
			icon: "<:workers:732730754735276124>",
			description: "The workshop was a standing improvement over guilds that allowed individual tasks to be conducted more effectively.",
			prerequisite_techs: ["cottage_industry"],
			research_cost: 50,
			category: "economic_technology",
			modifiers: [
				"Enables **Workshop**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("workshops");
			}
		},
		improved_mining_techniques: {
			icon: "<:lead:716791408840671322>",
			description: "By improving our mining techniques, we can afford to produce more and more from the bowels of the earth with less labour, improving overall efficiency.",
			prerequisite_techs: ["cottage_industry"],
			research_cost: 50,
			category: "economic_technology",
			modifiers: [
				"**+5%** RGO Throughput",
				"**+1** Quarries per city"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("workshops");
				usr.modifiers.quarries = usr.modifiers.quarries + 1;
			}
		},
		private_industry: {
			icon: "<:money:716817688718213192>",
			description: "By handing over both our financial and industrial potential to private industry, we can begin to develop a flourishing economy based on complex systems of trade and banking.",
			prerequisite_techs: ["cottage_industry"],
			research_cost: 50,
			category: "economic_technology",
			modifiers: [
				"**+5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
			}
		},
		economic_mobility: {
			icon: "<:trade:716828677115084812>",
			description: "Through a primitive free market society, our craftsmen and peasantry will have the ability to slowly migrate between economic classes, forming a sort of new nobility, and spurring economic innovation.",
			prerequisite_techs: ["the_workshop"],
			research_cost: 75,
			category: "economic_technology",
			modifiers: [
				"**+1%** Population Growth Rate"
			],
			unlocks: function (usr) {
				usr.pop_growth_modifier = usr.pop_growth_modifier + 0.01;
			}
		},
		wood_beam_support: {
			icon: "<:wood:716791408928751636>",
			description: "By supporting the structural integrity of our mines with wooden beams, we can improve stability and reduce the occurrence of mine accidents or collapses.",
			prerequisite_techs: ["improved_mining_techniques"],
			research_cost: 75,
			category: "economic_technology",
			modifiers: [
				"Enables **Coal Mine**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("coal_mines");
			}
		},
		early_capitalism: {
			icon: "<:gold:716798541028261927>",
			description: "Early capitalism, often revolving around banking, created a new merchant class known as burghers who were primarily responsible for the disposition of capital in a country, and starting up new businesses, especially in trade.",
			prerequisite_techs: ["private_industry"],
			research_cost: 75,
			category: "economic_technology",
			modifiers: [
				"**+5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
			}
		},
		improved_agriculture: {
			icon: "<:food:716797746715033602>",
			description: "By improving the quality and management of our irrigation systems, we can help ensure that farmers are receiving the water that they need to maintain crop growth, boosting yields.",
			prerequisite_techs: ["economic_mobility"],
			research_cost: 100,
			category: "economic_technology",
			modifiers: [
				"**+1** Farm per city"
			],
			unlocks: function (usr) {
				usr.modifiers.farms = usr.modifiers.farms + 1;
			}
		},
		wooden_rails: {
			icon: "<:paper:759161240987369522>",
			description: "Using wooden railway systems to cart out heavy loads of stone and ore could improve the efficiency of retrieval from mineral seams and quarries.",
			prerequisite_techs: ["wood_beam_support"],
			research_cost: 100,
			category: "economic_technology",
			modifiers: [
				"**+5%** RGO Throughput",
				"**+1** Coal Mine per city",
				"**+1** Quarry per city"
			],
			unlocks: function (usr) {
				usr.modifiers.rgo_throughput = usr.modifiers.rgo_throughput + 0.05;
				usr.modifiers.quarries = usr.modifiers.quarries + 1;
				usr.modifiers.coal_mines = usr.modifiers.coal_mines + 1;
			}
		},
		banking: {
			icon: "<:money:716817688718213192>",
			description: "The early concept of banking revolved not around safely storing money, but by lending money out to debtors who were then required to pay an interest on that loan, as usury slowly became to be seen as less of a social sin over time.",
			prerequisite_techs: ["early_capitalism"],
			research_cost: 100,
			category: "economic_technology",
			modifiers: [
				"**+3%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.03;
			}
		},
		mercantilism: {
			icon: "<:trade:716828677115084812>",
			description: "Mercantilism was an economic theory that stipulated tha tthe world only held finite sources of wealth, and that nations and empires must compete for them in order to become the most prosperous, thereby depriving their fellow nations of sources of wealth.",
			prerequisite_techs: ["early_capitalism"],
			research_cost: 100,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency",
				"**-2%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency - 0.02;
			}
		},
		the_scythe: {
			icon: "<:government:716817688693047306>",
			description: "The scythe is a tool for cutting crops that became developed more and more regularly as new farming techniques spread throughout the Continent in the 15th century.",
			prerequisite_techs: ["improved_agriculture"],
			research_cost: 150,
			category: "economic_technology",
			modifiers: [
				"**+1** Farms per city",
				"**+2%** Population Growth Rate"
			],
			unlocks: function (usr) {
				usr.modifiers.farms = usr.modifiers.farms + 1;
				usr.pop_growth_modifier = usr.pop_growth_modifier + 0.02;
			}
		},
		water_power: {
			icon: "<:factory:759161240601493525>",
			description: "By utilising the power of water to grind materials such as grain and for other usages such as sawing wood, we can improve production efficiency thoroughly and establish its value in providing rotational motion.",
			prerequisite_techs: ["economic_mobility"],
			research_cost: 150,
			category: "economic_technology",
			modifiers: [
				"**+1** Guild per city",
				"**+1** Workshop per city"
			],
			unlocks: function (usr) {
				usr.modifiers.guilds = usr.modifiers.guilds + 1;
				usr.modifiers.workshops = usr.modifiers.workshops + 1;
			}
		},
		paper_currency: {
			icon: "<:paper:759161240987369522>",
			description: "Although some may object to the usage of paper money as it carries no inert value, it becomes far easier to carry and print than normal coins, and provided that they are backed by something of monetary value, such as gold, there should be no reason why we should not use it.",
			prerequisite_techs: ["banking"],
			research_cost: 150,
			category: "economic_technology",
			modifiers: [
				"**+5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
			}
		},
		stock_market: {
			icon: "<:trade:716828677115084812>",
			description: "By diversifying investor risk and providing capital for new businesses, we can speed up economic growth and efficiency in our country.",
			prerequisite_techs: ["mercantilism"],
			research_cost: 150,
			category: "economic_technology",
			modifiers: [
				"**+10%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.10;
			}
		},
		improved_irrigation: {
			icon: "<:food:716797746715033602>",
			description: "Improving our irrigation could mean that our nation has more expendable arable land that can be used for the production of food.",
			prerequisite_techs: ["the_scythe","water_power"],
			research_cost: 200,
			category: "economic_technology",
			modifiers: [
				"**+1** Farms per city"
			],
			unlocks: function (usr) {
				usr.modifiers.farms = usr.modifiers.farms + 1;
			}
		},
		the_watermill: {
			icon: "<:factory:759161240601493525>",
			description: "The watermill is a type of manufactory that is reliant on water to provide rotational motion, typically by sitting near a flowing source of water, such as a river.",
			prerequisite_techs: ["water_power"],
			research_cost: 200,
			category: "economic_technology",
			modifiers: [
				"Enables **Watermills**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("watermills");
			}
		},
		steel_tools: {
			icon: "<:steel:716791408828088420>",
			description: "Steel tools, through their merit as a harder and more durable material than iron, should become the main material upon which our new tools are based, allowing for more efficient mining of iron and harder metals.",
			prerequisite_techs: ["wooden_rails"],
			research_cost: 200,
			category: "economic_technology",
			modifiers: [
				"Enables **Iron Mines**",
				"**+3** Lumberjacks per city",
				"**+1** Quarry per city"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("iron_mines");
				usr.modifiers.lumberjacks = usr.modifiers.lumberjacks + 3;
				usr.modifiers.quarries = usr.modifiers.quarries + 1;
			}
		},
		banknotes: {
			icon: "<:money:716817688718213192>",
			description: "Banknotes, initially starting out as I.O.U. scraps issued by more reputable entities, eventually came to be a currency in itself, often backed up by the local government in smaller city-states.",
			prerequisite_techs: ["paper_currency"],
			research_cost: 200,
			category: "economic_technology",
			modifiers: [
				"**+3%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.03;
			}
		},
		four_field_crop_rotation: {
			icon: "<:provinces:716809229603700737>",
			description: "With the advent of the First Agricultural Revolution, our noblemen have made a discovery that the fertility of the soil can be maintained via crop rotation, in such a manner so that our fields do not have to go fallow in any year.",
			prerequisite_techs: ["improved_irrigation"],
			research_cost: 250,
			category: "economic_technology",
			modifiers: [
				"**+3%** Population Growth Rate",
				"**+1** Farms per city"
			],
			unlocks: function (usr) {
				usr.pop_growth_modifier = usr.pop_growth_modifier + 0.03;
				usr.modifiers.farms = usr.modifiers.farms + 1;
			}
		},
		manufactories: {
			icon: "<:factory:759161240601493525>",
			description: "Manufactories were organised places of work where valuable goods were assembled. The advent of this institution quickly obsoleted the guild.",
			prerequisite_techs: ["the_watermill","steel_tools"],
			research_cost: 250,
			category: "economic_technology",
			modifiers: [
				"Enables **Manufactories**",
				"Obsoletes **Guilds**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("manufactories");
				deleteElement(usr.available_buildings, "guilds");
			}
		},
		trading_companies: {
			icon: "<:trade:716828677115084812>",
			description: "Trading companies were typically private enterprises, often with limited state support, that were allowed to go to far off lands to claim them for their mother country, and bring back exotic goods for a profit.",
			prerequisite_techs: ["stock_market"],
			research_cost: 250,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency",
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		land_centralisation: {
			icon: "<:provinces:716809229603700737>",
			description: "Although unpopular amongst the peasantry for the sheer amount of land that land centralisation will take away, it will have a drastic effect on agricultural efficiency, and possibly even begin a population boom.",
			prerequisite_techs: ["four_field_crop_rotation"],
			research_cost: 350,
			category: "economic_technology",
			modifiers: [
				"Enables **Centralised Farms**",
				"**+5%** Population Growth Rate",
				"**-1** Farms per city",
				"**-10%** Stability"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("centralised_farms");
				usr.pop_growth_modifier = usr.pop_growth_modifier + 0.05;
				usr.modifiers.farms = usr.modifiers.farms - 1;
				usr.stability = usr.stability - 10;
			}
		},
		ventilating_galleries: {
			icon: "<:stone:716796878649426020>",
			description: "The introduction of ventilating galleries to our mines will help provide much needed oxygen to our miners, allowing our mines to go deeper than ever before in search of valuable minerals ...",
			prerequisite_techs: ["the_watermill","steel_tools"],
			research_cost: 350,
			category: "economic_technology",
			modifiers: [
				"Enables **Gold Mines**",
				"**+5%** Building Cost"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("gold_mines");
				usr.modifiers.building_cost = usr.modifiers.building_cost + 0.05;
			}
		},
		global_trading: {
			icon: "<:taxes:716817688781127810>",
			description: "As our network of trading ports begin to criss-cross the world, globalisation of trade is becoming increasingly common, and more and more exotic goods are beginning to reach our shores ... goods that our craftsmen could surely learn a lot from.",
			prerequisite_techs: ["banknotes","trading_companies"],
			research_cost: 350,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency",
				"**-5%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.05;
			}
		},
		selective_breeding: {
			icon: "<:culture:758424912049864784>",
			description: "Through the usage of selective breeding to grow our livestock as fat as possible, we can improve farming efficiency and output higher meat yields per hectare than ever before.",
			prerequisite_techs: ["land_centralisation"],
			research_cost: 500,
			category: "economic_technology",
			modifiers: [
				"**+1** Centralised Farms per city"
			],
			unlocks: function (usr) {
				usr.modifiers.centralised_farms = usr.modifiers.centralised_farms + 1;
			}
		},
		putting_out_system: {
			icon: "<:development:716811992421367869>",
			description: "The putting-out system, similar in nature to the cottage industry, allowed centralised businesses to distribute production over a wide range of households, before turning them in. It was primarily used in the fields of manufacturing and textiles.",
			prerequisite_techs: ["manufactories"],
			research_cost: 500,
			category: "economic_technology",
			modifiers: [
				"**+10%** RGO Throughput"
			],
			unlocks: function (usr) {
				usr.modifiers.rgo_throughput = usr.modifiers.rgo_throughput + 0.10;
			}
		},
		centralised_banking: {
			icon: "<:money:716817688718213192>",
			description: "Via the establishment of a central bank, our national government will have more say over economic policy, and will be able to right the ship that is our nation, should the storms of a financial panic come.",
			prerequisite_techs: ["global_trading"],
			research_cost: 500,
			category: "economic_technology",
			modifiers: [
				"**+5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
			}
		},
		megacorporations: {
			icon: "<:old_scroll:716828676880334881>",
			description: "By licensing monopolies to certain companies to dominate entire regions of trade, we can improve the trade efficiency of our nation and create loyal vassals subject only to us.",
			prerequisite_techs: ["global_trading"],
			research_cost: 500,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
			}
		},
		improved_transportation: {
			icon: "<:actions:716817688244256770>",
			description: "Improving the quality and quantity of roads in the countryside, as well as building new canals could go a long way in improving the amount of natural resources we gain.",
			prerequisite_techs: ["selective_breeding"],
			research_cost: 650,
			category: "economic_technology",
			modifiers: [
				"**+5%** RGO Throughput"
			],
			unlocks: function (usr) {
				usr.modifiers.rgo_throughput = usr.modifiers.rgo_throughput + 0.05;
			}
		},
		mills: {
			icon: "<:factory:759161240601493525>",
			description: "Mills, similar to watermills, are used to described improved manufactories capable of translating waterpower into rotational motion for the manufacturing of various products.",
			prerequisite_techs: ["putting_out_system"],
			research_cost: 650,
			category: "economic_technology",
			modifiers: [
				"Enables **Mills**",
				"**+1** Manufactory per city"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("mills");
				usr.modifiers.manufactories = usr.modifiers.manufactories + 1;
			}
		},
		pig_iron_smelting: {
			icon: "<:factory:759161240601493525>",
			description: "Pig iron, also known as crude iron is the product obtained by smelteries from merely smelting raw iron without adding any carbon. It was used as a intermediary between raw iron and wrought iron, which was used in construction.",
			prerequisite_techs: ["ventilating_galleries"],
			research_cost: 650,
			category: "economic_technology",
			modifiers: [
				"**-5%** Building Cost",
				"**+1** Iron Mines per city"
			],
			unlocks: function (usr) {
				usr.modifiers.building_cost = usr.modifiers.building_cost - 0.05;
				usr.modifiers.iron_mines = usr.modifiers.iron_mines + 1;
			}
		},
		modern_loans_and_bonds: {
			icon: "<:money:716817688718213192>",
			description: "By keeping good track of the amount of debt that our clients owe us, we can ensure that debt is fairly collected, and that creditors do not take advantage of their position, giving investors and businesses more confidence in our nation's economy.",
			prerequisite_techs: ["centralised_banking"],
			research_cost: 650,
			category: "economic_technology",
			modifiers: [
				"**+5%** Tax Efficiency",
				"**-5%** Building Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency - 0.05;
				usr.modifiers.building_cost = usr.modifiers.building_cost - 0.05;
			}
		},
		monetary_exchange: {
			icon: "<:paper:759161240987369522>",
			description: "Through allowing foreign currencies to be traded between nations, we can raise capital, even from foreign lands to help support our businesses, whereas older means of monetary exchange were more inconvenient, and relied on the trust in the banker.",
			prerequisite_techs: ["megacorporations"],
			research_cost: 650,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
			}
		},
		rotherham_plough: {
			icon: "<:iron:716791408819961866>",
			description: "The Rotherham Plough, one of the first great modern tools of agriculture, was used for tilling the soil prior to planting in order to expose the most nutrients for crops. It was typically driven by an ox, and was the first to be produced on a mass scale.",
			prerequisite_techs: ["improved_transportation"],
			research_cost: 750,
			category: "economic_technology",
			modifiers: [
				"**+2%** Population Growth Rate",
				"**+1** Centralised Farms per city"
			],
			unlocks: function (usr) {
				usr.pop_growth_modifier = usr.pop_growth_modifier + 0.02;
				usr.modifiers.centralised_farms = usr.modifiers.centralised_farms + 1;
			}
		},
		government_banknotes: {
			icon: "<:paper:759161240987369522>",
			description: "Through the issuing of banknotes ourselves rather than from other banks and private institutions, we can help improve investor confidence and the level of trust that the public holds in us regarding the subject of paper currency.",
			prerequisite_techs: ["modern_loans_and_bonds"],
			research_cost: 750,
			category: "economic_technology",
			modifiers: [
				"**+3%** Tax Efficiency",
				"**+5%** Stability"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.03;
				usr.stability = usr.stability + 5;
			}
		},
		physiocracy: {
			icon: "<:knowledge:716797747193446441>",
			description: "Physiocracy, one of the first economic theories to emerge after mercantilism, was its direct opposite that believed that the wealth of nations derived not from overseas trade, but from the domestic economy, which was primarily agrarian in nature. They became popular during the later half of the 18th century, but never gained much traction outside of it, and is today considered the predecessor to classical economics.",
			prerequisite_techs: ["monetary_exchange"],
			research_cost: 750,
			category: "economic_technology",
			modifiers: [
				"**+2%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.02;
			}
		},
		early_steam_engine: {
			icon: "<:factory:759161240601493525>",
			description: "Although the early steam engine may not have been particularly efficient in deriving power on its own, it was often used to help ventilate mines, leading to miners being able to stay down for longer, and deeper, than ever before.",
			prerequisite_techs: ["mills"],
			research_cost: 900,
			category: "economic_technology",
			modifiers: [
				"**+5%** RGO Throughput"
			],
			unlocks: function (usr) {
				usr.modifiers.rgo_throughput = usr.modifiers.rgo_throughput + 0.05;
			}
		},
		deeper_mineshafts: {
			icon: "<:factory:759161240601493525>",
			description: "By drilling deeper mineshafts, and in some cases, simply vertical mineshafts into the face of the earth, we can expose new mineral seams that may not have been possible before, and with the emerging science of prospection, improve overall resource extraction efficiency.",
			prerequisite_techs: ["pig_iron_smelting"],
			research_cost: 900,
			category: "economic_technology",
			modifiers: [
				"**+1** Iron Mines per city",
				"**+1** Coal Mines per city",
				"**+2** Quarries per city",
				"**+10%** RGO Throughput"
			],
			unlocks: function (usr) {
				usr.modifiers.iron_mines = usr.modifiers.iron_mines + 1;
				usr.modifiers.coal_mines = usr.modifiers.coal_mines + 1;
				usr.modifiers.quarries = usr.modifiers.quarries + 2;
				usr.modifiers.rgo_throughput = usr.modifiers.rgo_throughput + 0.10;
			}
		},
		bullionism: {
			icon: "<:gold:716798541028261927>",
			description: "Bullionism, the direct antecedent to the gold and silver standards, was an economic doctrine which held that the value of the currency relied on precious metals, particularly gold, and that nations should store as much of it as possible in order to guarantee the safety and stability of their currencies, although it will take some initial startup capital to secure our gold and silver reserves ...",
			prerequisite_techs: ["government_banknotes"],
			research_cost: 900,
			category: "economic_technology",
			modifiers: [
				"**-5%** Tax Efficiency",
				"**+5%** Stability"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency - 0.05;
				usr.stability = usr.stability + 5;
			}
		},
		free_trade_doctrine: {
			icon: "<:trade:716828677115084812>",
			description: "One of the earliest schools of thought to come out of classical economics, the free trade doctrine posited that if all nations began lifting tariffs and severely limiting protectionism, the wealth of a country would benefit as a result, as trade with more nations would become possible.",
			prerequisite_techs: ["physiocracy"],
			research_cost: 900,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
			}
		},
		sodium_nitrate: {
			icon: "<:paper:759161240987369522>",
			description: "Sodium nitrate, similar to salt, was a preservative used to keep meats consumable for long periods of time. It was eventually superseded by refrigeration technologies.",
			prerequisite_techs: ["rotherham_plough"],
			research_cost: 1000,
			category: "economic_technology",
			modifiers: [
				"**+1%** Population Growth Rate"
			],
			unlocks: function (usr) {
				usr.pop_growth_modifier = usr.pop_growth_modifier + 0.01;
			}
		},
		factories: {
			icon: "<:factory:759161240601493525>",
			description: "With the advent of the economically viable steam engine, rotational motion no longer depended on a country's waterways, but on their coal reserves, as steam could now be easily and accessibly generated from any location, leading to the birth of huge industrial cities that became the forges and arsenals of entire nations.",
			prerequisite_techs: ["early_steam_engine"],
			research_cost: 1000,
			category: "economic_technology",
			modifiers: [
				"Enables **Factories**",
				"Unlocks **Minimum Wage** Reforms",
				"Obsoletes **Workshops**",
				"Obsoletes **Watermills**",
				"Obsoletes **Manufactories**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("factories");
				unlockReform(usr.id, "minimum_wage");
				deleteElement(usr.available_buildings, "workshops");
				deleteElement(usr.available_buildings, "watermills");
				deleteElement(usr.available_buildings, "manufactories");
			}
		},
		cast_iron_construction: {
			icon: "<:iron:716791408819961866>",
			description: "The development of cast iron has allowed structures to be built for cheaper than ever before, whilst maintaining structural integrity. Although relatively brittle, further developments in metallurgy could yield increasingly better results ...",
			prerequisite_techs: ["early_steam_engine"],
			research_cost: 1000,
			category: "economic_technology",
			modifiers: [
				"**-3%** Building Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.building_cost = usr.modifiers.building_cost - 0.03;
			}
		},
		early_classical_theory: {
			icon: "<:paper:759161240987369522>",
			description: "An umbrella term for a variety of differing opinions on economic thought, early classical theory first proposed the concept of the 'invisible hand', by which markets would be able to regulate themselves, and soon became the prevailing form of economic thought throughout Western capitalist economies in the 19th century.",
			prerequisite_techs: ["free_trade_doctrine"],
			research_cost: 1000,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
			}
		},
		improved_steam_engine: {
			icon: "<:technology:716812861514711040>",
			description: "By reducing the amount of energy lost from the usage of the steam engine, we can create a more efficient mechanism for translating coal and water into the machine needed to power today's factories.",
			prerequisite_techs: ["factories"],
			research_cost: 1200,
			category: "economic_technology",
			modifiers: [
				"**+3%** RGO Throughput",
				"**+2%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.rgo_throughput = usr.modifiers.rgo_throughput + 0.03;
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.02;
			}
		},
		wrought_iron_construction: {
			icon: "<:iron:716791408819961866>",
			description: "Wrought iron, or pure iron, was a relatively malleable form of the metal that could be worked into various shapes relatively easily because of its low carbon content, with its main drawback being brittleness.",
			prerequisite_techs: ["cast_iron_construction"],
			research_cost: 1200,
			category: "economic_technology",
			modifiers: [
				"**-3%** Building Cost"
			],
			unlocks: function (usr) {
				usr.modifiers.building_cost = usr.modifiers.building_cost - 0.03;
			}
		},
		gold_standard: {
			icon: "<:gold:716798541028261927>",
			description: "The gold standard, which swept the Continent and Great Britain during the 19th century, was an economic term used to describe the backing of paper currency by gold in order to protect the value of the currency from dangers such as debasing. It was largely abandoned after Bretton Woods.",
			prerequisite_techs: ["bullionism"],
			research_cost: 1200,
			category: "economic_technology",
			modifiers: [
				"**+5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
			}
		},
		economic_unions: {
			icon: "<:trade:716828677115084812>",
			description: "In areas densely populated by sovereign units, such as Germany or Italy, trade/economic unions became increasingly common, allowing for no customs checks when crossing borders, and for facilitating well-rounded trade free of robber barons.",
			prerequisite_techs: ["early_classical_theory"],
			research_cost: 1200,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
			}
		},
		guano: {
			icon: "<:paper:759161240987369522>",
			description: "Guano, the aggregate excrement accumulated from bird droppings is a valuable fertiliser, and can also be used in the manufacture of explosives and gunpowder.",
			prerequisite_techs: ["sodium_nitrate"],
			research_cost: 1400,
			category: "economic_technology",
			modifiers: [
				"**+2%** Population Growth Rate"
			],
			unlocks: function (usr) {
				usr.pop_growth_modifier = usr.pop_growth_modifier + 0.02;
			}
		},
		early_steel_factories: {
			icon: "<:steel:716791408828088420>",
			description: "Early steel factories used industrial blast furnaces in an attempt to produce more steel. But without the invention of the Bessemer Process, steel remained a relatively expensive material as impurities were still hard to remove.",
			prerequisite_techs: ["improved_steam_engine"],
			research_cost: 1400,
			category: "economic_technology",
			modifiers: [
				"**+1** Factories per city"
			],
			unlocks: function (usr) {
				usr.modifiers.factories = usr.modifiers.factories + 1;
			}
		},
		silver_standard: {
			icon: "<:iron:716791408819961866>",
			description: "Although reserves of gold may not always be available, there remain other precious metals with which we can back up our currency, primarily silver, which economists have suggested may help to provide a more stable backing than mere gold alone.",
			prerequisite_techs: ["improved_steam_engine"],
			research_cost: 1400,
			category: "economic_technology",
			modifiers: [
				"**+3%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.03;
			}
		},
		late_classical_theory: {
			icon: "<:money:716817688718213192>",
			description: "As the memories of feudalism begin to fade more and more into obscurity, economists are beginning to recognise the market potential held by industrial factories and enterprises, and are beginning to transform the field into a true science.",
			prerequisite_techs: ["economic_unions"],
			research_cost: 1400,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
			}
		},
		experimental_railways: {
			icon: "<:steel:716791408828088420>",
			description: "Through the usage of railways, we can speed up transport around the country, unlocking potential in areas never quite developed before.",
			prerequisite_techs: ["early_steel_factories","wrought_iron_construction"],
			research_cost: 1600,
			category: "economic_technology",
			modifiers: [
				"**+1** Extra Building Slots per city"
			],
			unlocks: function (usr) {
				usr.modifiers.extra_building_slots = usr.modifiers.extra_building_slots + 1;
			}
		},
		shaft_mining: {
			icon: "<:wood:716791408928751636>",
			description: "The development of shafts not only as ventilating galleries, but as the main conduit for the mine itself is changing the field of mining, allowing us to access deeper pockets of minerals than previously deemed possible.",
			prerequisite_techs: ["early_steel_factories","wrought_iron_construction"],
			research_cost: 1600,
			category: "economic_technology",
			modifiers: [
				"Enables **Lead Mines**",
				"**+1** Iron Mines per city",
				"**+1** Coal Mines per city",
				"**+1** Gold Mines per city",
				"**+1** Quarries per city"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("lead_mines");
				usr.modifiers.iron_mines = usr.modifiers.iron_mines + 1;
				usr.modifiers.coal_mines = usr.modifiers.coal_mines + 1;
				usr.modifiers.gold_mines = usr.modifiers.gold_mines + 1;
				usr.modifiers.quarries = usr.modifiers.quarries + 1;
			}
		},
		bimetallism: {
			icon: "<:gold:716798541028261927>",
			description: "The introduction of bimetallism, an economic theory which postulates that fiscal currency can be backed most effectively through a combination of precious metals, particularly silver and gold, holds promise, and can be adopted as the official policy of our country.",
			prerequisite_techs: ["silver_standard"],
			research_cost: 1600,
			category: "economic_technology",
			modifiers: [
				"**+5%** Stability"
			],
			unlocks: function (usr) {
				usr.stability = usr.stability + 5;
			}
		},
		forced_trade_agreements: {
			icon: "<:trade:716828677115084812>",
			description: "With improvements in our military technology, we now possess the ability to force open the doors of some ... lesser nations, allowing us to sign treaties extremely favourable to ourselves, and allowing for our businesses to take advantage of their economy.",
			prerequisite_techs: ["late_classical_theory"],
			research_cost: 1600,
			category: "economic_technology",
			modifiers: [
				"**+1** Political Capital Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.political_capital_gain = usr.modifiers.political_capital_gain + 1;
			}
		},
		fertiliser_development: {
			icon: "<:development:716811992421367869>",
			description: "Synthesising fertiliser from guano could yield a massive boost to agriculture and the more agrarian sectors of our society, as more land can now be turned into arable soil.",
			prerequisite_techs: ["guano"],
			research_cost: 1800,
			category: "economic_technology",
			modifiers: [
				"**+2** Farms",
				"**+3** Centralised Farms",
				"**-4%** Population Growth Rate"
			],
			unlocks: function (usr) {
				usr.modifiers.farms = usr.modifiers.farms + 2;
				usr.modifiers.centralised_farms = usr.modifiers.centralised_farms + 3;
				usr.pop_growth_modifier = usr.pop_growth_modifier - 0.04;
			}
		},
		iron_railways: {
			icon: "<:steel:716791408828088420>",
			description: "The construction of iron railways throughout our country will greatly speed up transport and improve the quality of infrastructure, allowing for more manufactured goods and raw resources to travel throughout.",
			prerequisite_techs: ["experimental_railways"],
			research_cost: 1800,
			category: "economic_technology",
			modifiers: [
				"**+10%** RGO Throughput"
			],
			unlocks: function (usr) {
				usr.modifiers.rgo_throughput = usr.modifiers.rgo_throughput + 0.10;
			}
		},
		unequal_treaties: {
			icon: "<:cb:716828676855169107>",
			description: "Although they may be unequal, by ensuring that they're unequal only for them, and not for us, we can extract more raw resources from our 'spheres of influence', even if those areas are not precisely ours.",
			prerequisite_techs: ["forced_trade_agreements"],
			research_cost: 1800,
			category: "economic_technology",
			modifiers: [
				"**+3%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.03;
			}
		},
		coprolite_fertiliser: {
			icon: "<:food:716797746715033602>",
			description: "Coprolite fertiliser, made from the fossilised excrement of dead animals, helps to enrich the soil on which it is applied, boosting crop yields over the selected area.",
			prerequisite_techs: ["fertiliser_development"],
			research_cost: 2000,
			category: "economic_technology",
			modifiers: [
				"**+1%** Population Growth Rate"
			],
			unlocks: function (usr) {
				usr.pop_growth_modifier = usr.pop_growth_modifier + 0.01;
			}
		},
		arsenals: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "Arsenals are vast, sprawling military factories responsible for the production of arms and ammunition, as well as their maintenace and restoration.",
			prerequisite_techs: ["iron_railways"],
			research_cost: 2000,
			category: "economic_technology",
			modifiers: [
				"Enables **Arsenals**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("arsenals");
			}
		},
		global_finance: {
			icon: "<:money:716817688718213192>",
			description: "With the invention of the telegraph, financial transactions can now be made instantaneously, revolutionising the speed at which commerce and business can travel.",
			prerequisite_techs: ["bimetallism"],
			research_cost: 2000,
			category: "economic_technology",
			modifiers: [
				"**+5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
			}
		},
		protectionism: {
			icon: "<:workers:732730754735276124>",
			description: "By protecting our companies from foreign competitors whilst still in their infancy, we can help nurture a growing domestic industry here at home. Free trade is not always right.",
			prerequisite_techs: ["iron_railways"],
			research_cost: 2000,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
			}
		},
		seed_drill: {
			icon: "<:steel:716791408828088420>",
			description: "Seed drills, agricultural supplements that assist in the planting of seeds, can help boost agricultural efficiency, as up until now, seeds would often be scattered on tilled fields, instead of properly planted.",
			prerequisite_techs: ["coprolite_fertiliser"],
			research_cost: 2500,
			category: "economic_technology",
			modifiers: [
				"**+1** Centralised Farm per city"
			],
			unlocks: function (usr) {
				usr.modifiers.centralised_farms = usr.modifiers.centralised_farms + 1;
			}
		},
		shift_work: {
			icon: "<:building:716827579650408538>",
			description: "By making workers work in shifts, we can keep a business operating 24/7, regardless of worker tiredness, as workers can be cycled in and out.",
			prerequisite_techs: ["arsenals"],
			research_cost: 2500,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency",
				"Unlocks **Maximum Workhours** Reforms"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
				unlockReform(usr.id, "maximum_workhours");
			}
		},
		bessemer_process: {
			icon: "<:steel:716791408828088420>",
			description: "The Bessemer Process was the first large-scale economical way of removing impurities from pig iron. Although largely superseded by modern steelmaking techniques, it played a pivotal role in transforming steel into a major industry and construction material.",
			prerequisite_techs: ["shaft_mining"],
			research_cost: 2500,
			category: "economic_technology",
			modifiers: [
				"Enables **Steelworks**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("steelworks");
			}
		},
		laissez_faire_doctrine: {
			icon: "<:trade:716828677115084812>",
			description: "French for 'let it be', proponents of laissez-faire believe that the government should interfere only minimally with the economy in order to let the market regulate themselves.",
			prerequisite_techs: ["protectionism"],
			research_cost: 2500,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency",
				"**-5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency - 0.05;
			}
		},
		assembly_plants: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "Assembly plants rely on assembly lines to speed up production and standardise parts and equipment, with work compartmentalised into a manner where each individual labourer has only one simple task to do.",
			prerequisite_techs: ["shift_work"],
			research_cost: 3000,
			category: "economic_technology",
			modifiers: [
				"Enables **Assembly Plants**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("assembly_plants");
			}
		},
		steelworks: {
			icon: "<:steel:716791408828088420>",
			description: "By subsidising the steel industry, our nation can become self-sustaining in the industry, and perhaps even begin exporting to other nations.",
			prerequisite_techs: ["bessemer_process"],
			research_cost: 3000,
			category: "economic_technology",
			modifiers: [
				"**+2** Steelworks per city"
			],
			unlocks: function (usr) {
				usr.modifiers.steelworks = usr.modifiers.steelworks + 2;
			}
		},
		corporatism: {
			icon: "<:trade:716828677115084812>",
			description: "Through tolerating ... and supporting huge magnates of industry, we can improve industrial efficiency as the number of competitors, and thereby number of entities to placate becomes significantly lessened.",
			prerequisite_techs: ["laissez_faire_doctrine"],
			research_cost: 3000,
			category: "economic_technology",
			modifiers: [
				"**+5%** Tax Efficiency",
				"**+5%** Production Efficiency",
				"Unlocks **Trade Union** Reforms",
				"**-5%** Reform Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
				unlockReform(usr.id, "trade_unions");
			}
		},
		crop_variation: {
			icon: "<:food:716797746715033602>",
			description: "By planting varied crops of the same species, we can improve agricultural and nutritional diversity amongst our population, as well as reduce the risk of a blight striking a staple crop.",
			prerequisite_techs: ["seed_drill"],
			research_cost: 3500,
			category: "economic_technology",
			modifiers: [
				"**+2** Farms per city"
			],
			unlocks: function (usr) {
				usr.modifiers.farms = usr.modifiers.farms + 2;
			}
		},
		refineries: {
			icon: "<:petroil:716791408748658739>",
			description: "The capability to refine petroleum could become extremely valuable in the future, as it is already widely used in terms of lighting, and is a material that promises to have additional uses in the future.",
			prerequisite_techs: ["assembly_plants"],
			research_cost: 3500,
			category: "economic_technology",
			modifiers: [
				"Enables **Refineries**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("refineries");
			}
		},
		cheap_coal: {
			icon: "<:coal:716791408714973204>",
			description: "With the advent of more modern resource extraction techniques, the age of cheap coal is upon us, promising a quick solution to our power needs, despite its polluting qualities.",
			prerequisite_techs: ["steelworks"],
			research_cost: 3500,
			category: "economic_technology",
			modifiers: [
				"**+3** Coal Mines per city"
			],
			unlocks: function (usr) {
				usr.modifiers.coal_mines = usr.modifiers.coal_mines + 3;
			}
		},
		neoclassical_theory: {
			icon: "<:money:716817688718213192>",
			description: "Neoclassical theory was an economic school of thought that sought to focus on the supply and demand side of economics.",
			prerequisite_techs: ["laissez_faire_doctrine"],
			research_cost: 3500,
			category: "economic_technology",
			modifiers: [
				"**+3%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.03;
			}
		},
		improved_machinery: {
			icon: "<:factory:759161240601493525>",
			description: "Using more advanced machinery will allow our farmers to farm greater amounts of land than typically possible by hand.",
			prerequisite_techs: ["improved_machinery"],
			research_cost: 4000,
			category: "economic_technology",
			modifiers: [
				"**+1%** Population Growth Rate",
				"**+5%** National Manpower"
			],
			unlocks: function (usr) {
				usr.pop_growth_modifier = usr.pop_growth_modifier + 0.01;
				usr.modifiers.national_manpower = usr.modifiers.national_manpower + 0.05;
			}
		},
		petrol_pipelines: {
			icon: "<:petroil:716791408748658739>",
			description: "By relying on the usage of pipelines to transport petroleum instead of the railway companies, petroleum refineries can cut costs and have dedicated infrastructure for transport, reducing vulnerability.",
			prerequisite_techs: ["improved_machinery"],
			research_cost: 4000,
			category: "economic_technology",
			modifiers: [
				"**+2** Refineries per city"
			],
			unlocks: function (usr) {
				usr.modifiers.refineries = usr.modifiers.refineries + 2;
			}
		},
		cheap_iron: {
			icon: "<:iron:716791408819961866>",
			description: "With dedicated infrastructure being devoted to the extraction of iron, our nation can now set up new iron mines in newly prospected locations, an emerging field of science that didn't exist mere decades ago.",
			prerequisite_techs: ["improved_machinery"],
			research_cost: 4000,
			category: "economic_technology",
			modifiers: [
				"**+3** Iron Mines per city"
			],
			unlocks: function (usr) {
				usr.modifiers.iron_mines = usr.modifiers.iron_mines + 3;
			}
		},
		state_regulation: {
			icon: "<:building:716827579650408538>",
			description: "Although a capitalist economy might be the best way forwards for our country, steps should be taken to form a comprehensive net to ensure that our workers don't fall through the cracks. By regulating some of its excesses, we can introduce a mixed economy that might lead to greater social stability.",
			prerequisite_techs: ["improved_machinery"],
			research_cost: 4000,
			category: "economic_technology",
			modifiers: [
				"Unlocks **Safety Regulations** Reforms",
				"Unlocks **Unemployment** Reforms"
			],
			unlocks: function (usr) {
				unlockReform(usr.id, "safety_regulations");
				unlockReform(usr.id, "unemployment");
			}
		},
		international_trade_agreements: {
			icon: "<:old_scroll:716828676880334881>",
			description: "The detailing of exact terms of trade might help lift some of the unease that falls upon our investors and corporations when trading with other countries.",
			prerequisite_techs: ["neoclassical_theory"],
			research_cost: 4000,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
			}
		},
		early_tractors: {
			icon: "<:food:716797746715033602>",
			description: "As mechanisation slowly takes over the business of agriculture, the amount of labour that needs to be devoted to it is beginning to decrease sharply. Paired with drastic urbanisation, the future of our country is set to be made in the cities.",
			prerequisite_techs: ["improved_machinery"],
			research_cost: 4000,
			category: "economic_technology",
			modifiers: [
				"Enables **Modern Farms**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("modern_farms");
			}
		},
		industrial_complexes: {
			icon: "<:factory:759161240601493525>",
			description: "Industrial complexes are sprawling behemoths of industry that oftentimes employ tens of thousands of workers. The industrial output generated from them can be deployed for a variety of uses.",
			prerequisite_techs: ["petrol_pipelines","cheap_iron"],
			research_cost: 4000,
			category: "economic_technology",
			modifiers: [
				"Enables **Industrial Complexes**",
				"Enables **Research Complexes**",
				"Obsoletes **Factories**",
				"Obsoletes **Mills**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("industrial_complexes");
				usr.available_buildings.push("research_complexes");
				deleteElement(usr.available_buildings, "factories");
				deleteElement(usr.available_buildings, "mills");
			}
		},
		bank_holidays: {
			icon: "<:money:716817688718213192>",
			description: "By utilising our governmental authority to prevent private citizens from withdrawing from their bank accounts during times of economic crisis, we can prevent the wholesale collapse of entire banks, and bank runs, with the result being increased economic resilience.",
			prerequisite_techs: ["state_regulation"],
			research_cost: 4000,
			category: "economic_technology",
			modifiers: [
				"**+3%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.03;
			}
		},
		economic_responsibility: {
			icon: "<:old_scroll:716828676880334881>",
			description: "Although self-regulation of the markets seems to be a valid internal theory, it falls flat when put in practice, and there remain various shortfalls for which the public should hold certain entities accountable. By further developing this position, we can help to ensure that businesses in our country do not simply go unchecked by the general public.",
			prerequisite_techs: ["international_trade_agreements"],
			research_cost: 4000,
			category: "economic_technology",
			modifiers: [
				"**-2%** Tax Efficiency",
				"**+3%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency - 0.02;
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.03;
			}
		},
		mass_production: {
			icon: "<:government:716817688693047306>",
			description: "The improvement of metallurgical production methods in our nation could lead to the more efficient allocation of materials needed to form industrial construction materials.",
			prerequisite_techs: ["petrol_pipelines","cheap_iron"],
			research_cost: 5000,
			category: "economic_technology",
			modifiers: [
				"**+2** Assembly Plants per city",
				"**+2** Industrial Complexes per city",
				"**+2%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.assembly_plants = usr.modifiers.assembly_plants + 2;
				usr.modifiers.industrial_complexes = usr.modifiers.industrial_complexes + 2;
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.02;
			}
		},
		advanced_metallurgy: {
			icon: "<:government:716817688693047306>",
			description: "The improvement of metallurgical production methods in our nation could lead to the more efficient allocation of materials needed to form industrial construction materials.",
			prerequisite_techs: ["petrol_pipelines","cheap_iron"],
			research_cost: 5000,
			category: "economic_technology",
			modifiers: [
				"**+1** Steelworks per city"
			],
			unlocks: function (usr) {
				usr.modifiers.steelworks = usr.modifiers.steelworks + 1;
			}
		},
		investment_banks: {
			icon: "<:money:716817688718213192>",
			description: "Investment banks allow private citizens to hold money in banks that not only generate interest based on loans, but also offer reliable investment options going forwards, helping our citizens to safely invest in our economy.",
			prerequisite_techs: ["bank_holidays"],
			research_cost: 5000,
			category: "economic_technology",
			modifiers: [
				"Unlocks **Pension** Reforms"
			],
			unlocks: function (usr) {
				unlockReform(usr.id, "pensions");
			}
		},
		advanced_tractors: {
			icon: "<:factory:759161240601493525>",
			description: "The improved reliability of new tractors could go a long way in the mechanisation of our country's agricultural sectors, contributing to a boosted crop yield for our farmers.",
			prerequisite_techs: ["mass_production"],
			research_cost: 5500,
			category: "economic_technology",
			modifiers: [
				"**+1** Modern Farms per city"
			],
			unlocks: function (usr) {
				usr.modifiers.modern_farms = usr.modifiers.modern_farms + 1;
			}
		},
		civilian_industry: {
			icon: "<:factory:759161240601493525>",
			description: "As consumer goods reach higher and higher levels of demand, entire factories and industrial complexes dedicated to their production are beginning to spring up around the country, leading to the growth of an organised consumer market.",
			prerequisite_techs: ["mass_production"],
			research_cost: 5500,
			category: "economic_technology",
			modifiers: [
				"Enable **Civilian Industries**",
				"Obsoletes **Factories**",
				"Obsoletes **Mills**",
				"Obsoletes **Workshops**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("civilian_industries");
				deleteElement(usr.available_buildings, "factories");
				deleteElement(usr.available_buildings, "mills");
				deleteElement(usr.available_buildings, "workshops");
			}
		},
		modern_mining_regulations: {
			icon: "<:government_scroll:716828975175041054>",
			description: "Mining may be a risky business, but the venture doesn't always need to cost miners their lives. By enforcing safety regulations, we can reduce the number of on-site accidents and maimings, and reduce dissatisfaction amongst our population.",
			prerequisite_techs: ["advanced_metallurgy"],
			research_cost: 5500,
			category: "economic_technology",
			modifiers: [
				"**-2%** Reform Desire Gain",
				"**-10%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.reform_desire_gain = usr.modifiers.reform_desire_gain - 0.02;
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency - 0.10;
			}
		},
		mutual_funds: {
			icon: "<:old_scroll:716828676880334881>",
			description: "Mutual funds are groupings of investments meant to lower risk by diversifying the burden of investment throughout a multitude of investors. They are typically overseen by portfolio managers and are seen as safe areas for private citizens to invest their money.",
			prerequisite_techs: ["investment_banks"],
			research_cost: 5500,
			category: "economic_technology",
			modifiers: [
				"**+5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
			}
		},
		keynesian_economics: {
			icon: "<:money:716817688718213192>",
			description: "Keynesian economics, first authored by John Maynard Keynes, proposed that government intervention during recessions could help boost consumer spending, leading to the revival of a nation's economy.",
			prerequisite_techs: ["economic_responsibility"],
			research_cost: 5500,
			category: "economic_technology",
			modifiers: [
				"**+2%** Tax Efficiency",
				"**+5%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.02;
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
			}
		},
		advanced_farming_machinery: {
			icon: "<:food:716797746715033602>",
			description: "The further advancement of our nation's machinery could reduce the burden of labour on our farmers, and help improve not only the quantity, but also the quality of the food grown within our nation, leading to the possibility of mass exports.",
			prerequisite_techs: ["advanced_tractors"],
			research_cost: 6000,
			category: "economic_technology",
			modifiers: [
				"**+1** Modern Farms per city"
			],
			unlocks: function (usr) {
				usr.modifiers.modern_farms = usr.modifiers.modern_farms + 1;
			}
		},
		integrated_rail_system: {
			icon: "<:steel:716791408828088420>",
			description: "The centralisation of our rail system will help get rid of a lot of the 'railwaymania' that clogs up our nation, allowing for neat and organised railways where the trains actually run on time. Although some may criticise it as an overextension of our government, there is no question about its effectiveness.",
			prerequisite_techs: ["civilian_industry"],
			research_cost: 6000,
			category: "economic_technology",
			modifiers: [
				"**+5%** RGO Throughput",
				"**+5%** Army Travel Speed"
			],
			unlocks: function (usr) {
				usr.modifiers.rgo_throughput = usr.modifiers.rgo_throughput + 0.05;
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed - 0.05;
			}
		},
		heavy_mining_machinery: {
			icon: "<:lead:716791408840671322>",
			description: "The introduction of heavy machinery into our mines, although making many a miner unemployed, will also inevitably boost resource extraction efficiency, allowing for ore deposits and mineral seams to be excavated faster.",
			prerequisite_techs: ["modern_mining_regulations"],
			research_cost: 6000,
			category: "economic_technology",
			modifiers: [
				"**+5%** RGO Throughput"
			],
			unlocks: function (usr) {
				usr.modifiers.rgo_throughput = usr.modifiers.rgo_throughput + 0.05;
			}
		},
		econometrics: {
			icon: "<:technology:716812861514711040>",
			description: "The application of statistical data for the purpose of analysing economic relationships helps our economists visualise the impact that certain policy decisions may have on the state of our economy. Through efficient analysation, we can help avoid many of the shortfalls that other countries have succumbed to in the past.",
			prerequisite_techs: ["mutual_funds","keynesian_economics"],
			research_cost: 6000,
			category: "economic_technology",
			modifiers: [
				"**+2%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.02;
			}
		},
		wartime_industry: {
			icon: "<:factory:759161240601493525>",
			description: "When in a state of total war, it becomes necessary for the state to mobilise and utilise all resources at its disposal to combat the enemy head-on. Every citizen is expected to do their part, and industry is no exception. By setting up factories that will produce equipment for new battalions, we can help shorten training time in the case of an eventual conflict, as equipment will be ready on site.",
			prerequisite_techs: ["integrated_rail_system"],
			research_cost: 6500,
			category: "economic_technology",
			modifiers: [
				"Enable **Wartime Industries**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("wartime_industries");
			}
		},
		deep_mining: {
			icon: "<:workers:732730754735276124>",
			description: "Deep mining, similar to shaft mining, poses numerous problems, but can be solved with the ingenuity of our engineers. Providing increased efficiency as workers no longer have to descend down long corridors, deep mining will allow us to produce the excess in raw resources that our factories desperately need.",
			prerequisite_techs: ["heavy_mining_machinery"],
			research_cost: 6500,
			category: "economic_technology",
			modifiers: [
				"**+10%** RGO Throughput"
			],
			unlocks: function (usr) {
				usr.modifiers.rgo_throughput = usr.modifiers.rgo_throughput + 0.10;
			}
		},
		divergent_economic_thought: {
			icon: "<:faculty:732730754911436830>",
			description: "Although several schools of economics had previously dominated the landscape, economic thought is beginning to shift in a more divergent direction, with variations of these schools coming into play in an attempt to make up each of their shortfalls.",
			prerequisite_techs: ["econometrics"],
			research_cost: 6500,
			category: "economic_technology",
			modifiers: [
				"**+3%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.03;
			}
		},
		industrial_farming: {
			icon: "<:food:716797746715033602>",
			description: "Industrial farming, or mass farming brings the organisation and efficiency of the factory to the farm as meat and grains can now be harvested across vast swaths of land, and animals can be crammed and fed for maximum efficiency.",
			prerequisite_techs: ["advanced_farming_machinery","wartime_industry"],
			research_cost: 7000,
			category: "economic_technology",
			modifiers: [
				"Enables **Industrial Farms**",
				"Obsoletes **Farms**",
				"Obsoletes **Centralised Farms**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("industrial_farms");
				deleteElement(usr.available_buildings, "farms");
				deleteElement(usr.available_buildings, "centralised_farms");
			}
		},
		limited_access_roads: {
			icon: "<:old_map:716821884867444746>",
			description: "Limited-access roads, or dual carriageways, are motorways that restrict access of certain parts of the road to certain vehicles in hope of reducing traffic congestion and gridlock.",
			prerequisite_techs: ["advanced_farming_machinery","wartime_industry"],
			research_cost: 7000,
			category: "economic_technology",
			modifiers: [
				"**+5%** Army Travel Speed"
			],
			unlocks: function (usr) {
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed - 0.05;
			}
		},
		offshore_drilling: {
			icon: "<:petroil:716791408748658739>",
			description: "Although not possible until recently, the discovery of several pockets of petroleum underneath the seas has led to the intriguing possibility of drilling offshore, which would be supported by petroil rigs, increasing our self-sustainability when it comes to supplying our nation with the petroil it runs on.",
			prerequisite_techs: ["deep_mining"],
			research_cost: 7000,
			category: "economic_technology",
			modifiers: [
				"**+1** Refineries per city"
			],
			unlocks: function (usr) {
				usr.modifiers.refineries = usr.modifiers.refineries + 1;
			}
		},
		securities: {
			icon: "<:money:716817688718213192>",
			description: "Securities are tradeable financial assets, typically bundled as either loans, derivatives, or normal stocks for investors to buy and sell as they please. They became infamous during the Great Recession as 'toxic assets', which referred to homeowner loans, which the homeowner stood almost no chance of paying back after the real estate bubble.",
			prerequisite_techs: ["mutual_funds"],
			research_cost: 7000,
			category: "economic_technology",
			modifiers: [
				"**+3%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.03;
			}
		},
		linear_programming: {
			icon: "<:taxes:716817688781127810>",
			description: "Linear programming is a field of mathematics used for planning and optimisation. It rapidly became a part of computer science, and its usage is now critical in several fields of study.",
			prerequisite_techs: ["divergent_economic_thought"],
			research_cost: 7000,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
			}
		},
		intensive_agriculture: {
			icon: "<:food:716797746715033602>",
			description: "The systematic optimisation of agriculture, with the usage of pesticides and herbicides in an attempt to maximise crop yield, is referred to as intensive agriculture, and is the main supplier of modern supermarkets and food supply chains.",
			prerequisite_techs: ["industrial_farming"],
			research_cost: 7000,
			category: "economic_technology",
			modifiers: [
				"**+2** Industrial Farms per city"
			],
			unlocks: function (usr) {
				usr.modifiers.industrial_farms = usr.modifiers.industrial_farms + 2;
			}
		},
		integrated_motorways: {
			icon: "<:steel:716791408828088420>",
			description: "The construction of an integrated motorway system underneath our government will help decrease transport time and increase our mobilisation capacity should war ever call for it. Logistics and shipments will also become easier to handle, leading to a boon for our economy.",
			prerequisite_techs: ["limited_access_roads"],
			research_cost: 7000,
			category: "economic_technology",
			modifiers: [
				"**+5%** Army Travel Speed"
			],
			unlocks: function (usr) {
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed - 0.05;
			}
		},
		modern_inflation_theory: {
			icon: "<:money:716817688718213192>",
			description: "Although inflation may have always been thought as bad during the era of classical economics, it turns out that there is an ideal rate of inflation that will drive up consumer spending, and ease the worry of investors. What this rate is remains up for debate, but it should be up to our Treasury to keep it relatively low.",
			prerequisite_techs: ["securities"],
			research_cost: 7000,
			category: "economic_technology",
			modifiers: [
				"**+5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
			}
		},
		microeconomics: {
			icon: "<:old_scroll:716828676880334881>",
			description: "Microeconomics is the study of price, supply and demand fluctuations at the level of an individual product, good, service, or even household. By analysing the behaviour of end consumers, we can get a better picture of how our economy should be directed.",
			prerequisite_techs: ["linear_programming"],
			research_cost: 7000,
			category: "economic_technology",
			modifiers: [
				"**+2%** Production Efficiency",
				"**+3%** Research Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.02;
				usr.modifiers.research_efficiency = usr.modifiers.research_efficiency + 0.03;
			}
		},
		industrial_complexes: {
			icon: "<:factory:759161240601493525>",
			description: "Sprawling, gritty areas perpetually spewing out smoke, industrial complexes are the modern manufactories of our nation, keeping us strong in war, and rich in peace.",
			prerequisite_techs: ["integrated_motorways"],
			research_cost: 8000,
			category: "economic_technology",
			modifiers: [
				"Enables **Industrial Complexes**",
				"Obsoletes **Assembly Plants**",
				"Obsoletes **Arsenals**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("industrial_complexes");
				deleteElement(usr.available_buildings, "assembly_plants");
				deleteElement(usr.available_buildings, "arsenals");
			}
		},
		boring_machines: {
			icon: "<:steel:716791408828088420>",
			description: "Boring machines or TBMs are used to help drill tunnels rapidly in areas where the rock hardness does not allow for manual excavation, or sectors where drilling needs to be exacted with precision.",
			prerequisite_techs: ["integrated_motorways"],
			research_cost: 8000,
			category: "economic_technology",
			modifiers: [
				"**+1** Coal Mine per city",
				"**+1** Iron Mine per city",
				"**+1** Lead Mine per city",
				"**+1** Quarry per city"
			],
			unlocks: function (usr) {
				usr.modifiers.coal_mines = usr.modifiers.coal_mines + 1;
				usr.modifiers.iron_mines = usr.modifiers.iron_mines + 1;
				usr.modifiers.lead_mines = usr.modifiers.lead_mines + 1;
				usr.modifiers.quarries = usr.modifiers.quarries + 1;
			}
		},
		bretton_woods: {
			icon: "<:money:716817688718213192>",
			description: "Bretton Woods was an international agreement tying the world's currencies to the U.S. dollar, helping to stabilise exchange rates, and allowing for a lingua franca of currencies by revolutionising finance.",
			prerequisite_techs: ["modern_inflation_theory"],
			research_cost: 8000,
			category: "economic_technology",
			modifiers: [
				"**+5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
			}
		},
		neo_keynesianism: {
			icon: "<:old_scroll:716828676880334881>",
			description: "Although Keynesianism initially had only accounted for macroeconomics, neo-Keynesianism seeks to combine the reasoning of microeconomics and macroeconomics into a single economic school of thought. They were eventually superseded by New Keynesianism.",
			prerequisite_techs: ["microeconomics"],
			research_cost: 8000,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
			}
		},
		green_revolution: {
			icon: "<:food:716797746715033602>",
			description: "The Green Revolution was the rapid improvement of technology in agriculture, rendering the fears of overpopulation obsolete. It utilised selective breeding to create a system of improved crop yields and agricultural outputs, especially in emerging economies with high population growth rates.",
			prerequisite_techs: ["intensive_agriculture"],
			research_cost: 8500,
			category: "economic_technology",
			modifiers: [
				"**+3** Industrial Farms per city"
			],
			unlocks: function (usr) {
				usr.modifiers.industrial_farms = usr.modifiers.industrial_farms + 3;
			}
		},
		high_speed_rail: {
			icon: "<:steel:716791408828088420>",
			description: "High-speed rail, using specialised rolling stock, integrated and straightened tracks, and power cables have enabled faster transport across our nation, reducing shipment times and increasing army transport speed.",
			prerequisite_techs: ["industrial_complexes"],
			research_cost: 8500,
			category: "economic_technology",
			modifiers: [
				"**+5%** Army Travel Speed"
			],
			unlocks: function (usr) {
				usr.modifiers.army_travel_speed = usr.modifiers.army_travel_speed - 0.05;
			}
		},
		abandonment_of_the_gold_standard: {
			icon: "<:gold:716798541028261927>",
			description: "By abandoning the gold standard and switching to a fiat currency, we can reduce the amount of inflation present in the policy as the worth of the currency will be tied solely to the amount of trust investors hold in our nation.",
			prerequisite_techs: ["bretton_woods"],
			research_cost: 8500,
			category: "economic_technology",
			modifiers: [
				"**-10%** Army Upkeep",
				"**-5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.10;
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency - 0.05;
			}
		},
		globalisation: {
			icon: "<:globe:716811246556545035>",
			description: "The globalisation of trade will play a key role in the logistical supply lines used to manufacture and ship goods on a global scale, with the end result being the consumer paying a lower price for their product, despite pushback over job losses, especially in more developed economies.",
			prerequisite_techs: ["neo_keynesianism"],
			research_cost: 8500,
			category: "economic_technology",
			modifiers: [
				"**+5%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.05;
			}
		},
		advanced_pesticides: {
			icon: "<:food:716797746715033602>",
			description: "Pesticides, although recognised as being harmful for the environment, will also help get rid of pests and parasites that plague our crops, ending the devastating havoc that they wreak upon our agricultural output.",
			prerequisite_techs: ["green_revolution"],
			research_cost: 9000,
			category: "economic_technology",
			modifiers: [
				"**+2%** Population Growth Rate",
				"**+1** Industrial Farms per city",
				"Obsoletes **Farms**"
			],
			unlocks: function (usr) {
				usr.pop_growth_modifier = usr.pop_growth_modifier + 0.02;
				usr.modifiers.industrial_farms = usr.modifiers.industrial_farms + 1;
				deleteElement(usr.available_buildings, "farms");
			}
		},
		modern_urban_transport: {
			icon: "<:development:716811992421367869>",
			description: "By improving inter-city rail links, undergrounds, and avenues, we can improve commute time, leading to greater production efficiency within our urban centres.",
			prerequisite_techs: ["high_speed_rail"],
			research_cost: 9000,
			category: "economic_technology",
			modifiers: [
				"**-3%** Shipment Time"
			],
			unlocks: function (usr) {
				usr.modifiers.shipment_time = usr.modifiers.shipment_time - 0.03;
			}
		},
		contemporary_mining: {
			icon: "<:government:716817688693047306>",
			description: "Contemporary mining is a system by which modern methods of resource extraction are used, including the usage of modern prospection techniques and computerised models of drilling and extraction.",
			prerequisite_techs: ["boring_machines"],
			research_cost: 9000,
			category: "economic_technology",
			modifiers: [
				"**+2** Coal Mines per city",
				"**+2** Iron Mines per city",
				"**+2** Lead Mines per city",
				"**+2** Gold Mines per city",
				"**+2** Quarries per city"
			],
			unlocks: function (usr) {
				usr.modifiers.coal_mines = usr.modifiers.coal_mines + 2;
				usr.modifiers.iron_mines = usr.modifiers.iron_mines + 2;
				usr.modifiers.lead_mines = usr.modifiers.lead_mines + 2;
				usr.modifiers.gold_mines = usr.modifiers.gold_mines + 2;
				usr.modifiers.quarries = usr.modifiers.quarries + 2;
			}
		},
		automated_stock_trading: {
			icon: "<:development:716811992421367869>",
			description: "Beginning in the early 80s, it became more and more common for stock firms to introduce algorithmic trading in order to boost reaction time and reduce investment risk. The practice, although not without its own risks as evidenced by flash crashes, continues to this day.",
			prerequisite_techs: ["abandonment_of_the_gold_standard"],
			research_cost: 9000,
			category: "economic_technology",
			modifiers: [
				"**+5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
			}
		},
		emerging_economic_theory: {
			icon: "<:technology:716812861514711040>",
			description: "New modes of economic thinking are beginning to challenge the economic establishment, leading to new policy intiatives and greater flexibility in deciding political directives.",
			prerequisite_techs: ["globalisation"],
			research_cost: 9000,
			category: "economic_technology",
			modifiers: [
				"**+2%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.02;
			}
		},
		gmo_crops: {
			icon: "<:food:716797746715033602>",
			description: "GMO crops will help improve resistance to blights and parasites, and will in some cases, completely get rid of them, whilst at the same time being capable of growing in more sturdy climes, allowing us to de facto expand the reach of our arable land.",
			prerequisite_techs: ["advanced_pesticides"],
			research_cost: 9500,
			category: "economic_technology",
			modifiers: [
				"**+1%** Population Growth Rate"
			],
			unlocks: function (usr) {
				usr.pop_growth_modifier = usr.pop_growth_modifier + 0.01;
			}
		},
		production_facilities: {
			icon: "<:factory:759161240601493525>",
			description: "Production facilities are typically used to refer to consumer goods factories that produce and distribute market goods of a civilian nature.",
			prerequisite_techs: ["modern_urban_transport"],
			research_cost: 9500,
			category: "economic_technology",
			modifiers: [
				"Enable **Production Facilities**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("production_facilities");
			}
		},
		liquefied_natural_gas: {
			icon: "<:petroil:716791408748658739>",
			description: "Natural gas, whilst not entirely friendly to the environment, will be seen as a step in improving the amount of emissions we produce whilst also at the same time boosting our energy efficiency. Although more expensive than petrol, it also holds the promise of being more reliable and being more capable to diversify our sources of energy.",
			prerequisite_techs: ["contemporary_mining"],
			research_cost: 9500,
			category: "economic_technology",
			modifiers: [
				"**+1** Refineries per city"
			],
			unlocks: function (usr) {
				usr.modifiers.refineries = usr.modifiers.refineries + 1;
			}
		},
		governmental_fiscal_stimulus: {
			icon: "<:money:716817688718213192>",
			description: "In times of recession, it becomes imperative that the government directly inject fiscal stimulus into the economy so as to boost consumer spending, and thereby revive the economy. Although critics believe it to be an overextension of the government, it can give us more leverage as a state to determine how the economy can be brought back to life during times of crisis.",
			prerequisite_techs: ["contemporary_mining"],
			research_cost: 9500,
			category: "economic_technology",
			modifiers: [
				"**-2%** Reform Desire Gain",
				"**-10%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.reform_desire_gain = usr.modifiers.reform_desire_gain - 0.02;
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency - 0.10;
			}
		},
		keynesian_resurgence: {
			icon: "<:trade:716828677115084812>",
			description: "In the wake of the Great Recession, economists from across the world have gathered to hammer out new policy initiatives, many of which centred around a Keynesian mode of thought, giving rise to the term 'Keynesian Resurgence'.",
			prerequisite_techs: ["emerging_economic_theory"],
			research_cost: 9500,
			category: "economic_technology",
			modifiers: [
				"**+3%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.03;
			}
		},
		new_green_revolution: {
			icon: "<:food:716797746715033602>",
			description: "Although advances in farming have been made, the practice is still seen as being unsustainable going forwards. By contributing research towards a New Green Revolution, we can ensure that better quality food is produced than the food spewed forth from the industrial farms that we currently hold.",
			prerequisite_techs: ["gmo_crops"],
			research_cost: 10000,
			category: "economic_technology",
			modifiers: [
				"**+5%** Population Growth Rate"
			],
			unlocks: function (usr) {
				usr.pop_growth_modifier = usr.pop_growth_modifier + 0.05;
			}
		},
		hydraulic_fracturing: {
			icon: "<:petroil:716791408748658739>",
			description: "Fracking, also known as hydraulic fracturing is a method that combined horizontal drilling and the dispersal of fracking fluid into the surroundings to loosen up pockets of petroil and drive them into a central pipeline, where it can then be extracted, allowing for improved petroil extraction techniques, despite its groundwater pollution risk.",
			prerequisite_techs: ["liquefied_natural_gas"],
			research_cost: 10000,
			category: "economic_technology",
			modifiers: [
				"**+1** Refineries per city"
			],
			unlocks: function (usr) {
				usr.modifiers.refineries = usr.modifiers.refineries + 1;
			}
		},
		austerity_controversy: {
			icon: "<:taxes:716817688781127810>",
			description: "The controversy of austerity, though it has been around for a while, was revived during the Great Recession after many countries witnessed unpopular bailouts which came with the terms of austerity. Deeply unpopular amongst their citizens, it led to significant civil unrest among their populations, and is today recognised as a failure internationally. A better replacement, however, has yet to be seen.",
			prerequisite_techs: ["liquefied_natural_gas"],
			research_cost: 10000,
			category: "economic_technology",
			modifiers: [
				"**+3%** Production Efficiency",
				"**+3%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency + 0.03;
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.03;
			}
		},
		improved_crop_yields: {
			icon: "<:food:716797746715033602>",
			description: "Innovation in farming technology allows for higher yield and more efficient usage of farmland. This would allow for a higher population being sustained.",
			prerequisite_techs: ["new_green_revolution"],
			research_cost: 10500,
			category: "economic_technology",
			modifiers: [
				"**+1** Industrial Farms per city"
			],
			unlocks: function (usr) {
				usr.modifiers.industrial_farms = usr.modifiers.industrial_farms + 1;
			}
		},
		modern_financial_centres: {
			icon: "<:taxes:716817688781127810>",
			description: "Modern financial centres are locations with a high concentration of participants in banking, asset management, insurance or financial markets with venues and supporting services for those activities to take place.",
			prerequisite_techs: ["production_facilities"],
			research_cost: 10500,
			category: "economic_technology",
			modifiers: [
				"Enables **Modern Financial Centres**",
				"**+1** Production Facilities per city"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("modern_financial_centres");
				usr.modifiers.production_facilities = usr.modifiers.production_facilities + 1;
			}
		},
		landfill_mining_and_recycling: {
			icon: "<:trade:716828677115084812>",
			description: "Landfill mining and recycling is a process which excavates and processes solid wastes which have previously been landfilled. In the process, mining recovers valuable recyclable materials, a combustible fraction, soil and landfill space.",
			prerequisite_techs: ["hydraulic_fracturing"],
			research_cost: 10500,
			category: "economic_technology",
			modifiers: [
				"**+1** Extra Building Slots"
			],
			unlocks: function (usr) {
				usr.modifiers.extra_building_slots = usr.modifiers.extra_building_slots + 1;
			}
		},
		ai_fund_management: {
			icon: "<:money:716817688718213192>",
			description: "With artificial intelligence responsible for Fund Management, developing, operating, maintaining, upgrading and disposing assets will all be conducted with little human intervention.",
			prerequisite_techs: ["governmental_fiscal_stimulus"],
			research_cost: 10500,
			category: "economic_technology",
			modifiers: [
				"**+5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
			}
		},
		regulated_capitalism: {
			icon: "<:old_scroll:716828676880334881>",
			description: "Regulated Capitalism serves as an alternative to other forms of capitalism in order to shed more light on capitalism as a polymorphous order. It suggests that the operation maintenance and development of the international political economy increasingly depends on administrative rules outside the legislatures and the courts.",
			prerequisite_techs: ["austerity_controversy"],
			research_cost: 10500,
			category: "economic_technology",
			modifiers: [
				"**+2** Political Capital Gain",
				"**-5%** Production Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.political_capital_gain = usr.modifiers.political_capital_gain + 2;
				usr.modifiers.production_efficiency = usr.modifiers.production_efficiency - 0.05;
			}
		},
		vertical_farming: {
			icon: "<:steel:716791408828088420>",
			description: "Vertical farming is the practice of growing crops in vertically stacked layers. It often incorporates controlled-environment agriculture, which aims to optimise plant growth, and soilless farming techniques such as hydroponics, aquaponics, and aeroponics.",
			prerequisite_techs: ["improved_crop_yields"],
			research_cost: 11000,
			category: "economic_technology",
			modifiers: [
				"Enables **Vertical Farms**",
				"**+3** Vertical Farms per city",
				"**-8%** Population Growth Rate"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("vertical_farms");
				usr.modifiers.vertical_farms = usr.modifiers.vertical_farms + 3;
				usr.pop_growth_modifier = usr.pop_growth_modifier - 0.08;
			}
		},
		ai_hubs: {
			icon: "<:government:716817688693047306>",
			description: "The consequences of the Industrial Revolution have been a disaster for the human race. They have finally reached their final form. Welcome to the endgame.",
			prerequisite_techs: ["modern_financial_centres"],
			research_cost: 11000,
			category: "economic_technology",
			modifiers: [
				"Enables **AI Hubs**",
				"**+1** AI Hubs per city",
				"**+2** Production Facilities per city"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("ai_hubs");
				usr.modifiers.ai_hubs = usr.modifiers.ai_hubs + 1;
				usr.modifiers.production_facilities = usr.modifiers.production_facilities + 2;
			}
		},
		automated_mining: {
			icon: "<:coal:716791408714973204>",
			description: "Automated mining involves the removal of human labour from the mining process. It can still require a large amount of human capital. There are two types of automated mining, process and software automation, and the application of robotic technology to mining vehicles and equipment.",
			prerequisite_techs: ["landfill_mining_and_recycling"],
			research_cost: 11000,
			category: "economic_technology",
			modifiers: [
				"**+2** Extra Building Slots"
			],
			unlocks: function (usr) {
				usr.modifiers.extra_building_slots = usr.modifiers.extra_building_slots + 2;
			}
		},
		contemporaneous_economic_thought: {
			icon: "<:technology:716812861514711040>",
			description: "The current state of economic thought covers a diverse range of policy initiatives and sub-movements, all of which claim to provide optimised mandates for our government. By running each of them through detailed economic simulations, we can sort out which ones will work for the economy, and which ones will not.",
			prerequisite_techs: ["regulated_capitalism"],
			research_cost: 11000,
			category: "economic_technology",
			modifiers: [
				"**+5%** Research Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.research_efficiency = usr.modifiers.research_efficiency + 0.05;
			}
		},
		early_colonial_administration: {
			icon: "<:paper:759161240987369522>",
			description: "Early colonial administration was typically managed by those deemed capable of managing the colony and easing it into a state of survival. Although not ideal for long-term growth, they were instrumental in growing colonies initially.",
			research_cost: 20,
			category: "administrative_technology",
			modifiers: [
				"**+1** Maximum Expeditions"
			],
			unlocks: function (usr) {
				usr.modifiers.maximum_expeditions = usr.modifiers.maximum_expeditions + 1;
			}
		},
		the_courthouse: {
			icon: "<:political_capital:716817688525275257>",
			description: "The courthouse, used to provide rule of law for the common citizenry, is imperative to maintain a semblance of public order in any nation, and will go a long way in cementing our legitimacy over the people as a government.",
			prerequisite_techs: ["early_colonial_administration"],
			research_cost: 50,
			category: "administrative_technology",
			modifiers: [
				"**+5%** Stability"
			],
			unlocks: function (usr) {
				usr.stability = usr.stability + 5;
			}
		},
		cartography: {
			icon: "<:old_map:716821884867444746>",
			description: "The art of map-making is beginning to diverge into a science as cartographic maps are used increasingly for navigation and administration, and the maps it produces are even used to wage battles.",
			prerequisite_techs: ["early_colonial_administration"],
			research_cost: 50,
			category: "administrative_technology",
			modifiers: [
				"**-5%** Colonist Travel Time"
			],
			unlocks: function (usr) {
				usr.modifiers.colonist_travel_speed = usr.modifiers.colonist_travel_speed - 0.05;
			}
		},
		universities: {
			icon: "<:knowledge:716797747193446441>",
			description: "Central locations of learning and beacons of knowledge, universities help guide our country into the future as youth from all over our nation will come to these places to study and further develop emerging fields of research.",
			prerequisite_techs: ["the_courthouse"],
			research_cost: 75,
			category: "administrative_technology",
			modifiers: [
				"Enables **Universities**"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("universities");
			}
		},
		colonial_charters: {
			icon: "<:old_map:716821884867444746>",
			description: "Originally given out as grants of land for colonies, overtime they evolved into having their own separate administration, typically with high degrees of autonomy from their mother country as more and more settlers came to settle in these charters.",
			prerequisite_techs: ["cartography"],
			research_cost: 75,
			category: "administrative_technology",
			modifiers: [
				"**+1** Maximum Expeditions"
			],
			unlocks: function (usr) {
				usr.modifiers.maximum_expeditions = usr.modifiers.maximum_expeditions + 1;
			}
		},
		early_modern_bureaucracy: {
			icon: "<:government:716817688693047306>",
			description: "By switching our system of government from one that merely follows the whims of various aristocrats to one that works on a merit-based system, we can begin to enforce an early modern bureaucracy in which all valid candidates are considered of equal worth.",
			prerequisite_techs: ["universities","colonial_charters"],
			research_cost: 100,
			category: "administrative_technology",
			modifiers: [
				"**-5%** Building Cost",
				"Unlocks **Bureaucracy** Reforms"
			],
			unlocks: function (usr) {
				usr.modifiers.building_cost = usr.modifiers.building_cost - 0.05;
				unlockReform(usr.id, "bureaucracy");
			}
		},
		standardisation_of_units: {
			icon: "<:stability:716817688722407424>",
			description: "The standardisation of units will help improve governmental efficiency and reduce cheating on the local level, as peasants and serfs will now be aware of what level of tax they have to pay, and whether or not their lord is cheating them by skimming some off the top, or by raising their taxes, leading to excess burdens.",
			prerequisite_techs: ["early_modern_bureaucracy"],
			research_cost: 150,
			category: "administrative_technology",
			modifiers: [
				"**-5%** Building Cost",
				"**+5%** Administrative Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.building_cost = usr.modifiers.building_cost - 0.05;
				usr.modifiers.administrative_efficiency = usr.modifiers.administrative_efficiency + 0.05;
			}
		},
		corvee: {
			icon: "<:taxes:716817688781127810>",
			description: "The corvee was a labour tax instituted in France, as well as several other European nations for the express purpose of building up infrastructure, typically for the benefit of the military, although it could also serve other purposes.",
			prerequisite_techs: ["early_modern_bureaucracy"],
			research_cost: 150,
			category: "administrative_technology",
			modifiers: [
				"**+5%** National Manpower"
			],
			unlocks: function (usr) {
				usr.modifiers.national_manpower = usr.modifiers.national_manpower + 0.05;
			}
		},
		religious_tolerance: {
			icon: "<:old_scroll:716828676880334881>",
			description: "The increase of religious tolerance in our country could help lead to a defusing of tensions between divergent sects of our faith, and reduce civil violence.",
			prerequisite_techs: ["early_modern_bureaucracy"],
			research_cost: 150,
			category: "administrative_technology",
			modifiers: [
				"**+5%** Stability"
			],
			unlocks: function (usr) {
				usr.stability = usr.stability + 5;
			}
		},
		centralisation: {
			icon: "<:provinces:716809229603700737>",
			description: "Although our state and the central government has long been swayed underneath the power and influence of the various nobles and vassals that comprise our country, through organised systems of placation, we can slowly whittle away their power peacefully, cementing a modern government capable of delegating duties.",
			prerequisite_techs: ["standardisation_of_units"],
			research_cost: 200,
			category: "administrative_technology",
			modifiers: [
				"Enables **Centralisation** Mechanics"
			],
			unlocks: function (usr) {
				usr.enabled_mechanics.push("centralisation");
			}
		},
		tax_oversight: {
			icon: "<:taxes:716817688781127810>",
			description: "By overseeing the nobles who are conducting our taxes, we can reduce the burden on the peasants, but also fill up our state coffers rather nicely in the process. Of course they won't be happy, but that's their lot.",
			prerequisite_techs: ["corvee"],
			research_cost: 200,
			category: "administrative_technology",
			modifiers: [
				"**+3%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.03;
			}
		},
		diplomatic_code: {
			icon: "<:faculty:732730754911436830>",
			description: "As thoughts of modernity and civilised expectations begin to sweep around the world, it seems only fair that we should codify our protection of diplomats to promote bilateral relations between us and other countries.",
			prerequisite_techs: ["religious_tolerance"],
			research_cost: 200,
			category: "administrative_technology",
			modifiers: [
				"**+1** Diplomatic Slots"
			],
			unlocks: function (usr) {
				usr.modifiers.starting_diplomatic_slots = usr.modifiers.starting_diplomatic_slots + 1;
			}
		},
		absolutism: {
			icon: "<:government_scroll:716828975175041054>",
			description: "Although viewed by many as the simple rule of a petty tyrant, absolutism will help increase the unity of our state, eventually leading to a situation in which the authority of nobles will be greatly devolved.",
			prerequisite_techs: ["religious_tolerance"],
			research_cost: 250,
			category: "administrative_technology",
			modifiers: [
				"**+2%** Ruling Party Support Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.ruling_party_support = usr.modifiers.ruling_party_support + 2;
			}
		},
		code_of_laws: {
			icon: "<:old_scroll:716828676880334881>",
			description: "By codifying our entire set of laws, we can make it clear to the people what we expect of them and their behaviour, and what practices to avoid, increasing social and national stability. Anything not found in the law is not law at all.",
			prerequisite_techs: ["religious_tolerance"],
			research_cost: 250,
			category: "administrative_technology",
			modifiers: [
				"Unlocks **Penal System** Reforms"
			],
			unlocks: function (usr) {
				unlockReform(usr.id, "penal_system");
			}
		},
		laws_of_war: {
			icon: "<:cb:716828676855169107>",
			description: "By setting some standards for the treatment of enemy belligerents during wartime, we can ensure that our own soldiers are treated, if not well, then at least acceptably.",
			prerequisite_techs: ["religious_tolerance"],
			research_cost: 250,
			category: "administrative_technology",
			modifiers: [
				"**+1** Diplomatic Slots"
			],
			unlocks: function (usr) {
				usr.modifiers.starting_diplomatic_slots = usr.modifiers.starting_diplomatic_slots + 1;
			}
		},
		modern_theocracy: {
			icon: "<:infamy:716817688453709905>",
			description: "The organisation of a modern theocracy, though challenging, would help in assisting our nation's souls into their afterlife, and would lend us great power over the everyday lives of the average citizen.",
			prerequisite_techs: ["absolutism"],
			research_cost: 350,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions."
			],
			unlocks: function (usr) {
				usr.modifiers.ruling_party_support = usr.modifiers.ruling_party_support + 2;
			}
		},
		constitutionalism: {
			icon: "<:paper:759161240987369522>",
			description: "The code of laws can be taken a step further into a constitution, severely restricting the power of the king, and opening up new voting rights for the landed gentry and aristocrats that make up this nation. Although the peasants and middle-class in our country may be upset at their own lack of representation ...",
			prerequisite_techs: ["code_of_laws"],
			research_cost: 350,
			category: "administrative_technology",
			modifiers: [
				"**-1%** Reform Desire Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.reform_desire_gain = usr.modifiers.reform_desire_gain - 0.01;
			}
		},
		the_nation_state: {
			icon: "<:globe:716811246556545035>",
			description: "The modern nation state is a government capable of exercising authority over its demarcated territories whilst at the same time providing services for its people. It is the modern concept of a nation as we know it.",
			prerequisite_techs: ["absolutism","constitutionalism"],
			research_cost: 500,
			category: "administrative_technology",
			modifiers: [
				"**+5%** Stability",
				"**+20** Prestige",
				"**+3** Political Capital Gain"
			],
			unlocks: function (usr) {
				usr.stability = usr.stability + 5;
				usr.prestige = usr.prestige + 20;
				usr.modifiers.political_capital_gain = usr.modifiers.political_capital_gain + 3;
			}
		},
		parliament: {
			icon: "<:political_capital:716817688525275257>",
			description: "A legislative body in charge of passing the laws of the land, the concept of a Parliament, even if not instituted, will at least give our citizens the hope that they will be represented someday.",
			prerequisite_techs: ["absolutism","constitutionalism"],
			research_cost: 500,
			category: "administrative_technology",
			modifiers: [
				"Unlocks **Upper House** Reforms"
			],
			unlocks: function (usr) {
				unlockReform(usr.id, "upper_house");
			}
		},
		military_oversight: {
			icon: "<:manpower:716817688705499177>",
			description: "Oversight of the military will help reduce the rampant corruption prevalent in our armed forces, and help transform our nation's army into a modern, professional fighting force.",
			prerequisite_techs: ["the_nation_state"],
			research_cost: 650,
			category: "administrative_technology",
			modifiers: [
				"**-5%** Upkeep Cost",
				"**+5%** Colonial Power Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.05;
				usr.modifiers.colonial_power_gain = usr.modifiers.colonial_power_gain + 0.05;
			}
		},
		enlightened_absolutism: {
			icon: "<:government_scroll:716828975175041054>",
			description: "By promising to bring about the reforms of the Enlightenment whilst maintaining an autocracy, we can placate some of the more reform-minded subjects amongst our population, and be seen as a forwards-looking ruler. At least for our time.",
			prerequisite_techs: ["the_nation_state"],
			research_cost: 650,
			category: "administrative_technology",
			modifiers: [
				"Unlocks **Slavery** Reforms",
				"**+1%** Constitutional Monarchy Popularity Gain"
			],
			unlocks: function (usr) {
				unlockReform(usr.id, "slavery");
				usr.modifiers.constitutional_monarchy = usr.modifiers.constitutional_monarchy + 1;
			}
		},
		diplomatic_order: {
			icon: "<:faculty:732730754911436830>",
			description: "As the diplomatic order, at least in the civilised world as we know it, continues to evolve, we should seek to keep our code up to date, and develop the concept of diplomatic immunity further, as well as the recognition of treaties as contractual obligations between nations.",
			prerequisite_techs: ["laws_of_war"],
			research_cost: 650,
			category: "administrative_technology",
			modifiers: [
				"**+1** Diplomatic Slots"
			],
			unlocks: function (usr) {
				usr.modifiers.starting_diplomatic_slots = usr.modifiers.starting_diplomatic_slots + 1;
			}
		},
		colonialism: {
			icon: "<:soldiers:732730754592669702>",
			description: "The doctrine of expansion for centuries, colonialism often meant acquiring land outside one's own continent and bringing it into their own fold in order to extract more resources and to establish ports in strategic locations for further expansion.",
			prerequisite_techs: ["military_oversight"],
			research_cost: 750,
			category: "administrative_technology",
			modifiers: [
				"Enables **Settlers**",
				"**+1** Maximum Expeditions",
				"Obsoletes **Conquistadors**"
			],
			unlocks: function (usr) {
				usr.modifiers.maximum_expeditions = usr.modifiers.maximum_expeditions + 1;
				usr.available_units.push("settlers");
				deleteElement(usr.available_units, "conquistadors", [usr, "obsolete_units"]);
			}
		},
		national_sovereignty: {
			icon: "<:provinces:716809229603700737>",
			description: "Concepts around the national sovereignty of nations and the right to control and determine their own destiny are starting to become more firmly entrenched in the minds of the leaders of many of the world's nations, and as such, we should be careful to 'respect' it as best we can.",
			prerequisite_techs: ["enlightened_absolutism"],
			research_cost: 750,
			category: "administrative_technology",
			modifiers: [
				"**+5%** Centralisation"
			],
			unlocks: function (usr) {
				usr.modifiers.centralisation = usr.modifiers.centralisation + 0.05;
			}
		},
		landed_gentry: {
			icon: "<:faculty:732730754911436830>",
			description: "In a constitutional monarchy, the landed gentry or those of the wealthy and the aristocracy were among the first to gain access to the vote, leading to further restrictions on the powers of the monarch and further opportunities to pass new legislation.",
			prerequisite_techs: ["parliament"],
			research_cost: 750,
			category: "administrative_technology",
			modifiers: [
				"Unlocks **Voting System** Reforms"
			],
			unlocks: function (usr) {
				unlockReform(usr.id, "voting_system");
			}
		},
		balance_of_power: {
			icon: "<:stability:716817688722407424>",
			description: "As nations are inevitably concerned about their own self-interest and how far they can advance their own priorities, it becomes important to maintain a balance of power in the region in order to ensure that a single power bloc is not capable of dominating the entire landscape.",
			prerequisite_techs: ["diplomatic_order"],
			research_cost: 750,
			category: "administrative_technology",
			modifiers: [
				"**-5%** Stability"
			],
			unlocks: function (usr) {
				usr.stability = usr.stability - 5;
			}
		},
		colonial_bureaucracy: {
			icon: "<:globe:716811246556545035>",
			description: "By creating more organised systems for our colonies, we can help to provide more effective governance than ever before, increasing our colonial capacity and allowing for more settlers to emigrate overseas.",
			prerequisite_techs: ["colonialism"],
			research_cost: 900,
			category: "administrative_technology",
			modifiers: [
				"**+1** Maximum Expeditions"
			],
			unlocks: function (usr) {
				usr.modifiers.maximum_expeditions = usr.modifiers.maximum_expeditions + 1;
			}
		},
		organised_postage: {
			icon: "<:trade:716828677115084812>",
			description: "The postal system of a country is arguably as important as the roads themselves. The improvement of lines of communication across our nation and empire become increasingly important as they are the conduits upon which our merchants and bureaucracy depend.",
			prerequisite_techs: ["national_sovereignty"],
			research_cost: 900,
			category: "administrative_technology",
			modifiers: [
				"**+50** Shipment Capacity"
			],
			unlocks: function (usr) {
				usr.modifiers.shipment_capacity = usr.modifiers.shipment_capacity + 50;
			}
		},
		great_power_status: {
			icon: "<:prestige:762428452636721202>",
			description: "By emphasising the qualities of power projection, we can achieve great power status as we subtly influence other nations into doing what we want them to do.",
			prerequisite_techs: ["balance_of_power"],
			research_cost: 900,
			category: "administrative_technology",
			modifiers: [
				"**+5** Prestige Gain",
				"**-5%** Army Upkeep"
			],
			unlocks: function (usr) {
				usr.modifiers.prestige_gain = usr.modifiers.prestige_gain + 5;
				usr.modifiers.army_upkeep = usr.modifiers.army_upkeep - 0.05;
			}
		},
		divide_and_conquer: {
			icon: "<:infamy:716817688453709905>",
			description: "Although imperial rule may not always be easy, we can pit the natives against each other in order to lessen the probability of short-term revolt at the risk of increasing long-term violence.",
			prerequisite_techs: ["colonial_bureaucracy"],
			research_cost: 1000,
			category: "administrative_technology",
			modifiers: [
				"**+1** Maximum Expeditions"
			],
			unlocks: function (usr) {
				usr.modifiers.maximum_expeditions = usr.modifiers.maximum_expeditions + 1;
			}
		},
		land_clearance: {
			icon: "<:provinces:716809229603700737>",
			description: "Mopping up several parcels of land into a single unified lot can improve efficiency and allow our businessmen greater opportunities when it comes to utilising our natural resources.",
			prerequisite_techs: ["land_clearance"],
			research_cost: 1000,
			category: "administrative_technology",
			modifiers: [
				"**+3%** Administrative Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.administrative_efficiency = usr.modifiers.administrative_efficiency + 0.03;
			}
		},
		political_thought_and_theory: {
			icon: "<:old_scroll:716828676880334881>",
			description: "As consciousness amongst our population begins to rise, and governments become more representative of the people, if not in truth, then at least in theory, political ideologies are beginning to adapt to the beliefs and cultures which they inhabit.",
			prerequisite_techs: ["landed_gentry"],
			research_cost: 1000,
			category: "administrative_technology",
			modifiers: [
				"**+2** Political Capital Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.political_capital_gain = usr.modifiers.political_capital_gain + 2;
			}
		},
		early_imperialism: {
			icon: "<:taxes:716817688781127810>",
			description: "Imperialism took colonialism to the next level by proclaiming a civilising mission across multiple continents in order to justify the subjugation of natives in the area. It later became used to refer to the influence colonial masters held over their 'protectorates' and client states.",
			prerequisite_techs: ["divide_and_conquer"],
			research_cost: 1200,
			category: "administrative_technology",
			modifiers: [
				"**+10%** Colonial Power Gain",
				"Enables **Colonists**",
				"Obsoletes **Settlers**"
			],
			unlocks: function (usr) {
				usr.modifiers.colonial_power_gain = usr.modifiers.colonial_power_gain + 0.10;
				usr.available_units.push("colonists");
				deleteElement(usr.available_units, "settlers", [usr, "obsolete_units"]);
			}
		},
		absolute_rulership: {
			icon: "<:government:716817688693047306>",
			description: "Sometimes the best government is one that has total authority over every aspect of life. At least that's what our leader thinks.",
			prerequisite_techs: ["land_clearance"],
			research_cost: 1200,
			category: "administrative_technology",
			modifiers: [
				"**+5%** Centralisation"
			],
			unlocks: function (usr) {
				usr.modifiers.centralisation = usr.modifiers.centralisation + 0.05;
			}
		},
		political_standardisation: {
			icon: "<:old_scroll:716828676880334881>",
			description: "The varying aspects of all the political ideologies that were borne forth out of the great revolutions are finally beginning to coalesce into standard ideologies, of which certain tenets are shared between people of different political beliefs.",
			prerequisite_techs: ["political_thought_and_theory"],
			research_cost: 1200,
			category: "administrative_technology",
			modifiers: [
				"**+1%** Ruling Party Support Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.ruling_party_support = usr.modifiers.ruling_party_support + 1;
			}
		},
		coalitionism: {
			icon: "<:old_map:716821884867444746>",
			description: "Minority governments, now that they are elected in certain parliamentary democracies, have the duty to form a coalition in order to gain a majority in Parliament, such that they will be capable of passing laws and enacting reforms in an equitable manner for the general public.",
			prerequisite_techs: ["great_power_status"],
			research_cost: 1200,
			category: "administrative_technology",
			modifiers: [
				"**+1%** Diplomatic Slots"
			],
			unlocks: function (usr) {
				usr.modifiers.starting_diplomatic_slots = usr.modifiers.starting_diplomatic_slots + 1;
			}
		},
		logical_units: {
			icon: "<:stability:716817688722407424>",
			description: "Despite the standardisation of our units having already occurred, certain scientists believe that measures should correspond to natural constants, as they believe that these measurements would be more 'logical' and 'natural'. Whether or not we adopt these policy changes, however, is up to us.",
			prerequisite_techs: ["absolute_rulership"],
			research_cost: 1400,
			category: "administrative_technology",
			modifiers: [
				"Enables **Research Labs**",
				"**+5%** Centralisation"
			],
			unlocks: function (usr) {
				usr.available_buildings.push("research_labs");
				usr.modifiers.centralisation = usr.modifiers.centralisation + 0.05;
			}
		},
		the_constitution: {
			icon: "<:old_scroll:716828676880334881>",
			description: "Although the concept of restricted powers and a code of laws has been around for a while, the time has finally come to update and formalise our constitution into something that will stand the test of time.",
			prerequisite_techs: ["political_standardisation"],
			research_cost: 1400,
			category: "administrative_technology",
			modifiers: [
				"Unlocks **Political Parties** Reforms"
			],
			unlocks: function (usr) {
				unlockReform(usr.id, "political_parties");
			}
		},
		intervention: {
			icon: "<:old_scroll:716828676880334881>",
			description: "Since the first 'bright' intellectuals came up with the concept of 'Bellum Justum', it falls upon us to figure out how to intervene in wars without the ire of our population. Concepts such as mutual defence and false-flag operations provide that casus belli, the reason for war that we so desperately need.",
			prerequisite_techs: ["coalitionism"],
			research_cost: 1400,
			category: "administrative_technology",
			modifiers: [
				"**+25%** CB Generation Speed"
			],
			unlocks: function (usr) {
				usr.modifiers.cb_generation_speed = usr.modifiers.cb_generation_speed + 0.25;
			}
		},
		improved_colonial_administration: {
			icon: "<:provinces:716809229603700737>",
			description: "Through the layout of ethnographic maps and historic provinces, we can help divide our colonial subjects up how we see best fit for their governance.",
			prerequisite_techs: ["early_imperialism"],
			research_cost: 1600,
			category: "administrative_technology",
			modifiers: [
				"Enables **Magnates**",
				"Obsoletes **Colonists**",
				"**+5%** Colonial Power Gain",
				"**-5% Overextention"
			],
			unlocks: function (usr) {
				usr.available_units.push("magnates");
				deleteElement(usr.available_units, "colonists", [usr, "obsolete_units"]);
				usr.modifiers.colonial_power_gain = usr.modifiers.colonial_power_gain + 0.05;
				usr.modifiers.overextension = usr.modifiers.overextension - 0.05;
			}
		},
		prussian_constitutionalism: {
			icon: "<:government:716817688693047306>",
			description: "Originating in the German state of Prussia, Prussian constitutionalism attempts to maintain a balance between complete constitutional monarchy as seen in Britain and an absolute monarchy where the monarch was to do as they saw fit.",
			prerequisite_techs: ["logical_units"],
			research_cost: 1600,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions." //Supposed to enable Prussian Constitutionalism as a government type in the future
			],
			unlocks: function (usr) {
			}
		},
		separation_of_powers: {
			icon: "<:political_capital:716817688525275257>",
			description: "In order to maintain a truly free democracy, the various branches of government must be separated in a such a manner that neither one of the branches is capable of holding a monopoly on government power.",
			prerequisite_techs: ["the_constitution"],
			research_cost: 1600,
			category: "administrative_technology",
			modifiers: [
				"**+5%** Republicanism Strength"
			],
			unlocks: function (usr) {
				usr.modifiers.republicanism = usr.modifiers.republicanism + 0.05;
			}
		},
		modern_diplomatic_institutions: {
			icon: "<:faculty:732730754911436830>",
			description: "Embassies, consulates, diplomatic missions and international agreements are slowly becoming more and more commonplace among the nations of the world, and it is only right that our great nation should take part in them as well.",
			prerequisite_techs: ["intervention"],
			research_cost: 1600,
			category: "administrative_technology",
			modifiers: [
				"**+1** Diplomatic Slots"
			],
			unlocks: function (usr) {
				usr.modifiers.starting_diplomatic_slots = usr.modifiers.starting_diplomatic_slots + 1;
			}
		},
		modern_bureaucracy: {
			icon: "<:knowledge:716797747193446441>",
			description: "The wheels and cogs of our government are beginning to turn as the first dedicated agencies to their service, the postal office and the central bank, are slowly beginning to cement themselves into the everyday vernacular. As our government expands, we must be careful to exercise our control well, lest certain parties increase unrest among our populace.",
			prerequisite_techs: ["prussian_constitutionalism"],
			research_cost: 1800,
			category: "administrative_technology",
			modifiers: [
				"**+2** Political Capital Gain",
				"Unlocks **School System** Reforms"
			],
			unlocks: function (usr) {
				usr.modifiers.political_capital_gain = usr.modifiers.political_capital_gain + 2;
				unlockReform(usr.id, "school_system");
			}
		},
		bill_of_rights: {
			icon: "<:old_scroll:716828676880334881>",
			description: "The Bill of Rights guarantees civil rights and liberties to the individual, like freedom of speech, press, and religion. It sets rules for due process of law and reserves all powers not delegated to the Government to the people.",
			prerequisite_techs: ["separation_of_powers"],
			research_cost: 1800,
			category: "administrative_technology",
			modifiers: [
				"**+5%** Republicanism Strength"
			],
			unlocks: function (usr) {
				usr.modifiers.republicanism = usr.modifiers.republicanism + 0.05;
			}
		},
		sphere_of_influence: {
			icon: "<:old_map:716821884867444746>",
			description: "A sphere of influence is a spatial region or concept division over which a state has a level of cultural, economic, military, or political exclusivity.",
			prerequisite_techs: ["modern_diplomatic_institutions"],
			research_cost: 1800,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions." //Supposed to enable Influence mechanics in the future
			],
			unlocks: function (usr) {
			}
		},
		colonial_autonomy: {
			icon: "<:consciousness:758424911852470293>",
			description: "Colonial autonomy allows for the existence of colonies with an elected government in which elected rulers were able to make most decisions without referring to the colonial power with nominal control of the colony.",
			prerequisite_techs: ["improved_colonial_administration"],
			research_cost: 2000,
			category: "administrative_technology",
			modifiers: [
				"**-5%** Colonial Maintenance"
			],
			unlocks: function (usr) {
				usr.modifiers.colonial_maintenance = usr.modifiers.colonial_maintenance - 0.05;
			}
		},
		instant_communciations: {
			icon: "<:naval_units:716821195277729832>",
			description: "The advent of the telegraph has allowed our country to revolutionise communication between not just our administrative entities, but also our finance centres and military as well, allowing for improved administrative efficiency.",
			prerequisite_techs: ["modern_bureaucracy"],
			research_cost: 2000,
			category: "administrative_technology",
			modifiers: [
				"**+3%** Administrative Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.administrative_efficiency = usr.modifiers.administrative_efficiency + 0.03;
			}
		},
		increased_voting_rights: {
			icon: "<:soldiers:732730754592669702>",
			description: "People in foreign lands are beginning to demand that they be given more say in political affairs, and as voter suffrage becomes a bigger issue abroad, perhaps it's time to look at our own country as well for consideration.",
			prerequisite_techs: ["bill_of_rights"],
			research_cost: 2000,
			category: "administrative_technology",
			modifiers: [
				"Unlocks **Public Meeting** Reforms",
				"Unlocks **Political Rights** Reforms"
			],
			unlocks: function (usr) {
				unlockReform(usr.id, "public_meetings");
				unlockReform(usr.id, "political_rights");
			}
		},
		political_union: {
			icon: "<:government:716817688693047306>",
			description: "A political union, in which all the parts thereof are intertwined either in a loose type of federalism where each state is still technically sovereign, or in a single union that comprises many autonomous regions, can encompass people of different ethnicities and languages by treating them as first-class citizens.",
			prerequisite_techs: ["sphere_of_influence"],
			research_cost: 2000,
			category: "administrative_technology",
			modifiers: [
				"**+1** Political Capital Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.political_capital_gain = usr.modifiers.political_capital_gain + 1;
			}
		},
		dominion_status: {
			icon: "<:government_scroll:716828975175041054>",
			description: "Overseas colonies are already clamouring for greater say in their external affairs. Granting them Dominion status would be a step in this direction, and would reduce our colonial maintenance expenses significantly.",
			prerequisite_techs: ["colonial_autonomy"],
			research_cost: 2500,
			category: "administrative_technology",
			modifiers: [
				"**-10%** Colonial Maintenance"
			],
			unlocks: function (usr) {
				usr.modifiers.colonial_maintenance = usr.modifiers.colonial_maintenance - 0.10;
			}
		},
		timezone_standardisation: {
			icon: "<:building:716827579650408538>",
			description: "Timezone Standardisation will allow for the railways to run on time as trains no longer have to be adjusted to a town's local time, improving the speed at which citizens of our nation can travel between cities.",
			prerequisite_techs: ["instant_communciations"],
			research_cost: 2500,
			category: "administrative_technology",
			modifiers: [
				"**+3%** Administrative Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.administrative_efficiency = usr.modifiers.administrative_efficiency + 0.03;
			}
		},
		revolution_and_counterrevolution: {
			icon: "<:infamy:716817688453709905>",
			description: "The advent of republicanism, especially violent one, has shaken the monarchies of the world to their core as more absolutist monarchies have to contend with new republics that threaten to stir up the international order.",
			prerequisite_techs: ["increased_voting_rights"],
			research_cost: 2500,
			category: "administrative_technology",
			modifiers: [
				"Unlocks **Vote Franchise** Reforms"
			],
			unlocks: function (usr) {
				unlockReform(usr.id, "vote_franchise");
			}
		},
		international_order: {
			icon: "<:diplomacy:716827579323121666>",
			description: "As the position of Great Powers in international politics become more cemented, we must learn to deal with them on the world stage if we wish to compete internationally.",
			prerequisite_techs: ["political_union"],
			research_cost: 2500,
			category: "administrative_technology",
			modifiers: [
				"**+5** Influence Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.influence_gain = usr.modifiers.influence_gain + 5;
			}
		},
		military_academies: {
			icon: "<:manpower:716817688705499177>",
			description: "Establishing professional schools of training where our officers can learn tactics and adapt in wargames will help to greatly improve our current military professionalism.",
			prerequisite_techs: ["dominion_status"],
			research_cost: 3000,
			category: "administrative_technology",
			modifiers: [
				"**+10%** Army Professionalism"
			],
			unlocks: function (usr) {
				usr.modifiers.army_professionalism = usr.modifiers.army_professionalism + 0.10;
			}
		},
		industrial_towns: {
			icon: "<:factory:759161240601493525>",
			description: "The establishment of industrial towns, solely dedicated to the furthering of our nation's industry, will become pivotal in the manufacturing sectors of our nation in the years to come.",
			prerequisite_techs: ["timezone_standardisation"],
			research_cost: 3000,
			category: "administrative_technology",
			modifiers: [
				"**+3%** Administrative Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.administrative_efficiency = usr.modifiers.administrative_efficiency + 0.03;
			}
		},
		popular_reform: {
			icon: "<:old_scroll:716828676880334881>",
			description: "Reforms in democratic states often demanded by the public can be passed in such institutions as Parliament, allowing for reforms to be made on a wide scale.",
			prerequisite_techs: ["timezone_standardisation"],
			research_cost: 3000,
			category: "administrative_technology",
			modifiers: [
				"Unlocks **Health Care** Reforms",
				"**+1%** Constitutional Monarchy Support Gain",
				"**+1%** Democracy Support Gain",
				"**+1%** Socialism Support Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.constitutional_monarchy = usr.modifiers.constitutional_monarchy + 1;
				usr.modifiers.democracy = usr.modifiers.democracy + 1;
				usr.modifiers.socialism = usr.modifiers.socialism + 1;
				unlockReform(usr.id, "healthcare");
			}
		},
		humane_treatment: {
			icon: "<:revolt:716819535964930149>",
			description: "Calls to outlaw such subtleties such as torture and arbitrary imprisonment have lead the populations of certain nations to begin calling for the criminalisation of 'cruel and unusual' punishments.",
			prerequisite_techs: ["timezone_standardisation"],
			research_cost: 3000,
			category: "administrative_technology",
			modifiers: [
				"**+10** Opinion Modifier"
			],
			unlocks: function (usr) {
				usr.modifiers.opinion_modifier = usr.modifiers.opinion_modifier + 10;
			}
		},
		divergent_political_thought: {
			icon: "<:knowledge:716797747193446441>",
			description: "As the spectre of new ideologies begin to take hold over the Continent, our nation's leaders should be careful to keep an eye on the situation to root out various forms of extremism.",
			prerequisite_techs: ["industrial_towns"],
			research_cost: 3500,
			category: "administrative_technology",
			modifiers: [
				"**+5%** Tax Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.tax_efficiency = usr.modifiers.tax_efficiency + 0.05;
			}
		},
		universal_suffrage: {
			icon: "<:old_scroll:716828676880334881>",
			description: "As the spectre of new ideologies begin to take hold over the Continent, our nation's leaders should be careful to keep an eye on the situation to root out various forms of extremism.",
			prerequisite_techs: ["popular_reform"],
			research_cost: 3500,
			category: "administrative_technology",
			modifiers: [
				"**+50** Political Capital"
			],
			unlocks: function (usr) {
				usr.political_capital = usr.political_capital + 50;
			}
		},
		communism: {
			icon: "<:infamy:716817688453709905>",
			description: "Socialism is when the government does stuff. And the more stuff they do, the more socialist it gets. And if they do a whole lot of stuff, it's communism.",
			prerequisite_techs: ["divergent_political_thought"],
			research_cost: 4000,
			category: "administrative_technology",
			modifiers: [
				"Enables **Communism**"
			],
			unlocks: function (usr) {
				usr.available_governments.push("communism");
			}
		},
		mass_politics: {
			icon: "<:old_scroll:716828676880334881>",
			description: "The emergence of new ideas and ideologies have piqued the common man's interest in politics, as they increasingly search for new ways of effective governance.",
			prerequisite_techs: ["universal_suffrage"],
			research_cost: 4000,
			category: "administrative_technology",
			modifiers: [
				"Unlocks **Press Rights** Reforms"
			],
			unlocks: function (usr) {
				unlockReform(usr.id, "press_rights");
			}
		},
		international_diplomatic_immunity: {
			icon: "<:diplomacy:716827579323121666>",
			description: "Increasingly, with the power projection of the countries that dominate this world, even uncivilised nations have to accept the sovereign immunity of diplomats.",
			prerequisite_techs: ["universal_suffrage"],
			research_cost: 4000,
			category: "administrative_technology",
			modifiers: [
				"**+5** Opinion Modifier"
			],
			unlocks: function (usr) {
				usr.modifiers.opinion_modifier = usr.modifiers.opinion_modifier + 5;
			}
		},
		protectorates: {
			icon: "<:old_map:716821884867444746>",
			description: "Protectorates are de jure nations that are given 'protection' by major colonial powers in exchange for large amounts of influence.",
			prerequisite_techs: ["military_academies"],
			research_cost: 4500,
			category: "administrative_technology",
			modifiers: [
				"Enables **Administrators**",
				"Obsoletes **Magnates**",
				"**+5%** Colonial Power Gain"
			],
			unlocks: function (usr) {
				usr.available_units.push("administrators");
				deleteElement(usr.available_units, "magnates", [usr, "obsolete_units"]);
				usr.modifiers.colonial_power_gain = usr.modifiers.colonial_power_gain + 0.05;
			}
		},
		fascism: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "Fascism is a doctrine that espouses the racial and national superiority of one's own country, often using political violence and intimidation in order to gain power before launching aggressive military campaigns in pursuit of a nationalist vision.",
			prerequisite_techs: ["communism"],
			research_cost: 4500,
			category: "administrative_technology",
			modifiers: [
				"Enables **Fascism**"
			],
			unlocks: function (usr) {
				usr.available_governments.push("fascism");
			}
		},
		self_determination: {
			icon: "<:knowledge:716797747193446441>",
			description: "A term Woodrow Wilson invented that doesn't actually mean anything. - Colonial Powers, probably.",
			prerequisite_techs: ["international_diplomatic_immunity"],
			research_cost: 4500,
			category: "administrative_technology",
			modifiers: [
				"**-10%** Stability",
				"**+2** Political Capital Gain"
			],
			unlocks: function (usr) {
				usr.stability = usr.stability - 10;
				usr.modifiers.political_capital_gain = usr.modifiers.political_capital_gain + 2;
			}
		},
		home_rule: {
			icon: "<:political_capital:716817688525275257>",
			description: "Seeking a compromise between direct rule, and complete independence, Home Rule allows for complete independence of the legislature whilst aligned with the foreign policy interests of the mother country.",
			prerequisite_techs: ["protectorates"],
			research_cost: 5000,
			category: "administrative_technology",
			modifiers: [
				"**-5%** Colonial Maintenace"
			],
			unlocks: function (usr) {
				usr.modifiers.colonial_maintenance = usr.modifiers.colonial_maintenance - 0.05;
			}
		},
		socialism: {
			icon: "<:workers:732730754735276124>",
			description: "Socialism is a blanket term for a wide range of economic and social systems characterised by social ownership of the means of production and workers' self-management of enterprises.",
			prerequisite_techs: ["fascism"],
			research_cost: 5000,
			category: "administrative_technology",
			modifiers: [
				"Enables **Socialism**"
			],
			unlocks: function (usr) {
				usr.available_governments.push("socialism");
			}
		},
		womens_suffrage: {
			icon: "<:consciousness:758424911852470293>",
			description: "The right for women to vote and participate in elections is a large step in the right direction in the fight for political equality and social reform, distancing societies from traditional gender roles.",
			prerequisite_techs: ["mass_politics"],
			research_cost: 5000,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions."
			],
			unlocks: function (usr) {
			}
		},
		geneva_convention: {
			icon: "<:diplomacy:716827579323121666>",
			description: "The Geneva Convention establishes the standard international law for human treatment in war, rules that apply in times of armed conflict that are aimed to protect people who are not included in taking part in hostilities.",
			prerequisite_techs: ["self_determination"],
			research_cost: 5000,
			category: "administrative_technology",
			modifiers: [
				"**-2%** Infamy Loss"
			],
			unlocks: function (usr) {
				usr.modifiers.infamy_loss = usr.modifiers.infamy_loss + 0.02;
			}
		},
		colonial_management: {
			icon: "<:old_map:716821884867444746>",
			description: "The vast swaths of land claimed by colonial powers aren't going to govern themselves, and the natives certainly won't be having a say either. Colonial management aims to exploit the resources and population of the colonies in order to maximise profits, with little to no regards for morality.",
			prerequisite_techs: ["home_rule"],
			research_cost: 5500,
			category: "administrative_technology",
			modifiers: [
				"**+5%** Colonial Power Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.colonial_power_gain = usr.modifiers.colonial_power_gain + 0.05;
			}
		},
		decentralised_administration: {
			icon: "<:provinces:716809229603700737>",
			description: "By allowing our various states and provinces to hold a high level of autonomy whilst reserving large amounts of federal power, we can potentially decrease the fiscal and administrative burden placed on local governments.",
			prerequisite_techs: ["socialism"],
			research_cost: 5500,
			category: "administrative_technology",
			modifiers: [
				"**+3%** Administrative Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.administrative_efficiency = usr.modifiers.administrative_efficiency + 0.03;
			}
		},
		frontier_control: {
			icon: "<:soldiers:732730754592669702>",
			description: "Having the power to check those coming in and out of our country will help in reducing the crime rate, as well as for checking for hostile actors who seek to upend our system and traditions.",
			prerequisite_techs: ["geneva_convention"],
			research_cost: 5500,
			category: "administrative_technology",
			modifiers: [
				"**+1** Political Capital Gain",
				"**-5%** Crime Rate"
			],
			unlocks: function (usr) {
				usr.modifiers.political_capital_gain = usr.modifiers.political_capital_gain + 1;
				usr.modifiers.crime_rate = usr.modifiers.crime_rate - 0.05;
			}
		},
		trusts_and_mandates: {
			icon: "<:globe:716811246556545035>",
			description: "Having the power to check those coming in and out of our country will help in reducing the crime rate, as well as for checking for hostile actors who seek to upend our system and traditions.",
			prerequisite_techs: ["colonial_management"],
			research_cost: 6000,
			category: "administrative_technology",
			modifiers: [
				"**-5%** Colonial Maintenance"
			],
			unlocks: function (usr) {
				usr.available_units.push("bureaucrats");
				deleteElement(usr.available_units, "administrators", [usr, "obsolete_units"]);
				usr.modifiers.colonial_maintenance = usr.modifiers.colonial_maintenance - 0.05;
			}
		},
		multi_party_political_systems: {
			icon: "<:government:716817688693047306>",
			description: "A multi-party political system allows for multiple political parties across the political spectrum to run in elections and have the capability to gain control of government institutions, either separately or in coalition.",
			prerequisite_techs: ["womens_suffrage"],
			research_cost: 6000,
			category: "administrative_technology",
			modifiers: [
				"**+1%** Constitutional Monarchy Support Gain",
				"**+1%** Democracy Support Gain",
				"**+1%** Socialism Support Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.constitutional_monarchy = usr.modifiers.constitutional_monarchy + 1;
			}
		},
		international_treaties: {
			icon: "<:globe:716811246556545035>",
			description: "A treaty is a formal and binding agreement entered by sovereign states or international organisations. Treaties express agreements that states use to legally bind themselves.",
			prerequisite_techs: ["frontier_control"],
			research_cost: 6000,
			category: "administrative_technology",
			modifiers: [
				"**+1** Diplomatic Slots"
			],
			unlocks: function (usr) {
				usr.modifiers.starting_diplomatic_slots = usr.modifiers.starting_diplomatic_slots + 1;
			}
		},
		wartime_colonial_administration: {
			icon: "<:infamy:716817688453709905>",
			description: "A treaty is a formal and binding agreement entered by sovereign states or international organisations. Treaties express agreements that states use to legally bind themselves.",
			prerequisite_techs: ["trusts_and_mandates"],
			research_cost: 6500,
			category: "administrative_technology",
			modifiers: [
				"**+15%** Colonial Maintenance",
				"**+10%** Colonial Power Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.colonial_maintenance = usr.modifiers.colonial_maintenance + 0.15;
				usr.modifiers.colonial_power_gain = usr.modifiers.colonial_power_gain + 0.10;
			}
		},
		economic_based_ideologies: {
			icon: "<:gold:716798541028261927>",
			description: "Economic-based ideologies such as anarcho-capitalism believe the inherent worth of the economy to act as a tool in moulding the life of the ordinary citizen.",
			prerequisite_techs: ["decentralised_administration"],
			research_cost: 6500,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions." //Supposed to unlock Libertarianism, Strasserism in the future
			],
			unlocks: function (usr) {
			}
		},
		racial_equality: {
			icon: "<:consciousness:758424911852470293>",
			description: "Racial equality is when institutions give equal opportunities to people of all races, regardless of physical traits, heritage or skin color. This would allow for minorities to gain more opportunities in employment, education and politics than ever before.",
			prerequisite_techs: ["multi_party_political_systems"],
			research_cost: 6500,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions." //Supposed to unlock Minorities reforms in the future
			],
			unlocks: function (usr) {
			}
		},
		universal_human_rights: {
			icon: "<:workers:732730754735276124>",
			description: "The establishment of moral principles and norms that set an international standard for fundamental rights to which a person is inherently entitled simply because he or she is a human being, regardless of age, ethnic origin, location, language, religion, ethnicity or any other status.",
			prerequisite_techs: ["international_treaties"],
			research_cost: 6500,
			category: "administrative_technology",
			modifiers: [
				"**-1%** Infamy Loss"
			],
			unlocks: function (usr) {
				usr.modifiers.infamy_loss = usr.modifiers.infamy_loss - 0.01;
			}
		},
		decolonisation: {
			icon: "<:diplomacy:716827579323121666>",
			description: "The description for this technology has not yet been written! This will be fixed at a later date.",
			prerequisite_techs: ["wartime_colonial_administration"],
			research_cost: 7000,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions." //Supposed to unlock Decolonisation mechanics in the future
			],
			unlocks: function (usr) {
			}
		},
		political_responsibility: {
			icon: "<:political_capital:716817688525275257>",
			description: "By holding those in office accountable for their political actions, our government can seek to enforce a meritocracy of sorts that promotes only those deemed capable enough to carry out their duties effectively.",
			prerequisite_techs: ["racial_equality"],
			research_cost: 7000,
			category: "administrative_technology",
			modifiers: [
				"**+2** Political Capital Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.political_capital_gain = usr.modifiers.political_capital_gain + 2;
			}
		},
		cold_war: {
			icon: "<:infamy:716817688453709905>",
			description: "New technological innovations, digitalisation and mass markets have come to dominate our country, as we deal with the ideological struggles of the Cold War.",
			prerequisite_techs: ["universal_human_rights"],
			research_cost: 7000,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions." //Supposed to unlock Cold War mechanics in the future
			],
			unlocks: function (usr) {
			}
		},
		neo_colonialism: {
			icon: "<:trade:716828677115084812>",
			description: "Neo-colonialism is the geopolitical practice of utilising economics, globalisation, cultural imperialism, conditional aid, and other nefarious practices such as spiraling debt obligations that functionally imitate the relationship of traditional colonialism in order to impose dominance over other sovereign states.",
			prerequisite_techs: ["decolonisation"],
			research_cost: 7500,
			category: "administrative_technology",
			modifiers: [
				"**+5%** Colonial Power Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.colonial_power_gain = usr.modifiers.colonial_power_gain + 0.05;
			}
		},
		modern_political_theory: {
			icon: "<:political_capital:716817688525275257>",
			description: "The description for this technology has not yet been written! This will be fixed at a later date.",
			prerequisite_techs: ["decolonisation"],
			research_cost: 7500,
			category: "administrative_technology",
			modifiers: [
				"**+1** Political Capital Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.political_capital_gain = usr.modifiers.political_capital_gain + 1;
			}
		},
		containment: {
			icon: "<:infamy:716817688453709905>",
			description: "The description for this technology has not yet been written! This will be fixed at a later date.",
			prerequisite_techs: ["cold_war"],
			research_cost: 7500,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions."
			],
			unlocks: function (usr) {
			}
		},
		modern_political_competency: {
			icon: "<:knowledge:716797747193446441>",
			description: "The description for this technology has not yet been written! This will be fixed at a later date.",
			prerequisite_techs: ["modern_political_theory"],
			research_cost: 8000,
			category: "administrative_technology",
			modifiers: [
				"**+3%** Administrative Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.administrative_efficiency = usr.modifiers.administrative_efficiency + 0.03;
			}
		},
		rollback: {
			icon: "<:land_vehicles:716821195215077406>",
			description: "The description for this technology has not yet been written! This will be fixed at a later date.",
			prerequisite_techs: ["containment"],
			research_cost: 8000,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions."
			],
			unlocks: function (usr) {
			}
		},
		governmental_digitisation: {
			icon: "<:government:716817688693047306>",
			description: "The description for this technology has not yet been written! This will be fixed at a later date.",
			prerequisite_techs: ["modern_political_competency"],
			research_cost: 8500,
			category: "administrative_technology",
			modifiers: [
				"**+5%** Administrative Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.administrative_efficiency = usr.modifiers.administrative_efficiency + 0.05;
			}
		},
		lgbtqia_rights: {
			icon: "<:government:716817688693047306>",
			description: "The description for this technology has not yet been written! This will be fixed at a later date.",
			prerequisite_techs: ["modern_political_competency"],
			research_cost: 8500,
			category: "administrative_technology",
			modifiers: [
				"Unlocks **LGBTQIA Rights** Reforms"
			],
			unlocks: function (usr) {
				unlockReform(usr.id, "lgbtqia_rights");
			}
		},
		foreign_aid: {
			icon: "<:money:716817688718213192>",
			description: "Foreign aid is the voluntary transfer of resources from one actor to another. It serves various purposes, such as a sign of diplomatic approval, extending the donor's cultural influence and providing infrastructure needed by the donor for resource extraction from the recipient country.",
			prerequisite_techs: ["rollback"],
			research_cost: 8500,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions." //Supposed to unlock Foreign Aid diplomatic decisions with other countries to extend influence
			],
			unlocks: function (usr) {
			}
		},
		political_transparency: {
			icon: "<:knowledge:716797747193446441>",
			description: "Political transparency gives citizens the right and means to examine the process of decision making within government institutions. This is used as a means of holding public officials accountable and fighting corruption.",
			prerequisite_techs: ["governmental_digitisation"],
			research_cost: 9000,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions."
			],
			unlocks: function (usr) {
			}
		},
		contemporary_politics: {
			icon: "<:consciousness:758424911852470293>",
			description: "The description for this technology has not yet been written! This will be fixed at a later date.",
			prerequisite_techs: ["lgbtqia_rights"],
			research_cost: 9000,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions." 
			],
			unlocks: function (usr) {
			}
		},
		detente: {
			icon: "<:diplomacy:716827579323121666>",
			description: "Detente is the relaxation of strained relations, especially political tensions, by communication. The term is often used to refer to a period of general easing of geopolitical tensions between major powers.",
			prerequisite_techs: ["foreign_aid"],
			research_cost: 9000,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions." //Supposed to enable Detente decisions
			],
			unlocks: function (usr) {
			}
		},
		populism: {
			icon: "<:culture:758424912049864784>",
			description: "Populism refers to a range of political stances that emphasises the idea of 'the people', and often seeks to juxtapose this group against a common enemy via negative integration.",
			prerequisite_techs: ["contemporary_politics","detente"],
			research_cost: 10000,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions." //Supposed to unlock populist ideologies
			],
			unlocks: function (usr) {
			}
		},
		democratic_order: {
			icon: "<:revolt:716819535964930149>",
			description: "The description for this technology has not yet been written! This will be fixed at a later date.",
			prerequisite_techs: ["contemporary_politics","detente"],
			research_cost: 10000,
			category: "administrative_technology",
			modifiers: [
				"**+1%** Constitutional Monarchy Support Gain",
				"**+1%** Democracy Support Gain",
				"**+1%** Socialism Support Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.constitutional_monarchy = usr.modifiers.constitutional_monarchy + 1;
				usr.modifiers.democracy = usr.modifiers.democracy + 1;
				usr.modifiers.socialism = usr.modifiers.socialism + 1;
			}
		},
		increased_digitalisation: {
			icon: "<:steel:716791408828088420>",
			description: "The description for this technology has not yet been written! This will be fixed at a later date.",
			prerequisite_techs: ["political_transparency"],
			research_cost: 10000,
			category: "administrative_technology",
			modifiers: [
				"**+5%** Administrative Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.administrative_efficiency = usr.modifiers.administrative_efficiency + 0.05;
			}
		},
		students_rights: {
			icon: "<:consciousness:758424911852470293>",
			description: "The description for this technology has not yet been written! This will be fixed at a later date.",
			prerequisite_techs: ["populism"],
			research_cost: 10000,
			category: "administrative_technology",
			modifiers: [
				"This technology currently has no effect. This may change in future versions." //Supposed to unlock Students Rights reforms
			],
			unlocks: function (usr) {
			}
		},
		citizen_protection: {
			icon: "<:faculty:732730754911436830>",
			description: "The description for this technology has not yet been written! This will be fixed at a later date.",
			prerequisite_techs: ["democratic_order"],
			research_cost: 10000,
			category: "administrative_technology",
			modifiers: [
				"**+1** Political Capital Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.political_capital_gain = usr.modifiers.political_capital_gain + 1;
			}
		},
		cyberstates: {
			icon: "<:taxes:716817688781127810>",
			description: "The description for this technology has not yet been written! This will be fixed at a later date.",
			prerequisite_techs: ["increased_digitalisation"],
			research_cost: 10500,
			category: "administrative_technology",
			modifiers: [
				"**+5%** Administrative Efficiency"
			],
			unlocks: function (usr) {
				usr.modifiers.administrative_efficiency = usr.modifiers.administrative_efficiency + 0.05;
			}
		},
		minors_rights: {
			icon: "<:faculty:732730754911436830>",
			description: "The description for this technology has not yet been written! This will be fixed at a later date.",
			prerequisite_techs: ["students_rights"],
			research_cost: 10500,
			category: "administrative_technology",
			modifiers: [
				"**+1** Political Capital Gain",
				"**-5%** Stability"
			],
			unlocks: function (usr) {
				usr.modifiers.political_capital_gain = usr.modifiers.political_capital_gain + 1;
				usr.stability = usr.stability - 5;
			}
		},
		contemporary_international_order: {
			icon: "<:diplomacy:716827579323121666>",
			description: "The establishment of a worldwide intergovernmental organization aims to maintain international peace, justice, stability and security, while developing friendly and mutually beneficial relations among states to achieve international cooperation.",
			prerequisite_techs: ["citizen_protection"],
			research_cost: 10500,
			category: "administrative_technology",
			modifiers: [
				"**+2** Political Capital Gain"
			],
			unlocks: function (usr) {
				usr.modifiers.political_capital_gain = usr.modifiers.political_capital_gain + 2;
			}
		},
		augmented_governmental_management: {
			icon: "<:development:716811992421367869>",
			description: "Through the effective use of information and employing algorithmic governance, we can create a government capable of managing various bureaus and agencies with surgical precision and machine-like efficiency.",
			prerequisite_techs: ["cyberstates"],
			research_cost: 11000,
			category: "administrative_technology",
			modifiers: [
				"**+10%** Administrative Efficiency",
				"**+5%** Stability"
			],
			unlocks: function (usr) {
				usr.modifiers.administrative_efficiency = usr.modifiers.administrative_efficiency + 0.10;
				usr.stability = usr.stability + 5;
			}
		},
	},
	
	government_list: ["absolute_monarchy", "constitutional_monarchy", "communism", "socialism", "democracy", "fascism"],
	governments: {
		anarchy: {
			name: ["Anarchy", "Anarchists"],
			icon: ":black_circle:",
			description: "Anarchists believe in a stateless world ... which is bad news for you, since you're roleplaying a state. Go on, do `$government <name>`!",
			can_justify_wars: false,
			has_elections: false,
			maximum_manpower: 1.00,
			maximum_tax_rate: 0.00,
			civilian_actions: 0.00,
			stability_modifier: -10,
			famine_penalty: 0.50
		},
		absolute_monarchy: {
			name: ["Absolute Monarchy", "Absolutists"],
			icon: ":purple_circle:",
			description: "Supporters of absolute monarchy believe in a divinely ordained monarchy that wields absolute power.",
			can_justify_wars: true,
			has_elections: false,
			maximum_manpower: 0.10,
			maximum_tax_rate: 0.65,
			civilian_actions: 0.10,
			stability_modifier: -5,
			famine_penalty: 0.075,
			reform_desire: -0.1
		},
		constitutional_monarchy: {
			name: ["Constitutional Monarchy", "Constitutionalists"],
			icon: ":orange_circle:",
			description: "Constitutionalists believe in a figurehead monarchy, with a democratic system of government.",
			can_justify_wars: false,
			has_elections: true,
			maximum_manpower: 0.20,
			maximum_tax_rate: 0.35,
			civilian_actions: 0.35,
			stability_modifier: 5,
			famine_penalty: 0.065,
			reform_desire: 0.02
		},
		communism: {
			name: ["Communism", "Communists"],
			icon: ":red_circle:",
			description: "Communism, the Red Hydra: the dictatorship of the proletariat often means the nationalisation of all privately held property.",
			can_justify_wars: true,
			has_elections: false,
			maximum_manpower: 0.35,
			maximum_tax_rate: 0.05,
			civilian_actions: 0.05,
			stability_modifier: -5,
			famine_penalty: 0.125,
			reform_desire: 0.01
		},
		socialism: {
			name: ["Socialism", "Socialists"],
			icon: ":green_circle:",
			description: "Socialism branched out from communism during the first half of the 20th century, and instead argued for a welfare state.",
			can_justify_wars: false,
			has_elections: true,
			maximum_manpower: 0.35,
			maximum_tax_rate: 0.15,
			civilian_actions: 0.20,
			stability_modifier: 5,
			famine_penalty: 0.07,
			reform_desire: 0.04
		},
		democracy: {
			name: ["Democracy", "Republicans"],
			icon: ":blue_circle:",
			description: "The concept of democracy often differed throughout history, but eventually came to represent a government by the people.",
			can_justify_wars: false,
			has_elections: true,
			maximum_manpower: 0.25,
			maximum_tax_rate: 0.70,
			civilian_actions: 0.50,
			stability_modifier: 5,
			famine_penalty: 0.05,
			reform_desire: 0.03
		},
		fascism: {
			name: ["Fascism", "Fascists"],
			icon: ":brown_circle:",
			description: "Fascism originally stemmed from ethnic hypernationalism and became emblematic of aggressive militaristic countries.",
			can_justify_wars: true,
			has_elections: false,
			maximum_manpower: 0.10,
			maximum_tax_rate: 0.70,
			civilian_actions: 0.20,
			stability_modifier: 10,
			famine_penalty: 0.05,
			reform_desire: -0.05
		}
	},
	
	reforms: {
		minimum_wage: {
			name: "Minimum Wage",
			no_minimum_wage: {
				name: "No Minimum Wage",
				description: "Proponents of no minimum wage believe that countries without a minimum wage will see increased economic growth as smaller businesses can afford to hire more workers.",
				political_appeasement: {
					absolute_monarchy_discontent: -5,
					fascism_discontent: -5,
					constitutional_monarchy_discontent: 2,
					democracy_discontent: 2,
					socialism_discontent: 5,
					communism_discontent: 7
				},
				effects: [
					["stability", -5],
					["tax_efficiency", -0.03],
					["production_efficiency", -0.05],
					["research_efficiency", 0.02],
					["building_cost", -0.05],
					["rgo_throughput", 0.02]
				]
			},
			trinket_minimum_wage: {
				name: "Trinket Minimum Wage",
				description: "A trinket minimum wage can be used to help satisfy the workers of this country whilst keeping corporate regulations minimal. However, workers won't be oblivious to this, and trade unions will likely continue to attempt to push for higher minimum wages.",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: -3,
					constitutional_monarchy_discontent: 3,
					democracy_discontent: 3,
					socialism_discontent: 2,
					communism_discontent: 2
				},
				effects: [
					["stability", -3],
					["tax_efficiency", -0.02],
					["production_efficiency", -0.04],
					["research_efficiency", 0.05],
					["building_cost", -0.03],
					["rgo_throughput", 0.02]
				]
			},
			low_minimum_wage: {
				name: "Low Minimum Wage",
				description: "Low minimum wages wil help reduce worker discontent, but will also be seen as a step towards more regulationist policies in our country.",
				political_appeasement: {
					absolute_monarchy_discontent: -1,
					fascism_discontent: -2,
					constitutional_monarchy_discontent: 0,
					democracy_discontent: 0,
					socialism_discontent: 2,
					communism_discontent: 3
				},
				effects: [
					["stability", -1],
					["production_efficiency", -0.02]
				]
			},
			acceptable_minimum_wage: {
				name: "Acceptable Minimum Wage",
				description: "Acceptable minimum wages, whilst decreasing our support amongst more conservative members of society, is seen as a widely needed reform by trade unions and those on the left of the political spectrum. It is also likely to impact small businesses.",
				political_appeasement: {
					absolute_monarchy_discontent: 3,
					fascism_discontent: 2,
					constitutional_monarchy_discontent: -1,
					democracy_discontent: -1,
					socialism_discontent: 4,
					communism_discontent: 3
				},
				effects: [
					["stability", 2],
					["tax_efficiency", 0.03],
					["production_efficiency", 0.02],
					["research_efficiency", -0.01],
					["building_cost", 0.05],
					["unit_cost", 0.05],
					["training_cost", 0.05],
					["rgo_throughput", -0.03]
				]
			},
			good_minimum_wage: {
				name: "Good Minimum Wage",
				description: "A good minimum wage, or as critics are calling it, a 'lavish minimum wage', is likely to increase stability and lower discontent on the left, but will also increase building costs and unit upkeep, although tax efficiency will also go up as consumer spending increases.",
				political_appeasement: {
					absolute_monarchy_discontent: 5,
					fascism_discontent: 4,
					constitutional_monarchy_discontent: 2,
					democracy_discontent: 3,
					socialism_discontent: -7,
					communism_discontent: -6
				},
				effects: [
					["stability", 5],
					["tax_efficiency", 0.05],
					["production_efficiency", 0.04],
					["research_efficiency", -0.06],
					["building_cost", 0.10],
					["unit_cost", 0.08],
					["training_cost", 0.06],
					["rgo_throughput", -0.05]
				]
			}
		},
		maximum_workhours: {
			name: "Maximum Workhours",
			unlimited_work_day: {
				name: "Unlimited Work Day",
				description: "No one enjoys this schedule, but proponents of lassiez-faire believe that markets will self-adjust working hours, as workers choose which jobs to work at. However, critics point out that all workplaces have similar working hours.",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: -1,
					constitutional_monarchy_discontent: 5,
					democracy_discontent: 6,
					socialism_discontent: 8,
					communism_discontent: 8
				},
				effects: [
					["stability", -7],
					["tax_efficiency", -0.05],
					["production_efficiency", 0.2],
					["research_efficiency", -0.1],
					["reform_desire_gain", 0.05],
					["rgo_throughput", 0.1]
				]
			},
			fourteen_hour_work_day: {
				name: "14 Hour Work Day",
				description: "The introduction of a limited work day was hailed as a good first step, but regulationists are still concerned, and laissez-faire economists believe the government is meddling too much in private business.",
				political_appeasement: {
					absolute_monarchy_discontent: -2,
					fascism_discontent: -2,
					constitutional_monarchy_discontent: 3,
					democracy_discontent: 3,
					socialism_discontent: 1,
					communism_discontent: 1
				},
				effects: [
					["stability", -5],
					["tax_efficiency", -0.02],
					["production_efficiency", 0.1],
					["reform_desire_gain", 0.02],
					["rgo_throughput", 0.05]
				]
			},
			twelve_hour_work_day: {
				name: "12 Hour Work Day",
				description: "A 12-hour workday, whilst currently seen as acceptable, is likely to fail to placate workers in the long-term, and laissez-faire economists are increasingly claiming that our policies go overboard.",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: -2,
					constitutional_monarchy_discontent: 2,
					democracy_discontent: 5,
					socialism_discontent: 3,
					communism_discontent: 2
				},
				effects: [
					["stability", -3],
					["research_efficiency", 0.05],
					["production_efficiency", 0.1],
					["reform_desire_gain", 0.01],
					["rgo_throughput", 0.05]
				]
			},
			ten_hour_work_day: {
				name: "10 Hour Work Day",
				description: "A 10-hour workday is likely to meet the relatively modern standards that our workers are now demanding for their workday, but also to upset deregulationists.",
				political_appeasement: {
					absolute_monarchy_discontent: 2,
					fascism_discontent: 3,
					constitutional_monarchy_discontent: 1,
					democracy_discontent: 1,
					socialism_discontent: -4,
					communism_discontent: -3
				},
				effects: [
					["research_efficiency", 0.1],
					["production_efficiency", 0.05],
					["rgo_throughput", 0.05]
				]
			},
			eight_hour_work_day: {
				name: "8 Hour Work Day",
				description: "A comfortable eight hour workday is likely to allow leisure time for our workers, and therefore, will also increase consumer spending, especially when coupled with better minimum wages. Critics, however, point out that it will lower our production efficiency.",
				political_appeasement: {
					absolute_monarchy_discontent: 7,
					fascism_discontent: 5,
					constitutional_monarchy_discontent: 2,
					democracy_discontent: 3,
					socialism_discontent: -8,
					communism_discontent: -5
				},
				effects: [
					["stability", 5],
					["research_efficiency", 0.15],
					["tax_efficiency", 0.03],
					["production_efficiency", -0.05],
					["rgo_throughput", -0.05]
				]
			}
		},
		safety_regulations: {
			name: "Safety Regulations",
			no_safety_regulations: {
				name: "No Safety Regulations",
				description: "Although dangerous, critics of safety regulation believe that increased regulationism will reduce the ability of the free markets to allocate their own funds most efficiently.",
				political_appeasement: {
					absolute_monarchy_discontent: -5,
					fascism_discontent: -6,
					constitutional_monarchy_discontent: 4,
					democracy_discontent: 5,
					socialism_discontent: 7,
					communism_discontent: 6
				},
				effects: [
					["stability", -5],
					["pop_growth_modifier", -0.01],
					["reform_desire_gain", 0.05],
					["production_efficiency", 0.05],
					["building_cost", -0.1],
					["tax_efficiency", -0.02]
				]
			},
			minimal_safety_regulations: {
				name: "Minimal Safety Regulations",
				description: "Minimal safety regulations, whilst not protecting from all accidents, will hopefully help those on the job to avoid the most serious of injuries that may maim them for life.",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: -4,
					constitutional_monarchy_discontent: 3,
					democracy_discontent: 4,
					socialism_discontent: 5,
					communism_discontent: 5
				},
				effects: [
					["stability", -2],
					["pop_growth_modifier", -0.005],
					["reform_desire_gain", 0.04],
					["production_efficiency", 0.02],
					["building_cost", -0.05]
				]
			},
			limited_safety_regulations: {
				name: "Limited Safety Regulations",
				description: "Limited safety regulations will prevent most injures on-site and will help reduce the burden on charities and workers compensation. However, production efficiency will take a modest hit.",
				political_appeasement: {
					absolute_monarchy_discontent: -2,
					fascism_discontent: -1,
					constitutional_monarchy_discontent: 1,
					democracy_discontent: 2,
					socialism_discontent: 3,
					communism_discontent: 4
				},
				effects: [
					["reform_desire_gain", 0.02],
					["production_efficiency", 0.01],
					["tax_efficiency", 0.01]
				]
			},
			acceptable_safety_regulations: {
				name: "Acceptable Safety Regulations",
				description: "Acceptable safety regulations are hailed by trade unions as a step towards a comprehensive social safety net, but companies are beginning to fear the overarching role that government is beginning to play in regulation.",
				political_appeasement: {
					absolute_monarchy_discontent: 2,
					fascism_discontent: 4,
					constitutional_monarchy_discontent: -4,
					democracy_discontent: -5,
					socialism_discontent: 1,
					communism_discontent: 1
				},
				effects: [
					["stability", 2],
					["production_efficiency", -0.02],
					["pop_growth_modifier", 0.02],
					["reform_desire_gain", -0.02],
					["building_cost", 0.1],
					["tax_efficiency", 0.04]
				]
			},
			excellent_safety_regulations: {
				name: "Excellent Safety Regulations",
				description: "Excellent safety regulations, although widely seen as a gross overreach of power by conservatives and even moderates, is a way to help ensure minimal casualties amongst the workforce, and will help appease those on the left.",
				political_appeasement: {
					absolute_monarchy_discontent: 5,
					fascism_discontent: 6,
					constitutional_monarchy_discontent: 1,
					democracy_discontent: 2,
					socialism_discontent: -7,
					communism_discontent: -7
				},
				effects: [
					["stability", 5],
					["production_efficiency", -0.05],
					["pop_growth_modifier", 0.01],
					["reform_desire_gain", -0.05],
					["building_cost", 0.15],
					["tax_efficiency", 0.1]
				]
			}
		},
		unemployment: {
			name: "Unemployment",
			no_subsidies: {
				name: "No Subsidies",
				description: "In order to avoid taxation, we can rely completely on charities to provide aid to those most affected, so as to ease the administrative burden upon ourselves.",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: -8,
					constitutional_monarchy_discontent: 5,
					democracy_discontent: 4,
					socialism_discontent: 5,
					communism_discontent: 6
				},
				effects: [
					["stability", -5],
					["pop_growth_modifier", -0.02],
					["reform_desire_gain", 0.05],
					["tax_efficiency", 0.1],
					["national_manpower", 0.05],
					["political_capital_gain", 2]
				]
			},
			trinket_subsidies: {
				name: "Trinket Subsidies",
				description: "Trinket subsidies, athough far from an effective solution regarding unemployment, will help alleviate some of the burdens faced by unemployed workers in our country today.",
				political_appeasement: {
					absolute_monarchy_discontent: -2,
					fascism_discontent: -6,
					constitutional_monarchy_discontent: 4,
					democracy_discontent: 3,
					socialism_discontent: 4,
					communism_discontent: 4
				},
				effects: [
					["stability", -3],
					["pop_growth_modifier", -0.02],
					["reform_desire_gain", 0.03],
					["tax_efficiency", 0.08],
					["national_manpower", 0.02],
					["political_capital_gain", 1]
				]
			},
			trinket_subsidies: {
				name: "Trinket Subsidies",
				description: "Trinket subsidies, athough far from an effective solution regarding unemployment, will help alleviate some of the burdens faced by unemployed workers in our country today.",
				political_appeasement: {
					absolute_monarchy_discontent: -2,
					fascism_discontent: -6,
					constitutional_monarchy_discontent: 4,
					democracy_discontent: 3,
					socialism_discontent: 4,
					communism_discontent: 4
				},
				effects: [
					["stability", -3],
					["pop_growth_modifier", -0.02],
					["reform_desire_gain", 0.02],
					["tax_efficiency", 0.08],
					["national_manpower", 0.02],
					["political_capital_gain", 1]
				]
			},
			low_subsidies: {
				name: "Low Subsidies",
				description: "Low subsidies, although far from a comprehensive part of a social safety net, will help lift the burden on charities, and lower discontent amongst the general public.",
				political_appeasement: {
					absolute_monarchy_discontent: -1,
					fascism_discontent: -3,
					constitutional_monarchy_discontent: 1,
					democracy_discontent: 1,
					socialism_discontent: 3,
					communism_discontent: 2
				},
				effects: [
					["pop_growth_modifier", -0.01],
					["reform_desire_gain", 0.01],
					["tax_efficiency", 0.04]
				]
			},
			extended_subsidies: {
				name: "Extended Subsidies",
				description: "Extended subsidies, although praised by the left as helping those unfortunate enough to be unemployed to get back on their feet, are also said by those on the right to encourage laziness, and may lower our tax efficiency.",
				political_appeasement: {
					absolute_monarchy_discontent: 1,
					fascism_discontent: 2,
					constitutional_monarchy_discontent: 1,
					democracy_discontent: 0,
					socialism_discontent: -2,
					communism_discontent: -3
				},
				effects: [
					["stability", 5],
					["pop_growth_modifier", 0.02],
					["reform_desire_gain", -0.02],
					["production_efficiency", -0.05],
					["national_manpower", -0.01]
				]
			},
			generous_subsidies: {
				name: "Generous Subsidies",
				description: "Generous subsidies, although deeply alleviating burden on the unemployed, will also weigh down our state's coffers and political capital, and is often seen as feeding laziness.",
				political_appeasement: {
					absolute_monarchy_discontent: 2,
					fascism_discontent: 6,
					constitutional_monarchy_discontent: 4,
					democracy_discontent: 3,
					socialism_discontent: -4,
					communism_discontent: -4
				},
				effects: [
					["stability", 10],
					["pop_growth_modifier", 0.05],
					["reform_desire_gain", -0.05],
					["production_efficiency", -0.1],
					["building_cost", 0.05],
					["national_manpower", -0.05]
				]
			}
		},
		pensions: {
			name: "Pensions",
			no_pensions: {
				name: "No Pensions",
				description: "Although pensions might sure sound nice, few people ever consider how much money it would actually cost us, and does it look like the public want austerity?",
				political_appeasement: {
					absolute_monarchy_discontent: -5,
					fascism_discontent: -4,
					constitutional_monarchy_discontent: 5,
					democracy_discontent: 4,
					socialism_discontent: 7,
					communism_discontent: 7
				},
				effects: [
					["stability", -3],
					["pop_growth_modifier", 0.02],
					["reform_desire_gain", 0.02],
					["tax_efficiency", 0.07],
					["political_capital_gain", 4],
					["building_cost", -0.1],
					["training_cost", -0.1],
					["production_efficiency", -0.05]
				]
			},
			trinket_pensions: {
				name: "Trinket Pensions",
				description: "Trinket pensions will give our workforce something to look forwards to in the future when they retire, even if not much. Unfortunately, it would seem that the pension amount is proportional to incentive.",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: 1,
					constitutional_monarchy_discontent: 4,
					democracy_discontent: 3,
					socialism_discontent: 5,
					communism_discontent: 5
				},
				effects: [
					["stability", -1],
					["pop_growth_modifier", 0.04],
					["reform_desire_gain", 0.02],
					["tax_efficiency", 0.05],
					["political_capital_gain", 3],
					["building_cost", -0.05],
					["training_cost", -0.05],
					["production_efficiency", -0.02]
				]
			},
			low_pensions: {
				name: "Low Pensions",
				description: "Low pensions, whilst still offering flexibility for our state budget, will also help to incentivise workers and help decrease discontent in our country. However, some in our government are beginning to grow worried whether our state can handle all these expenses ...",
				political_appeasement: {
					absolute_monarchy_discontent: -2,
					fascism_discontent: -1,
					constitutional_monarchy_discontent: 2,
					democracy_discontent: 2,
					socialism_discontent: 4,
					communism_discontent: 3
				},
				effects: [
					["pop_growth_modifier", 0.05],
					["tax_efficiency", 0.01],
					["political_capital_gain", 1]
				]
			},
			acceptable_pensions: {
				name: "Acceptable Pensions",
				description: "Acceptable pensions, a.k.a. enough for most of our elderly to live off of, is substantially more accepted by society, but also places a substantial burden on our administrative functions and our workforce.",
				political_appeasement: {
					absolute_monarchy_discontent: 2,
					fascism_discontent: -2,
					constitutional_monarchy_discontent: -5,
					democracy_discontent: -5,
					socialism_discontent: -2,
					communism_discontent: -3
				},
				effects: [
					["stability", 5],
					["pop_growth_modifier", 0.07],
					["reform_desire_gain", -0.02],
					["tax_efficiency", -0.05],
					["political_capital_gain", -1],
					["building_cost", 0.05],
					["training_cost", 0.05],
					["production_efficiency", 0.05]
				]
			},
			good_pensions: {
				name: "Good Pensions",
				description: "Good pensions, whilst placing a heavy burden on our existent workforce and lowering the state budget significantly will serve as a paragon of stability and incentive, although it will alienate those on the right and even some moderates.",
				political_appeasement: {
					absolute_monarchy_discontent: 5,
					fascism_discontent: 4,
					constitutional_monarchy_discontent: 3,
					democracy_discontent: 4,
					socialism_discontent: -8,
					communism_discontent: -10
				},
				effects: [
					["stability", 10],
					["pop_growth_modifier", 0.1],
					["reform_desire_gain", -0.05],
					["tax_efficiency", -0.1],
					["political_capital_gain", -2],
					["building_cost", 0.1],
					["training_cost", 0.1],
					["production_efficiency", 0.2]
				]
			}
		},
		healthcare: {
			name: "Healthcare",
			no_healthcare: {
				name: "No Healthcare",
				description: "It's the American way!",
				political_appeasement: {
					absolute_monarchy_discontent: -10,
					fascism_discontent: 1,
					constitutional_monarchy_discontent: 6,
					democracy_discontent: 1,
					socialism_discontent: 8,
					communism_discontent: 6
				},
				effects: [
					["stability", -5],
					["pop_growth_modifier", -0.05],
					["reform_desire_gain", 0.05],
					["tax_efficiency", 0.15]
				]
			},
			trinket_healthcare: {
				name: "Trinket Healthcare",
				description: "If we can't afford to set up even the most rudimentary of healthcare services, at least we can put some 'nurses' in our schools and call it a day!",
				political_appeasement: {
					absolute_monarchy_discontent: -8,
					fascism_discontent: -1,
					constitutional_monarchy_discontent: 5,
					democracy_discontent: -1,
					socialism_discontent: 7,
					communism_discontent: 6
				},
				effects: [
					["stability", -2],
					["pop_growth_modifier", -0.04],
					["reform_desire_gain", 0.04],
					["tax_efficiency", 0.12]
				]
			},
			low_healthcare: {
				name: "Low Healthcare",
				description: "By providing rudimentary services to the general public, and making the healthcare system free for those in emergency situations only, we can at least trim down some of the excess casualties.",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: -1,
					constitutional_monarchy_discontent: 2,
					democracy_discontent: -3,
					socialism_discontent: 6,
					communism_discontent: 5
				},
				effects: [
					["pop_growth_modifier", -0.02],
					["reform_desire_gain", 0.02],
					["tax_efficiency", 0.05]
				]
			},
			acceptable_healthcare: {
				name: "Acceptable Healthcare",
				description: "Don't socialise my healthcare!",
				political_appeasement: {
					absolute_monarchy_discontent: 3,
					fascism_discontent: 2,
					constitutional_monarchy_discontent: 0,
					democracy_discontent: -3,
					socialism_discontent: 3,
					communism_discontent: 2
				},
				effects: [
					["stability", 5],
					["pop_growth_modifier", 0.02],
					["tax_efficiency", -0.02]
				]
			},
			good_healthcare: {
				name: "Good Healthcare",
				description: "By making our nation a world model for healthcare, we can avoid the worst of public health crises and ensure stability for those in our nation at the cost of the taxpayer.",
				political_appeasement: {
					absolute_monarchy_discontent: 4,
					fascism_discontent: 2,
					constitutional_monarchy_discontent: 1,
					democracy_discontent: -3,
					socialism_discontent: -6,
					communism_discontent: -6
				},
				effects: [
					["stability", 10],
					["pop_growth_modifier", 0.05],
					["tax_efficiency", -0.05],
					["reform_desire_gain", -0.02],
					["political_capital_gain", -1]
				]
			}
		},
		school_system: {
			name: "School System",
			no_school_system: {
				name: "No School System",
				description: "Sometimes the best schooling is homeschooling.",
				political_appeasement: {
					absolute_monarchy_discontent: 2,
					fascism_discontent: -3,
					constitutional_monarchy_discontent: 6,
					democracy_discontent: 6,
					socialism_discontent: 8,
					communism_discontent: 8
				},
				effects: [
					["stability", -10],
					["pop_growth_modifier", 0.05],
					["tax_efficiency", 0.15],
					["political_capital_gain", -2],
					["research_efficiency", -0.2],
					["reform_desire_gain", 0.03]
				]
			},
			basic_school_system: {
				name: "Basic School System",
				description: "By giving our nation's children at least basic literacy skills, we can ensure a more competent workforce in the future.",
				political_appeasement: {
					absolute_monarchy_discontent: -1,
					fascism_discontent: -1,
					constitutional_monarchy_discontent: 5,
					democracy_discontent: 4,
					socialism_discontent: 7,
					communism_discontent: 7
				},
				effects: [
					["stability", -5],
					["pop_growth_modifier", 0.04],
					["tax_efficiency", 0.1],
					["political_capital_gain", -1],
					["research_efficiency", -0.15],
					["reform_desire_gain", 0.01]
				]
			},
			acceptable_school_system: {
				name: "Acceptable School System",
				description: "An acceptable school system will teach our children at least primary education and ensure a basic academic base to build our future research prospects off of.",
				political_appeasement: {
					absolute_monarchy_discontent: 1,
					fascism_discontent: 2,
					constitutional_monarchy_discontent: 1,
					democracy_discontent: 0,
					socialism_discontent: 3,
					communism_discontent: 4
				},
				effects: [
					["pop_growth_modifier", 0.03],
					["tax_efficiency", 0.05],
					["research_efficiency", -0.06]
				]
			},
			good_school_system: {
				name: "Good School System",
				description: "A good school system will not only allow for secondary education for our students, but will also ensure that they can be taught to love our government and support our country ... for some monetary cost, of course.",
				political_appeasement: {
					absolute_monarchy_discontent: 3,
					fascism_discontent: 3,
					constitutional_monarchy_discontent: -2,
					democracy_discontent: -3,
					socialism_discontent: 2,
					communism_discontent: 2
				},
				effects: [
					["stability", 5],
					["tax_efficiency", -0.05],
					["political_capital_gain", 1],
					["research_efficiency", 0.05]
				]
			},
			mandatory_schooling: {
				name: "Mandatory Schooling",
				description: "Mandatory schooling will forcibly place our nation's children into a learning environment where we can instill in them values and ideals that reflect those of our nation, and with post-secondary education being made available, a good scientific base to build off of.",
				political_appeasement: {
					absolute_monarchy_discontent: 8,
					fascism_discontent: 5,
					constitutional_monarchy_discontent: -5,
					democracy_discontent: 2,
					socialism_discontent: -8,
					communism_discontent: -8
				},
				effects: [
					["stability", 10],
					["tax_efficiency", -0.1],
					["political_capital_gain", 3],
					["pop_growth_modifier", -0.05],
					["research_efficiency", 0.2]
				]
			}
		},
		penal_system: {
			name: "Penal System",
			capital_punishment: {
				name: "Capital Punishment",
				description: "Although some citizens may call it the 'Bloody Code', capital punishment for even the lightest of crimes is the only surefire way to prevent crime from breeding.",
				political_appeasement: {
					absolute_monarchy_discontent: -8,
					fascism_discontent: -8,
					constitutional_monarchy_discontent: -4,
					democracy_discontent: -3,
					socialism_discontent: 4,
					communism_discontent: 3
				},
				effects: [
					["stability", 5],
					["reform_desire_gain", 0.1],
					["training_cost", -0.05],
					["pop_growth_modifier", -0.03],
					["infamy_loss", 0.02]
				]
			},
			penal_labour: {
				name: "Penal Labour",
				description: "In order to rehabilitate our prisoners back to society, we shall place them in forced work camps, where they shall contribute towards making valuable products that our society wants and needs.",
				political_appeasement: {
					absolute_monarchy_discontent: -8,
					fascism_discontent: -6,
					constitutional_monarchy_discontent: 2,
					democracy_discontent: 1,
					socialism_discontent: 3,
					communism_discontent: 3
				},
				effects: [
					["stability", 3],
					["reform_desire_gain", 0.05],
					["training_cost", -0.02],
					["pop_growth_modifier", -0.02],
					["infamy_loss", 0.01]
				]
			},
			incarceration: {
				name: "Incarceration",
				description: "Simply arresting individuals and throwing them in gaols and prisons is more than enough to stop any wave of crime.",
				political_appeasement: {
					absolute_monarchy_discontent: -2,
					fascism_discontent: -3,
					constitutional_monarchy_discontent: 0,
					democracy_discontent: 0,
					socialism_discontent: 2,
					communism_discontent: 2
				},
				effects: [
					["reform_desire_gain", 0.02],
					["training_cost", -0.02]
				]
			},
			rehabilitation: {
				name: "Rehabilitation",
				description: "By rehabilitating our prisoners, we may be able to reintroduce them back into society, and thereby, the workforce, at a later date when they are deemed safe for release.",
				political_appeasement: {
					absolute_monarchy_discontent: 2,
					fascism_discontent: 1,
					constitutional_monarchy_discontent: 0,
					democracy_discontent: 0,
					socialism_discontent: -5,
					communism_discontent: -5
				},
				effects: [
					["stability", -5],
					["reform_desire_gain", -0.02],
					["training_cost", 0.05],
					["pop_growth_modifier", 0.04],
					["tax_efficiency", 0.03],
					["infamy_loss", -0.02]
				]
			}
		},
		political_parties: {
			name: "Political Parties",
			only_underground: {
				name: "Only Underground",
				description: "We shall take every opportunity to crack down on political dissent and impose a one-party state.",
				political_appeasement: {
					absolute_monarchy_discontent: -5,
					fascism_discontent: -10,
					constitutional_monarchy_discontent: 10,
					democracy_discontent: 8,
					socialism_discontent: 9,
					communism_discontent: -8
				},
				effects: [
					["stability", 10],
					["reform_desire_gain", 0.05],
					["political_capital_gain", 5]
				]
			},
			harassment: {
				name: "Harassment",
				description: "As domestic and international criticism begins to ramp up, we recognise that it may be necessary to implement some new reforms, although we'll be sure to keep the opposition on a short leash still.",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: -5,
					constitutional_monarchy_discontent: 8,
					democracy_discontent: 7,
					socialism_discontent: 8,
					communism_discontent: -5
				},
				effects: [
					["stability", 5]
					["reform_desire_gain", 0.03],
					["political_capital_gain", 3]
				]
			},
			gerrymandering: {
				name: "Gerrymandering",
				description: "'Can we have some more funds for redistricting maps, please?'",
				political_appeasement: {
					absolute_monarchy_discontent: -1,
					fascism_discontent: -2,
					constitutional_monarchy_discontent: 5,
					democracy_discontent: 6,
					socialism_discontent: 7,
					communism_discontent: -3
				},
				effects: [
					["reform_desire_gain", 0.02],
					["political_capital_gain", 2]
				]
			},
			non_secret_ballots: {
				name: "Non-Secret Ballots",
				description: "They're secret, just an open secret! Oh, and we're taking notes by the way ...",
				political_appeasement: {
					absolute_monarchy_discontent: 1,
					fascism_discontent: 0,
					constitutional_monarchy_discontent: 3,
					democracy_discontent: 4,
					socialism_discontent: 5,
					communism_discontent: -1
				},
				effects: [
					["stability", -5],
					["reform_desire_gain", 0.01],
					["political_capital_gain", 1]
				]
			},
			secret_ballots: {
				name: "Secret Ballots",
				description: "We can only have a free and fair democracy by ensuring that each of our voters are able to vote securely and therefore for the candidate that they feel will serve their job best.",
				political_appeasement: {
					absolute_monarchy_discontent: 3,
					fascism_discontent: 4,
					constitutional_monarchy_discontent: -7,
					democracy_discontent: -6,
					socialism_discontent: -3,
					communism_discontent: 5
				},
				effects: [
					["stability", -10],
					["reform_desire_gain", -0.02],
					["political_capital_gain", -1],
					["constitutional_monarchy", 3],
					["democracy", 3],
					["socialism", 2]
				]
			}
		},
		upper_house: {
			name: "Upper House",
			ruling_party_only: {
				name: "Ruling Party Only",
				description: "Why have an upper house when you can simply be a dictatorship?",
				political_appeasement: {
					absolute_monarchy_discontent: -8,
					fascism_discontent: -10,
					constitutional_monarchy_discontent: 8,
					democracy_discontent: 8,
					socialism_discontent: 5,
					communism_discontent: -10
				},
				effects: [
					["stability", 15],
					["reform_desire_gain", 0.05],
					["political_capital_gain", 5]
				]
			},
			appointed: {
				name: "Appointed",
				description: "By simply appointing the upper house of our legislature, we can ensure that only the Acts which suit our own interest pass Parliament.",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: -2,
					constitutional_monarchy_discontent: 4,
					democracy_discontent: 7,
					socialism_discontent: 5,
					communism_discontent: -2
				},
				effects: [
					["stability", 10],
					["reform_desire_gain", 0.03],
					["political_capital_gain", 3],
					["constitutional_monarchy", 2]
				]
			},
			two_per_state: {
				name: "Two Per State",
				description: "We can prevent the inevitable outcome of the 'tyranny of the majority' in a completely democratic society by giving each state an equal say.",
				political_appeasement: {
					absolute_monarchy_discontent: 3,
					fascism_discontent: 2,
					constitutional_monarchy_discontent: 2,
					democracy_discontent: -3,
					socialism_discontent: 2,
					communism_discontent: 3
				},
				effects: [
					["stability", 5],
					["reform_desire_gain", 0.01],
					["political_capital_gain", 1],
					["democracy", 3]
				]
			},
			based_on_population: {
				name: "Based on Population",
				description: "Although many on the right are against this proposal, our government believes that only votes based on population will ensure a fair result.",
				political_appeasement: {
					absolute_monarchy_discontent: 5,
					fascism_discontent: 4,
					constitutional_monarchy_discontent: -5,
					democracy_discontent: -2,
					socialism_discontent: -3,
					communism_discontent: 4
				},
				effects: [
					["stability", -5],
					["reform_desire_gain", -0.01],
					["political_capital_gain", -1],
					["constitutional_monarchy", 3],
					["democracy", 2],
					["socialism", 1]
				]
			}
		},
		conscription: {
			name: "Conscription",
			service_by_requirement: {
				name: "Service by Requirement",
				description: "The only sure way to maximise our manpower is service by requirement, although people may choose to emigrate instead, and all the training is sucking our coffers dry.",
				political_appeasement: {
					absolute_monarchy_discontent: -5,
					fascism_discontent: -15,
					constitutional_monarchy_discontent: 5,
					democracy_discontent: 5,
					socialism_discontent: 7,
					communism_discontent: -5
				},
				effects: [
					["stability", 5],
					["national_manpower", 0.2],
					["training_cost", -0.2],
					["tax_efficiency", -0.1],
					["pop_growth_modifier", -0.02],
					["political_capital_gain", 1],
					["fascism", 1],
					["absolute_monarchy", 1]
				]
			},
			four_year_draft: {
				name: "Four Year Draft",
				description: "By implementing a four year draft, we can help alleviate the training costs when it finally comes time to mobilise our population for the war effort.",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: -12,
					constitutional_monarchy_discontent: 4,
					democracy_discontent: 4,
					socialism_discontent: 6,
					communism_discontent: -3
				},
				effects: [
					["stability", 3],
					["national_manpower", 0.15],
					["training_cost", -0.2],
					["tax_efficiency", -0.05],
					["pop_growth_modifier", -0.02],
					["fascism", 1],
					["absolute_monarchy", 1]
				]
			},
			two_year_draft: {
				name: "Two Year Draft",
				description: "A two year draft will help ensure at least basic training for all males of fighting age in our country at reduced cost.",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: -6,
					constitutional_monarchy_discontent: 3,
					democracy_discontent: 3,
					socialism_discontent: 5,
					communism_discontent: -3
				},
				effects: [
					["stability", 1],
					["national_manpower", 0.1],
					["training_cost", -0.15],
					["tax_efficiency", -0.03],
					["pop_growth_modifier", -0.01],
					["fascism", 1],
					["absolute_monarchy", 1]
				]
			},
			one_year_draft: {
				name: "One Year Draft",
				description: "A one year draft, whilst not enough for advanced military training, will help reduce future training costs somewhat whilst keeping expenditures and draft dodging minimal.",
				political_appeasement: {
					absolute_monarchy_discontent: -1,
					fascism_discontent: -2,
					constitutional_monarchy_discontent: 2,
					democracy_discontent: 2,
					socialism_discontent: 4,
					communism_discontent: -1
				},
				effects: [
					["national_manpower", 0.1],
					["training_cost", -0.1],
					["tax_efficiency", -0.01],
					["pop_growth_modifier", -0.01]
				]
			},
			no_draft: {
				name: "No Draft",
				description: "Whilst not having a draft implemented in our nation is sure to drive down draft dodging, concerns are growing over whether it could lead to pacifism running rampant amongst our populace.",
				political_appeasement: {
					absolute_monarchy_discontent: 3,
					fascism_discontent: 0,
					constitutional_monarchy_discontent: -3,
					democracy_discontent: -3,
					socialism_discontent: -4,
					communism_discontent: 0
				},
				effects: [
					["tax_efficiency", 0.05],
					["national_manpower", -0.05],
					["pop_growth_modifier", 0.05],
					["political_capital_gain", -1],
					["infamy_loss", -0.05],
					["democracy", 1],
					["constitutional_monarchy", 1],
					["socialism", 2]
				]
			}
		},
		trade_unions: {
			name: "Trade Unions",
			illegal: {
				name: "Illegal",
				description: "Our factory owners and businessmen could do better without the Red Hydra lurking around the corners ready to threaten them with strikes for not raising wages to ludicrous levels.",
				political_appeasement: {
					absolute_monarchy_discontent: -4,
					fascism_discontent: -5,
					constitutional_monarchy_discontent: -2,
					democracy_discontent: -1,
					socialism_discontent: 8,
					communism_discontent: 8
				},
				effects: [
					["stability", -5],
					["tax_efficiency", 0.05],
					["rgo_throughput", 0.02],
					["production_efficiency", 0.1],
					["political_capital_gain", 2],
					["extra_building_slots", 3],
					["reform_desire_gain", 0.03]
				]
			},
			guilds: {
				name: "Guilds",
				description: "Although we should allow some organised labour, further concessions to the unions could lead to more strikes and unrest across our country. 'Give them an inch, and they want a mile'.",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: -4,
					constitutional_monarchy_discontent: -1,
					democracy_discontent: -1,
					socialism_discontent: 6,
					communism_discontent: 7
				},
				effects: [
					["stability", -2],
					["tax_efficiency", 0.03],
					["rgo_throughput", 0.01],
					["production_efficiency", 0.05],
					["political_capital_gain", 1],
					["extra_building_slots", 2],
					["reform_desire_gain", 0.02]
				]
			},
			state_controlled: {
				name: "State Controlled",
				description: "State-controlled unions are a good way to make sure that unions stay friendly and don't strike during times critical to our nation. Or so the line of reasoning goes.",
				political_appeasement: {
					absolute_monarchy_discontent: -4,
					fascism_discontent: -6,
					constitutional_monarchy_discontent: 1,
					democracy_discontent: 0,
					socialism_discontent: 5,
					communism_discontent: 5
				},
				effects: [
					["stability", 5],
					["tax_efficiency", 0.05],
					["rgo_throughput", 0.1],
					["production_efficiency", 0.1],
					["political_capital_gain", 2],
					["extra_building_slots", 2],
					["reform_desire_gain", 0.04]
				]
			},
			non_socialist_allowed: {
				name: "Non-Socialist Allowed",
				description: "If we strike before the Red Hydra can grow its first head, we won't have to worry about the rest.",
				political_appeasement: {
					absolute_monarchy_discontent: 2,
					fascism_discontent: 3,
					constitutional_monarchy_discontent: 1,
					democracy_discontent: 0,
					socialism_discontent: 4,
					communism_discontent: 5
				},
				effects: [
					["stability", -5],
					["tax_efficiency", -0.05],
					["rgo_throughput", -0.05],
					["production_efficiency", 0.1],
					["political_capital_gain", 1],
					["extra_building_slots", 1],
					["reform_desire_gain", 0.01]
				]
			},
			all_allowed: {
				name: "All Allowed",
				description: "Organised labour should have a seat at the table, and militia should not be sent in to machine gun down strikers as violence involving socialist trade unions has recently come to a head.",
				political_appeasement: {
					absolute_monarchy_discontent: 5,
					fascism_discontent: 8,
					constitutional_monarchy_discontent: 1,
					democracy_discontent: 2,
					socialism_discontent: -9,
					communism_discontent: -10
				},
				effects: [
					["stability", -10],
					["tax_efficiency", -0.1],
					["rgo_throughput", -0.1],
					["production_efficiency", -0.05],
					["political_capital_gain", 1],
					["extra_building_slots", 5],
					["reform_desire_gain", -0.05],
					["socialism", 2],
					["communism", 2]
				]
			}
		},
		vote_franchise: {
			name: "Vote Franchise",
			no_voting: {
				name: "No Voting",
				description: "Why have a democracy?",
				political_appeasement: {
					absolute_monarchy_discontent: -10,
					fascism_discontent: -10,
					constitutional_monarchy_discontent: 7,
					democracy_discontent: 8,
					socialism_discontent: 6,
					communism_discontent: -10
				},
				effects: [
					["stability", 5],
					["political_capital_gain", 2],
					["army_upkeep", 0.05],
					["reform_desire_gain", 0.05],
					["infamy_loss", 0.04],
					["absolute_monarchy", 1],
					["fascism", 1],
					["communism", 1]
				]
			},
			only_landed: {
				name: "Only Landed",
				description: "We should make it so that only the landed gentry and those of high intelligence in our country are allowed to vote, as the common people simply can't be trusted to elect their own leaders.",
				political_appeasement: {
					absolute_monarchy_discontent: -8,
					fascism_discontent: -3,
					constitutional_monarchy_discontent: 5,
					democracy_discontent: 7,
					socialism_discontent: 5,
					communism_discontent: -7
				},
				effects: [
					["stability", 2],
					["political_capital_gain", 1],
					["reform_desire_gain", 0.04],
					["infamy_loss", 0.03],
					["absolute_monarchy", 1],
					["constitutional_monarchy", 1]
				]
			},
			weighted_wealth: {
				name: "Weighted Wealth",
				description: "Only those who own land and are of the majority ethnicity should be allowed to vote in this country, and greater emphasis should be placed on the aristocracy.",
				political_appeasement: {
					absolute_monarchy_discontent: -6,
					fascism_discontent: -1,
					constitutional_monarchy_discontent: 4,
					democracy_discontent: 5,
					socialism_discontent: 4,
					communism_discontent: -3
				},
				effects: [
					["stability", 3],
					["political_capital_gain", 1],
					["reform_desire_gain", 0.05],
					["infamy_loss", 0.02],
					["absolute_monarchy", 1],
					["constitutional_monarchy", 1],
					["democracy", 1]
				]
			},
			wealth: {
				name: "Wealth",
				description: "Any landowing gentleman in this realm should be given the vote.",
				political_appeasement: {
					absolute_monarchy_discontent: -5,
					fascism_discontent: 0,
					constitutional_monarchy_discontent: 2,
					democracy_discontent: 3,
					socialism_discontent: 3,
					communism_discontent: -5
				},
				effects: [
					["stability", 1],
					["reform_desire_gain", 0.03],
					["tax_efficiency", 0.05],
					["absolute_monarchy", 1],
					["constitutional_monarchy", 1],
					["democracy", 2]
				]
			},
			weighted_universal: {
				name: "Weighted Universal",
				description: "Although everyone should be given the vote, it might be wise to balance out our country's electoral system with an electoral college to make sure that everyone's views are represented.",
				political_appeasement: {
					absolute_monarchy_discontent: 5,
					fascism_discontent: 4,
					constitutional_monarchy_discontent: 0,
					democracy_discontent: 0,
					socialism_discontent: 2,
					communism_discontent: 4
				},
				effects: [
					["reform_desire_gain", -0.01],
					["tax_efficiency", 0.07],
					["absolute_monarchy", 1],
					["constitutional_monarchy", 2],
					["democracy", 4],
					["socialism", 1]
				]
			},
			universal: {
				name: "Universal",
				description: "One man, one vote.",
				political_appeasement: {
					absolute_monarchy_discontent: 5,
					fascism_discontent: 4,
					constitutional_monarchy_discontent: 0,
					democracy_discontent: 0,
					socialism_discontent: 2,
					communism_discontent: 4
				},
				effects: [
					["stability", -5],
					["reform_desire_gain", -0.04],
					["infamy_loss", -0.05],
					["tax_efficiency", 0.1],
					["constitutional_monarchy", 2],
					["democracy", 5],
					["socialism", 2]
				]
			}
		},
		slavery: {
			name: "Slavery",
			upheld: {
				name: "Upheld",
				description: "Everyone knows that slavery is necessary for the continued existence of our state, and not only is it necessary, but it is the ethical choice to make, as anyone who's ever read the Curse of Ham would know.",
				political_appeasement: {
					absolute_monarchy_discontent: -2,
					fascism_discontent: -9,
					constitutional_monarchy_discontent: 5,
					democracy_discontent: 4,
					socialism_discontent: 8,
					communism_discontent: 10
				},
				effects: [
					["stability", -5],
					["reform_desire_gain", 0.1],
					["infamy_loss", 0.02],
					["tax_efficiency", 0.1],
					["production_efficiency", 0.15],
					["rgo_throughput", 0.1],
					["national_manpower", -0.1],
					["building_cost", -0.2],
					["research_efficiency", -0.2]
				]
			},
			allowed: {
				name: "Allowed",
				description: "Whilst we won't go as far as to openly promote the morality of slavery, we will simply allow it in order to allow the continuation of the flow of raw resources to our industry, no matter the cost.",
				political_appeasement: {
					absolute_monarchy_discontent: -1,
					fascism_discontent: -8,
					constitutional_monarchy_discontent: 4,
					democracy_discontent: 5,
					socialism_discontent: 7,
					communism_discontent: 9
				},
				effects: [
					["stability", -8],
					["reform_desire_gain", 0.12],
					["tax_efficiency", 0.08],
					["production_efficiency", 0.15],
					["rgo_throughput", 0.1],
					["national_manpower", -0.1],
					["building_cost", -0.15],
					["research_efficiency", -0.15]
				]
			},
			freedom_of_womb: {
				name: "Freedom of Womb",
				description: "As slavery leaves a moral mark on our society, we should seek to phase it out gradually to ensure that the slaveholders in our country don't get too upset ...",
				political_appeasement: {
					absolute_monarchy_discontent: 1,
					fascism_discontent: 3,
					constitutional_monarchy_discontent: 3,
					democracy_discontent: 3,
					socialism_discontent: 6,
					communism_discontent: 8
				},
				effects: [
					["stability", -5],
					["reform_desire_gain", 0.05],
					["tax_efficiency", 0.05],
					["production_efficiency", 0.1],
					["rgo_throughput", 0.1],
					["national_manpower", -0.05],
					["building_cost", -0.1],
					["research_efficiency", -0.1]
				]
			},
			partial_abolition: {
				name: "Partial Abolition",
				description: "Partial abolition refers to the plan by which we will gradually phase out slavery in this country and transition to a free society.",
				political_appeasement: {
					absolute_monarchy_discontent: 3,
					fascism_discontent: 5,
					constitutional_monarchy_discontent: 1,
					democracy_discontent: 1,
					socialism_discontent: 4,
					communism_discontent: 6
				},
				effects: [
					["reform_desire_gain", 0.02],
					["tax_efficiency", 0.05],
					["production_efficiency", 0.05],
					["rgo_throughput", 0.05],
					["building_cost", -0.05],
					["research_efficiency", -0.1]
				]
			},
			outlawed: {
				name: "Outlawed",
				description: "Slavery should be outlawed everywhere. 'Am I not a man and also a brother?'",
				political_appeasement: {
					absolute_monarchy_discontent: 3,
					fascism_discontent: 6,
					constitutional_monarchy_discontent: -3,
					democracy_discontent: -4,
					socialism_discontent: -5,
					communism_discontent: -5
				},
				effects: [
					["national_manpower", 0.1],
					["rgo_throughput", 0.05],
					["research_efficiency", 0.1]
				]
			}
		},
		voting_system: {
			name: "Voting System",
			no_voting_system: {
				name: "No Voting System",
				description: "Dictatorship, trollface.",
				political_appeasement: {
					absolute_monarchy_discontent: -10,
					fascism_discontent: -10,
					constitutional_monarchy_discontent: 5,
					democracy_discontent: 8,
					socialism_discontent: 8,
					communism_discontent: -10
				},
				effects: [
					["stability", 10],
					["absolute_monarchy", 2],
					["fascism", 2],
					["communism", 2],
					["reform_desire_gain", 0.05]
				]
			},
			first_past_the_post: {
				name: "First Past The Post",
				description: "Reforms to our voting system could greatly change the political landscape of our democracy. First Past the Post, or FPTP, therefore, is the most secure as it is the most widely used.",
				political_appeasement: {
					absolute_monarchy_discontent: 3,
					fascism_discontent: 5,
					constitutional_monarchy_discontent: -1,
					democracy_discontent: -2,
					socialism_discontent: 3,
					communism_discontent: 5
				},
				effects: [
					["stability", 5],
					["reform_desire_gain", 0.01],
					["democracy", 5],
					["constitutional_monarchy", 4],
					["socialism", 1]
				]
			},
			jefferson_method: {
				name: "Jefferson Method",
				description: "By weighting our voting methods, we can ensure that seats to our Lower House are fairly allocated amongst our states.",
				political_appeasement: {
					absolute_monarchy_discontent: 5,
					fascism_discontent: 6,
					constitutional_monarchy_discontent: 1,
					democracy_discontent: -4,
					socialism_discontent: 2,
					communism_discontent: 5
				},
				effects: [
					["reform_desire_gain", -0.01],
					["democracy", 6],
					["constitutional_monarchy", 4],
					["socialism", 1]
				]
			},
			proportional_representation: {
				name: "Proportional Representation",
				description: "Via proportional representation, we can ensure a wealth and diversity of opinions amongst the enfranchised, if at least nothing else, which can help improve our governmental stability and decrease cynicism.",
				political_appeasement: {
					absolute_monarchy_discontent: 6,
					fascism_discontent: 6,
					constitutional_monarchy_discontent: -2,
					democracy_discontent: -5,
					socialism_discontent: -2,
					communism_discontent: 6
				},
				effects: [
					["political_capital_gain", 4],
					["reform_desire_gain", -0.03],
					["democracy", 8],
					["constitutional_monarchy", 5],
					["socialism", 3]
				]
			}
		},
		public_meetings: {
			name: "Public Meetings",
			meetings_not_allowed: {
				name: "Meetings Not Allowed",
				description: "Although freedom of assembly might sure sound nice, few contemplate the potential loss of stability that our state could suffer from implementing it, and fewer still the administrative burden that it would place amongst our governors. Therefore, we should restrict it.",
				political_appeasement: {
					absolute_monarchy_discontent: -7,
					fascism_discontent: -5,
					constitutional_monarchy_discontent: 5,
					democracy_discontent: 4,
					socialism_discontent: 6,
					communism_discontent: 5
				},
				effects: [
					["political_capital_gain", 3],
					["stability", 10],
					["reform_desire_gain", 0.05],
					["production_efficiency", 0.05],
					["rgo_throughput", 0.05],
					["training_cost", 0.1]
				]
			},
			some_meetings_tolerated: {
				name: "Some Meetings Tolerated",
				description: "As the number of unsanctioned and thereby illegal protests grow, we might be forced to tolerate some of the larger ones, as a brutal massacre would rile the population against us.",
				political_appeasement: {
					absolute_monarchy_discontent: -4,
					fascism_discontent: 1,
					constitutional_monarchy_discontent: 4,
					democracy_discontent: 3,
					socialism_discontent: 5,
					communism_discontent: 5
				},
				effects: [
					["political_capital_gain", 1],
					["stability", -5],
					["reform_desire_gain", 0.07],
					["production_efficiency", 0.02],
					["rgo_throughput", 0.03],
					["training_cost", 0.15]
				]
			},
			meetings_allowed: {
				name: "Meetings Allowed",
				description: "In order to maintain a truly democratic society, we must allow freedom of assembly in public in order to safeguard our freedoms and ensure that each of our citizens has a voice.",
				political_appeasement: {
					absolute_monarchy_discontent: 1,
					fascism_discontent: 2,
					constitutional_monarchy_discontent: -4,
					democracy_discontent: -6,
					socialism_discontent: -5,
					communism_discontent: 7
				},
				effects: [
					["reform_desire_gain", 0.02],
					["production_efficiency", -0.05],
					["rgo_throughput", -0.02],
					["democracy", 3],
					["constitutional_monarchy", 3],
					["socialism", 1]
				]
			}
		},
		child_labour: {
			name: "Child Labour",
			child_labour_encouraged: {
				name: "Child Labour Encouraged",
				description: "By encouraging our children to work in the factories, we can instill in them a valuable work ethic that will surely be of great use to us in the future ... although some of them will inevitably be injured in the process.",
				political_appeasement: {
					absolute_monarchy_discontent: 1,
					fascism_discontent: -2,
					constitutional_monarchy_discontent: 4,
					democracy_discontent: 4,
					socialism_discontent: 5,
					communism_discontent: 4
				},
				effects: [
					["stability", -5],
					["reform_desire_gain", 0.03],
					["tax_efficiency", 0.05],
					["production_efficiency", 0.05],
					["building_cost", -0.05],
					["training_cost", -0.05],
					["pop_growth_modifier", -0.05],
					["research_efficiency", -0.05]
				]
			},
			child_labour_legal: {
				name: "Child Labour Legal",
				description: "Although the moral efficacy of using child labour might be questionable, it sure is a boon to our businesses, and so we should only socially encourage parents to withdraw their children from unsafe working conditions.",
				political_appeasement: {
					absolute_monarchy_discontent: -2,
					fascism_discontent: -1,
					constitutional_monarchy_discontent: 3,
					democracy_discontent: 3,
					socialism_discontent: 4,
					communism_discontent: 3
				},
				effects: [
					["stability", -2],
					["reform_desire_gain", 0.02],
					["tax_efficiency", 0.06],
					["production_efficiency", 0.04],
					["building_cost", -0.03],
					["training_cost", -0.03],
					["pop_growth_modifier", -0.02],
					["research_efficiency", -0.04]
				]
			},
			child_labour_discouraged: {
				name: "Child Labour Discouraged",
				description: "It might also be wise to start public information campaigns about the dangers of child labour in order to prevent even more parents from sending their children to the mills where they could be injured or worse in an effort to preserve our population, even with the maluses it may come with.",
				political_appeasement: {
					absolute_monarchy_discontent: -2,
					fascism_discontent: -1,
					constitutional_monarchy_discontent: 3,
					democracy_discontent: 3,
					socialism_discontent: 4,
					communism_discontent: 3
				},
				effects: [
					["stability", -5],
					["reform_desire_gain", 0.03],
					["tax_efficiency", 0.03],
					["production_efficiency", 0.02],
					["research_efficiency", -0.04],
					["national_manpower", 0.02]
				]
			},
			child_labour_restricted: {
				name: "Child Labour Restricted",
				description: "By beginning to restrict child labour only to 'safe jobs', we can help reduce the epidemic of maiming and lost limbs that abound amongst our young.",
				political_appeasement: {
					absolute_monarchy_discontent: 3,
					fascism_discontent: 1,
					constitutional_monarchy_discontent: -1,
					democracy_discontent: -1,
					socialism_discontent: 3,
					communism_discontent: 2
				},
				effects: [
					["stability", 5],
					["reform_desire_gain", 0.01],
					["tax_efficiency", 0.01],
					["production_efficiency", 0.02],
					["research_efficiency", -0.03],
					["pop_growth_modifier", 0.01],
					["national_manpower", 0.05]
				]
			},
			child_labour_illegal: {
				name: "Child Labour Illegal",
				description: "Criminalising the usage of child labour, whilst damaging for our economy in the short term, could provide a population and academic base to build off of when combined with mandatory schooling.",
				political_appeasement: {
					absolute_monarchy_discontent: 4,
					fascism_discontent: 2,
					constitutional_monarchy_discontent: -3,
					democracy_discontent: -2,
					socialism_discontent: -3,
					communism_discontent: -4
				},
				effects: [
					["stability", 7],
					["research_efficiency", 0.1],
					["pop_growth_modifier", 0.05],
					["national_manpower", 0.07]
				]
			}
		},
		bureaucracy: {
			name: "Bureaucracy",
			gentry: {
				name: "Gentry",
				description: "By restricting our bureaucratic positions to aristocrats only, we can ensure that an entire category of men are raised to adulthood with the sole purpose of serving as competent administrators.",
				political_appeasement: {
					absolute_monarchy_discontent: -15,
					fascism_discontent: 3,
					constitutional_monarchy_discontent: -3,
					democracy_discontent: 5,
					socialism_discontent: 8,
					communism_discontent: 10
				},
				effects: [
					["stability", 5],
					["reform_desire_gain", 0.05],
					["tax_efficiency", 0.1],
					["political_capital_gain", 3],
					["army_upkeep", 0.05],
					["building_cost", -0.05],
					["training_cost", 0.02],
					["research_efficiency", -0.05]
				]
			},
			hereditary_bureaucracy: {
				name: "Hereditary Bureaucracy",
				description: "Although our bureaucracy may theoretically be open to anyone, in reality, it is comprised out of the descendants of noble families and those lucky enough to have passed the exams required to become an administrator.",
				political_appeasement: {
					absolute_monarchy_discontent: -12,
					fascism_discontent: 2,
					constitutional_monarchy_discontent: -1,
					democracy_discontent: 4,
					socialism_discontent: 6,
					communism_discontent: 8
				},
				effects: [
					["stability", 3],
					["reform_desire_gain", 0.03],
					["tax_efficiency", -0.05],
					["political_capital_gain", 3],
					["army_upkeep", -0.02],
					["building_cost", 0.05],
					["training_cost", 0.02],
					["research_efficiency", -0.05]
				]
			},
			professional_civil_servants: {
				name: "Professional Civil Servants",
				description: "Professional civil servants are the backbone that lie underneath any great modern state, and should form the backbone of ours too, if we are to create a truly competent bureaucracy.",
				political_appeasement: {
					absolute_monarchy_discontent: 2,
					fascism_discontent: 3,
					constitutional_monarchy_discontent: -5,
					democracy_discontent: -4,
					socialism_discontent: -8,
					communism_discontent: -8
				},
				effects: [
					["stability", -5],
					["reform_desire_gain", -0.02],
					["tax_efficiency", 0.1],
					["political_capital_gain", 5],
					["army_upkeep", -0.05],
					["building_cost", -0.05],
					["training_cost", -0.02],
					["research_efficiency", 0.15]
				]
			}
		},
		political_rights: {
			name: "Political Rights",
			restricted_rights: {
				name: "Restricted Rights",
				description: "Political rights are best in small doses. And I mean small, alright.",
				political_appeasement: {
					absolute_monarchy_discontent: -5,
					fascism_discontent: -4,
					constitutional_monarchy_discontent: 2,
					democracy_discontent: 5,
					socialism_discontent: 4,
					communism_discontent: -3
				},
				effects: [
					["stability", 5],
					["political_capital_gain", 1],
					["reform_desire_gain", 0.02],
					["national_manpower", -0.05],
					["training_cost", 0.05],
					["unit_cost", 0.05],
					["extra_building_slots", -1]
				]
			},
			cultural_rights: {
				name: "Cultural Rights",
				description: "By enshrining the rights of at least some cultural minorities in our country, we may be able to ensure long-term stability and draw those not of our primary culture to our side, if nothing else.",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: 1,
					constitutional_monarchy_discontent: -2,
					democracy_discontent: -3,
					socialism_discontent: 3,
					communism_discontent: -3
				},
				effects: [
					["stability", 7],
					["political_capital_gain", 2],
					["reform_desire_gain", -0.05],
					["national_manpower", -0.02],
					["training_cost", 0.02],
					["unit_cost", 0.02],
					["extra_building_slots", 1]
				]
			},
			all_allowed_rights: {
				name: "All Allowed Rights",
				description: "All of our citizens shall be equal in this country, and enshrining that view point in none other than the public consciousness will help to solidify our nation's varicose reputation as a melting pot of cultures.",
				political_appeasement: {
					absolute_monarchy_discontent: 1,
					fascism_discontent: 5,
					constitutional_monarchy_discontent: -5,
					democracy_discontent: -4,
					socialism_discontent: -6,
					communism_discontent: -1
				},
				effects: [
					["stability", 10],
					["political_capital_gain", 3],
					["reform_desire_gain", -0.1],
					["national_manpower", 0.05],
					["training_cost", 0.05],
					["unit_cost", 0.05],
					["extra_building_slots", 3]
				]
			}
		},
		lgbtqia_rights: {
			name: "LGBTQIA Rights",
			outlawed: {
				name: "Outlawed",
				description: "'Also, you're gay, and they're homophobic, so ...'\n'Firstly, I'm not gay'.\n'Yes, you are'.",
				political_appeasement: {
					absolute_monarchy_discontent: -5,
					fascism_discontent: -7,
					constitutional_monarchy_discontent: 4,
					democracy_discontent: 6,
					socialism_discontent: 6,
					communism_discontent: 2
				},
				effects: [
					["stability", 5],
					["reform_desire_gain", 0.02],
					["national_manpower", -0.05],
					["infamy_loss", -0.01],
					["constitutional_monarchy", 1],
					["fascism", 1]
				]
			},
			decriminalised: {
				name: "Decriminalised",
				description: "'Well, we've stopped throwing the gays in prison, which has got to be progress, right?'\n'Wait, why and how do they have seven letters for the same sexuality?'\n'Why are you gay?'\n\nI wish I lived in more enlightened times, away from the wacky world of Ugandan telly ...",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: -3,
					constitutional_monarchy_discontent: 2,
					democracy_discontent: 2,
					socialism_discontent: 3,
					communism_discontent: 1
				},
				effects: [
					["stability", -5],
					["reform_desire_gain", 0.01],
					["constitutional_monarchy", 1],
					["democracy", 1],
					["socialism", 1]
				]
			},
			accepted: {
				name: "Accepted",
				description: "'At the end of the day, they're our fellow countrymen, and they're not really any different from any of us - we see no reason to exclude them from military service, and we believe that society should treat them as they would any other person'.",
				political_appeasement: {
					absolute_monarchy_discontent: 5,
					fascism_discontent: 6,
					constitutional_monarchy_discontent: -2,
					democracy_discontent: -4,
					socialism_discontent: -5,
					communism_discontent: 2
				},
				effects: [
					["stability", 5],
					["reform_desire_gain", 0.01],
					["national_manpower", 0.05],
					["infamy_loss", 0.01],
					["constitutional_monarchy", 1],
					["democracy", 2],
					["socialism", 2]
				]
			}
		},
		press_rights: {
			name: "Press Rights",
			state_press_only: {
				name: "State Press Only",
				description: "You know, it's a real shame private broadcasting networks have a tendency to not accept all our rubbish propaganda. Now, the solution here is obvious: nationalising all of them and merging them into our very own state broadcaster. I'm sure you wouldn't disagree, would you, Minister?",
				political_appeasement: {
					absolute_monarchy_discontent: -4,
					fascism_discontent: -8,
					constitutional_monarchy_discontent: 3,
					democracy_discontent: 4,
					socialism_discontent: 6,
					communism_discontent: -10
				},
				effects: [
					["stability", 10],
					["reform_desire_gain", -0.05],
					["tax_efficiency", -0.1],
					["research_efficiency", -0.1],
					["building_cost", -0.05],
					["pop_growth_modifier", 0.02],
					["rgo_throughput", 0.05]
				]
			},
			censored_press: {
				name: "Censored Press",
				description: "Although no one likes restrictions, they're necessary to prevent wartime secrets from leaking out, or even critical coverage of our government when we could afford it least. Therefore, some press needs to be censored.",
				political_appeasement: {
					absolute_monarchy_discontent: -3,
					fascism_discontent: -7,
					constitutional_monarchy_discontent: 2,
					democracy_discontent: 3,
					socialism_discontent: 5,
					communism_discontent: -9
				},
				effects: [
					["stability", 5],
					["reform_desire_gain", -0.03],
					["tax_efficiency", -0.13],
					["research_efficiency", -0.05],
					["building_cost", -0.04],
					["pop_growth_modifier", 0.03],
					["rgo_throughput", 0.04]
				]
			},
			harassed_press: {
				name: "Harassed Press",
				description: "That's just another hit job from the Fake News Media. Ah, here's another beauty ... and besides, no one could even see that 'Press' vest at that protest you were going to. This is the media my opponents want, can you believe it? It's so sad.",
				political_appeasement: {
					absolute_monarchy_discontent: -2,
					fascism_discontent: -3,
					constitutional_monarchy_discontent: 1,
					democracy_discontent: 1,
					socialism_discontent: 4,
					communism_discontent: -2
				},
				effects: [
					["reform_desire_gain", 0.01],
					["research_efficiency", -0.08],
					["building_cost", -0.02],
					["pop_growth_modifier", 0.01],
					["democracy", 2]
				]
			},
			free_press: {
				name: "Free Press",
				description: "Democracy relies on a free and open press to be able to inform voters, not only of geopolitical affairs, but also of affairs in their local constituencies as well.",
				political_appeasement: {
					absolute_monarchy_discontent: 3,
					fascism_discontent: 5,
					constitutional_monarchy_discontent: -1,
					democracy_discontent: -2,
					socialism_discontent: -2,
					communism_discontent: 6
				},
				effects: [
					["reform_desire_gain", 0.03],
					["research_efficiency", 0.1],
					["democracy", 4]
				]
			}
		}
	},
	
	starting_actions: 5,
	money_per_action: 2500,
	resource_list: [["coal", 1000], ["food", 750], ["gold", 2500], ["iron", 2000], ["lead", 700], ["petroil", 2500], ["steel", 3500], ["stone", 1500], ["wood", 1000]],
	resource_base_stock: 50,
	rgo_modifier: 0.1,
	shipment_speed: 50,
	
	combat_order: ["ap", "dp"],
	mobilisation_tech_limit: 5,
	mobilisation_cooldown: 3,
	mobilise_unit: "none",
	carrier_capacity: 50,
	
	army_speed: 20,
	colonisation_speed: 40, //Provinces a turn
	shipment_time: 100, //Transfer speed for shipping goods
	base_transfer_time: 3, //Turns
	cb_generation_speed: 10,
	
	political_capital_gain: 10,
	infamy_loss: -0.05,
	accepted_culture_cost: 150,
	coup_cost: 150,
	move_capital_cost: 100,
	stability_cost: 75,
	reform_cost: 25,
	assimilate_cost: 10,
	accepted_culture_maintenance_cost: 1,
	
	assimilate_fiscal_cost: 5000,
	assimilation_turns: 10,
	integration_turns: 20,
	non_core_manpower: 0.1,
	
	//Diplomatic actions
	justify_wargoal_cost: 75,
	justify_wargoal_time: 3,
	
	improve_relations_cost: 50,
	decrease_relations_cost: 25,
	
	vassalise_cost: 75,
	form_alliance_cost: 50,
	break_alliance_cost: 50,
	declare_rival_cost: 50,
	guarantee_independence_cost: 30,
	request_military_access_cost: 25,
	sign_non_aggression_pact_cost: 25,
	
	pop_array: ["aristocrats", "faculty", "workers", "soldiers"],
	pops: {
		aristocrats: {
			name: "Aristocrats",
			chance: 0.02,
			specialised_pop: true,
			tax_efficiency_per_100k: 0.03,
			stability_per_100k: 0.05
		},
		faculty: {
			name: "Faculty",
			chance: 0.10,
			specialised_pop: true,
			research_efficiency_per_100k: 0.02,
			knowledge_per_100k: 10
		},
		workers: {
			name: "Workers",
			specialised_pop: false
		},
		soldiers: {
			name: "Soldiers",
			chance: 0.15,
			specialised_pop: true
		}
	},
	
	events: {
		access_cancelled: {
			name: "Military Access Cancelled.",
			description: "{0} has cancelled our right to passage through their territorial claims for our military assets. Oh, well, we didn't need those traitorious scum anyway.",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "We really should have beaten them to it.",
			option_a_description: " Your military access has been cancelled by **{0}**!",
			option_a: function (usr) {
			}
		},
		access_denied: {
			name: "Request For Military Access Denied.",
			description: "{0} has denied our requests for military access repeatedly. If we can't get our way, we may just have to circumvent them ... one way or the other.",
			trigger: function (usr) {
			},
			option_a_title: "Unfortunate.",
			option_a_description: " This option currently has no effect.",
			option_a: function (usr) {
			}
		},
		a_guarantee_for_our_nation: {
			name: "Our Sovereignty Guaranteed!",
			description: "{0}, seeking to form closer relations with our state, has decided to extend a guarantee of sovereignty to us to protect us from both internal and external threats. Our envoys and diplomats are looking forward to working with {0} in the future, and our people are relieved to finally have an ally in their time of need.",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "They must be proud to offer this arrangement to such a noble nation.",
			option_a_description: " **+25** Relations with {0}.\n **+10%** Stability for 5 turns.",
			option_a_ai_chance: function (usr) {
				return 100;
			},
			option_a: function (usr) {
				for (var i = 0; i < usr.relations.length; i++) {
					if (usr.relations[i][1] == main.users.global.current_scope) {
						if (usr.relations[i][0]+25 <= 100) {
							usr.relations[i][0] = usr.relations[i][0] + 25;
						} else {
							usr.relations[i][0] = 100;
						}
					}
				}
				usr.temporary_modifiers.push(["stability", 10, 5]);
			},
			option_b_title: "How patronising!",
			option_b_description: " This choice currently has no effect.",
			option_b_ai_chance: function (usr) {
				return 0;
			},
			option_b: function (usr) {
			}
		},
		a_guaranteed_peace: {
			name: "A Guaranteed Peace.", //[[user_id, turns_before_expiry]
			description: "{0} is offering us a non-aggression pact for the next 10 turns. It is up to you, however, as to how to respond to this present opportunity for making peace with the nation of {0}. Should we accept this opportunity for peace, or should we plan for war?",
			event_image: "https://media.discordapp.net/attachments/682166052393582627/740803688834269194/unknown.png",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "We shall accept the offer.",
			option_a_description: " **+20** Relations with {0}.\n This will take up one of our diplomatic slots!",
			option_a_ai_chance: function (usr) {
				return 20;
			},
			option_a: function (usr) {
				for (var i = 0; i < usr.relations.length; i++) {
					if (usr.relations[i][1] == main.users.global.current_scope) {
						if (usr.relations[i][0]+20 <= 100) {
							usr.relations[i][0] = usr.relations[i][0] + 20;
						} else {
							usr.relations[i][0] = 100;
						}
					}
				}
				main.users[main.users.global.current_scope].non_aggression_pacts.push([usr.id, 10]);
				usr.non_aggression_pacts.push([main.users[main.users.global.current_scope].id, 10]);
				usr.used_diplomatic_slots++;
			},
			option_b_title: "We respectfully decline the offer.",
			option_b_description: " This choice currently has no effect.",
			option_b_ai_chance: function (usr) {
				return 80;
			},
			option_b: function (usr) {
				printEvent(main.users.global.current_scope, "an_uneasy_peace");
			}
		},
		alliance_proposal: {
			name: "An Offer For Alliance.",
			description: "We have received an official diplomatic delegation from {0}. They are requesting our mutual aid and support in military and economic affairs, and a formal agreement regarding an alliance. How should our government respond?",
			event_image: "https://media.discordapp.net/attachments/682166052393582627/740803072304873542/unknown.png",
			trigger: function (usr) {
				//Check if user has received any alliance requests: [[nation, pending/accepted]]
				return false;
			},
			option_a_title: "It is in our best interest to conclude an alliance with {0}.",
			option_a_description: " We enter into an alliance with **{0}**.\n Improves relations with {0} by **+25**.\n This will take up one of our diplomatic slots!",
			option_a_ai_chance: function (usr) {
				return 60;
			},
			option_a: function (usr) {
				usr.used_diplomatic_slots++;
				//[[value, player_id, [improving/decreasing/none, turns]]
				for (var i = 0; i < usr.allies.length; i++) {
					if (usr.allies[i][0] == main.users.global.current_scope) {
						usr.allies.splice(i, 1);
					}
				}
				usr.allies.push([main.users.global.current_scope, "accepted"]);
				main.users[main.users.global.current_scope].allies.push([usr.id, "accepted"]);
				for (var i = 0; i < usr.relations.length; i++) {
					if (usr.relations[i][1] == main.users.global.current_scope) {
						if (usr.relations[i][0]+25 <= 100) {
							usr.relations[i][0] = usr.relations[i][0] + 25;
						} else {
							usr.relations[i][0] = 100;
						}
					}
				}
				localisation.push(main.users[main.users.global.current_scope].name);
				localisation.push(usr.name);
				printEvent(main.users.global.current_scope, "alliance_accepted");
			},
			option_b_title: "Respectfully decline the offer for now.",
			option_b_description: " We refuse **{0}'s** alliance proposal. This will harm our relations with them moderately.",
			option_b_ai_chance: function (usr) {
				return 40;
			},
			option_b: function (usr) {
				for (var i = 0; i < usr.relations.length; i++) {
					if (usr.relations[i][1] == main.users.global.current_scope) {
						if (usr.relations[i][0]-20 >= -100) {
							usr.relations[i][0] = usr.relations[i][0] - 20;
						} else {
							usr.relations[i][0] = -100;
						}
					}
				}
				for (var i = 0; i < usr.allies.length; i++) {
					if (usr.allies[i][0] == main.users.global.current_scope) {
						usr.allies.splice(i, 1); //Remove alliance request from array
					}
				}
				main.users[main.users.global.current_scope].used_diplomatic_slots--;
				localisation.push(usr.name);
				printEvent(main.users.global.current_scope, "alliance_declined");
			}
		},
		alliance_accepted: {
			name: "Our New Friend!",
			description: "{1} is cheering her new friend, {0} tonight. It comes as our diplomatic standing in the world is beginning to increase, and we hope that these well-made connections with other foreign powers can help protect our own people.",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "We shall accomplish mush together.",
			option_a_description: " **+5%** Stability for 3 turns.",
			option_a: function (usr) {
				usr.temporary_modifiers.push(["stability", 5, 3]);
			}
		},
		alliance_declined: {
			name: "Alliance Rejected.",
			description: "{0} has declined our repeated requests for an alliance. We should get ready for whatever they have planned ...",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "An unfortunate rejection.",
			option_a_description: " This choice currently has no effect.",
			option_a: function (usr) {
			}
		},
		alliance_broken: {
			name: "Alliance Broken.",
			description: "We were informed by a diplomatic envoy from {0} that our alliance has expired today. Our government worries, however, that it could be the start of colder diplomatic relations between our two nations.",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "What could we have done?",
			option_a_description: " This choice currently has no effect.",
			option_a: function (usr) {
			}
		},
		an_offer_to_lay_down_arms: {
			//[user, war, peace_object
			name: "An Offer To Lay Down Arms.",
			description: "{0} is offering us peace in exchange for the terms listed below. We have the option to either accept or deny this.",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "We accept this offer.",
			option_a_description: " You concede to the terms listed below.",
			option_a: function (usr) {
				//(arg0_peace_obj, arg1_war_obj)
				parsePeace(main.users.global.current_scope[0], main.users.global.current_scope[1]);
			},
			option_b_title: "And they call it ''peace''?",
			option_b_description: " The war rages on ...",
			option_b: function (usr) {
			}
		},
		an_uneasy_peace: {
			name: "An Uneasy Peace.",
			description: "An uneasy peace is now forming between us and {0} as the former has refused our requests for a non-aggression pact, which would surely be mutually beneficial to us both! Perhaps they have something to hide, and if they do, we'd better be ready ...",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "Stand vigilant.",
			option_a_description: " This option currently has no effect.",
			option_a: function (usr) {
			}
		},
		auroras_last_flight: {
			name: "Aurora's Last Flight.",
			description: "The engines hummed steadily as Miller glanced at the fuel gauge bouncing off the bottom. Runsend, had by their merit, earlier shone with the brilliance of a thousand suns, but now a seemingly eternal void of darkness enveloped the plane.\n\nThey all knew there was nowhere to go. {0} would be a crater, and {1} might not exist at all.\n\n'Raven, how do you feel?'\n\nRaven didn't respond.\n\n'Ah well, there'll be bombers on both sides of the Arctic that'll never see land', Miller said in a hushed tone.\n\nAnd with that, the fuel gauge steadied. Miller found a strange comfort grip his heart just before the plane whisked them ten thousand metres below to their watery graves.",
			event_image: "https://media.discordapp.net/attachments/751226425272434770/765012430874214400/unknown.png",
			trigger: function (usr) {
				if (usr.at_war.length > 0) {
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]] == usr.at_war[0]) {
							if (main.users[main.user_array[i]].cities.city_array.length > 0) {
								localisation.push(main.users[main.user_array[i]].cities.city_array[0]);
							} else {
								localisation.push("Runsend");
							}
						}
					}
				} else {
					localisation.push("Runsend");
				}
				
				var all_cities = usr.cities.city_array;
				if (all_cities.length > 1) {
					localisation.push(usr.cities.city_array[0]);
					localisation.push(usr.cities.city_array[1]);
				} else {
					localisation.push(usr.cities.city_array[0]);
					localisation.push("Valsond");
				}
				return false;
			},
			option_a_title: "'Do you suppose anyone will ever know?'",
			option_a_description: " The game comes to an end ...",
			option_a: function (usr) {
			}
		},
		call_to_arms: {
			name: "Call to Arms!",
			description: "{0} is attempting to call us into their war! Although this war may have been started by another country, we hold an alliance with {0}, and so if we seek to honour our alliance, we'll also need to muster our armed forces together. For us all.",
			event_image: "https://media.discordapp.net/attachments/751226425272434770/751226440971976754/Le_drapeau_belge.png",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "Our nation is one of honour!",
			option_a_description: " Join the **{1}**.\n Our alliance will not be seen in vain ...",
			option_a: function (usr) {
				//[war_id, friendly_side: attacker/defender, opposing_side: attacker/defender, nation_calling_in_ally]
				main.users.global.wars[main.users.global.current_scope[0]][main.users.global.current_scope[1]].push(usr.id);
				for (var i = 0; i < main.users.global.wars[main.users.global.current_scope[0]][main.users.global.current_scope[2]].length; i++) {
					usr.at_war.push(main.users[main.users.global.wars[main.users.global.current_scope[0]][main.users.global.current_scope[2]][i]].name);
					//Add new belligerent to all opposing nations
					main.users[main.users.global.wars[main.users.global.current_scope[0]][main.users.global.current_scope[2]][i]].at_war.push(usr.name);
				}
			},
			option_b_title: "We can't afford this war.",
			option_b_title: " Break alliance with **{0}**.\n **-15%** Stability for 5 turns. \n **{0}** will see this as a betrayal ...",
			option_b: function (usr) {
				for (var i = 0; i < usr.relations.length; i++) {
					if (usr.relations[i][1] == main.users.global.current_scope[3]) {
						if (usr.relations[i][0]-70 >= -100) {
							usr.relations[i][0] = usr.relations[i][0] - 70;
						} else {
							usr.relations[i][0] = -100;
						}
					}
				}
				for (var i = 0; i < usr.allies.length; i++) {
					if (usr.allies[i][0] == main.users.global.current_scope[3]) {
						usr.allies.splice(i, 1); //Remove alliance from array
					}
				}
				for (var i = 0; i < main.users[main.users.global.current_scope[3]].allies.length; i++) {
					if (main.users[main.users.global.current_scope[3]].allies[i][0] == usr.id) {
						main.users[main.users.global.current_scope[3]].allies.splice(i, 1); //Remove alliance from array
					}
				}
				usr.temporary_modifiers.push(["stability", -15, 5]);
			}
		},
		comet_sighted: {
			name: "Comet Sighted!",
			description: "Peasants are always superstitious, and the appearance of a comet in the sky has caused panic among our people. They are convinced that this is a sign that the end of times is near or that something bad is going to happen in the near future.",
			event_image: "https://media.discordapp.net/attachments/682166052393582627/740806719512379432/f65c82ddf92032087e9b472ec36903a5.png",
			trigger: function (usr) {
				var chance = randomNumber(0, 100);
				if (chance <= 4) {
					return true;
				} else {
					return false;
				}
			},
			option_a_title: "It's an omen!",
			option_a_description: " **-5%** Stability for 3 turns.",
			option_a: function (usr) {
				//[modifier, increment, lasting_turns]
				usr.temporary_modifiers.push(["stability", -5, 3]);
			}
		},
		declare_independence: {
			name: "{0}'s Declaration of Independence.",
			description: "For too long, the peoples of {0} have been oppressed underneath the rule of the tyrannical {1}. Our lands have been ruthlessly exploited, and our men have been sent to die in foreign wars that are only for the benfit of {0}. The time for justice has arrived, and it has arrived on the point of a bayonet!",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "This is an act of war!",
			option_a_description: " {0} declares war on {1}",
			option_a: function (usr) {
				//Add effect later
			}
		},
		emergence_of_a_nation: {
			name: "Emergence of a Nation.",
			description: "Perhaps, over time, their culture had begun to evolve to be something different than that of their neighbours. Through thousands of years of migration, an entire people had shifted, leaving artefacts here and there for future archaeologists to admire.\n\nThen, even though they found themselves parcelled up by different kings and warlords, they found home.\n\nThey built towns and cities, forts and walls - until they built a kingdom of their own. Over time, they became known as the {0}.\n\nAnd although nations were not meant to last, they were to leave a legacy that was to surely stand the test of time.",
			event_image: "https://media.discordapp.net/attachments/751226425272434770/767857679292694578/unknown.png",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "Nations come and go, the people endure.",
			option_a_description: " The game begins ...",
			option_a: function (usr) {
			}
		},
		guarantee_broken: {
			name: "Guarantee Broken.",
			description: "{0} has rescinded their guarantee for our nation. It seems that they no longer wish to be friends with our great and mighty nation. Whatever the case, our military and our diplomats shall always be standing by at your service.",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "Shame.",
			option_a_description: " This choice currently has no effect.",
			option_a: function (usr) {
			}
		},
		non_aggression_pact_expired: {
			name: "The Expiry Of A Pact.",
			description: "Our non-aggression pact with {0} has expired, and our secretaries are urging for you to renew the pact with **{0}** in order to preserve peace and stability in the region and for our peoples. On the other hand, we could use it as an opportunity to attack, if we so desire ...",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "Alright. Next brief, please!",
			option_a_description: " This choice currently has no effect.",
			option_a: function (usr) {
			}
		},
		other_armies_our_soil: {
			name: "Other Armies, Our Soil.",
			description: "{0} is proposing to be able to move troops through our territory! Our advisors believe that it will likely have a negative impact on the stability of certain regions of our country, however, some advisors also say that the best option may simply be to yield into {0}'s demands. How should we respond?",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "Let them march through.",
			option_a_description: " **+10** Relations with {0}.\n **-5% Stability for 10 turns.\n **{0}** will be given military access through our nation.",
			option_a_ai_chance: function (usr) {
				return 65;
			},
			option_a: function (usr) {
				for (var i = 0; i < usr.relations.length; i++) {
					if (usr.relations[i][1] == main.users.global.current_scope) {
						if (usr.relations[i][0]+10 <= 100) {
							usr.relations[i][0] = usr.relations[i][0] + 10;
						} else {
							usr.relations[i][0] = 100;
						}
					}
					usr.temporary_modifiers.push(["stability", -5, 10]);
					main.users[main.users.global.current_scope].military_access.push(usr.id);
				}
			},
			option_b_title: "They'll march through when we're dead!",
			option_b_description: " This choice currently has no effect.",
			option_b_ai_chance: function (usr) {
				return 35;
			},
			option_b: function (usr) {
				printEvent(main.users.global.current_scope, "access_denied");
			}
		},
		our_hour_of_need: {
			name: "Our Hour of Need.",
			description: "Our nation is now locked in a state of war that threatens to consume our country. Our old friend, {0}, has promised to help us in this struggle. Our diplomats and envoys are standing by. What should we do?",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "We need every friend we can get.",
			option_a_description: " **{0}** may join the war.",
			option_a_ai_chance: function (usr) {
				return 90;
			},
			option_a: function (usr) {
				printEvent(main.users.global.current_scope, "the_promise_we_made");
			},
			option_b_title: "We shall fight alone.",
			option_b_description: " This choice currently has no effect.",
			option_a_ai_chance: function (usr) {
				return 10;
			},
			option_b: function (usr) {
			}
		},
		rival_declared: {
			name: "A New Rival!",
			description: "Relations between us and {0} have never been colder. Diplomatic relations have been suspended, and our forces are marching to the border immediately. Our citizens are growing more and more eager to view them, if not as rivals, then at least as enemies.",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "It's either us or them.",
			option_a_description: " **-50** Relations with {0}.\n Rival relations with {0}.",
			option_a: function (usr) {
				//No actual effect
			}
		},
		the_coming_thaw: {
			name: "The Coming Thaw.",
			description: "Relations between us and {0} are beginning to thaw as our diplomats begin approaching them with a mutual policy of detente. Our citizens are increasingly seeing them not as a menace, but rather as a potential trade partner, or at the very least, a nation like any other.",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "Can relations improve?",
			option_a_description: " End rivalry with {0}.",
			option_a: function (usr) {
				for (var i = 0; i < usr.rivals.length; i++) {
					if (usr.rivals[i] == main.users.global.current_scope) {
						usr.rivals.splice(i, 1);
					}
				}
				for (var i = 0; i < main.users[main.users.global.current_scope].rivals.length; i++) {
					if (main.users[main.users.global.current_scope].rivals[i] == main.users.global.current_scope) {
						main.users[main.users.global.current_scope].rivals.splice(i, 1);
					}
				}
			}
		},
		the_national_disaster: {
			name: "The National Disaster!",
			description: "War exhaustion in our countries and in those of our allies have finally reached record highs. With the enemy willing to talk peace terms, we have no choice but to concede to their demands, whatever they may be. Let us hope that they shall be merciful.",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "It's over ... I can't believe it's over.",
			option_a_description: " We sign an unconditional surrender with the enemy, resulting in the peace terms listed below.",
			option_a: function (usr) {
				parsePeace(main.users.global.current_scope[0], main.users.global.current_scope[1]);
			}
		},
		the_option_to_submit: {
			name: "The Option To Submit.",
			description: "Diplomats in our country are hastily screening over {0}'s proposal, which if accepted, could drastically change the future of our nation. {0} promises to deliver us economic and military support in exchange for, well let's just say ... our independence. We would have to be a subservient client state to {0} in order for them to provide this aid. We could of course decline, but that might anger {0}'s envoys.",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "This is a diplomatic insult!",
			option_a_description: " **-50** Relations with {0}",
			option_a_ai_chance: function (usr) {
				return 95;
			},
			option_a: function (usr) {
				for (var i = 0; i < usr.relations.length; i++) {
					if (main.users[main.users.global.current_scope].relations[i][1] == usr.id) {
						if (usr.relations[i][0]-50 >= -100) {
							usr.relations[i][0] = usr.relations[i][0] - 50;
						} else {
							usr.relations[i][0] = -100;
						}
					}
				}
				for (var i = 0; i < main.users[main.users.global.current_scope].relations.length; i++) {
					if (main.users[main.users.global.current_scope].relations[i][1] == usr.id) {
						if (main.users[main.users.global.current_scope].relations[i][0]-50 >= -100) {
							main.users[main.users.global.current_scope].relations[i][0] = main.users[main.users.global.current_scope].relations[i][0] - 50;
						} else {
							main.users[main.users.global.current_scope].relations[i][0] = -100;
						}
					}
				}
				printEvent(main.users.global.current_scope, "they_stand_defiant");
			},
			option_b_title: "We have no choice but to accept.",
			option_b_description: " We will become a vassal under **{0}**!\n **-15%** Stability for 5 turns.",
			option_b_ai_chance: function (usr) {
				return 5;
			},
			option_b: function (usr) {
				main.users[main.users.global.current_scope].vassals.push(usr.id);
				usr.temporary_modifiers.push(["stability", -15, 5]);
			}
		},
		the_promise_we_made: {
			name: "The Promise We Made.",
			description: "A nation we had previously announced our intention to protect, {0} has been attacked in a perfidious act of war! Although we could simply opt out of risking both our resources and armies to protect {0}, such an action would likely ruin our diplomatic reputation on the world stage. What should we do?",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "''Let the world know we stand by {0}. Enter the war''.",
			option_a_description: " Join the **{1}**.",
			option_a_ai_chance: function (usr) {
				return 80;
			},
			option_a: function (usr) {
				//Add effect later
			},
			option_b_title: "{0}!? I've never heard of such a place before!",
			option_b_description: " **-50** Relations with {0}.\n**-5%** Stability for 5 turns.",
			option_a_ai_chance: function (usr) {
				return 20;
			},
			option_b: function (usr) {
				for (var i = 0; i < main.users[main.users.global.current_scope].relations.length; i++) {
					if (main.users[main.users.global.current_scope].relations[i][1] == usr.id) {
						if (main.users[main.users.global.current_scope].relations[i][0]-50 >= -100) {
							main.users[main.users.global.current_scope].relations[i][0] = main.users[main.users.global.current_scope].relations[i][0] - 50;
						} else {
							main.users[main.users.global.current_scope].relations[i][0] = -100;
						}
					}
				}
				usr.temporary_modifiers.push(["stability", -5, 5]);
			}
		},
		they_stand_defiant: {
			name: "They Stand Defiant.",
			description: "{0} has refused to give up their independence, even in the face of our combined economic and military assets. Either they treat us as a laughing stock, or they hold the means to protect their independence at all costs. Either way, our military is preparing to move in.",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "How dare they defy us?",
			option_description: " This option currently has no effect.",
			option_a: function (usr) {
			}
		},
		we_are_free: {
			name: "We Are Free!",
			description: "Our nation has recently gained independence from {0} after our overlord announced that our vassalisation treaties and contractual obligations had been annulled. Their given reason for doing this is unclear, but our diplomats are speculating that they might have lost the economic and military strength needed to enforce such a policy. As such we have once again become an independent nation.",
			trigger: function (usr) {
				return false;
			},
			option_a_title: "Long live the new republic!",
			option_a_description: " This option currently has no effect.",
			option_a: function (usr) {
			}
		}
	},
	
	casus_belli: {
		//status_quo, install_government, cut_down_to_size, liberation, puppet, retake_cores, annexation
		territorial_violation: {
			name: "Territorial Violation",
			description: "Target has moved armed forces through your country without permission.",
			icon: "<:active_personnel:716820390474940426>",
			infamy: 0,
			peace_demands: ["status_quo"]
		},
		theft: {
			name: "Theft",
			description: "Target scammed/blockaded you, etc.",
			icon: "<:taxes:716817688781127810>",
			infamy: 0,
			peace_demands: ["status_quo"]
		},
		containment: {
			name: "Containment",
			description: "Target has over 8 infamy.",
			icon: "<:infamy:716817688453709905>",
			infamy: 0,
			peace_demands: ["status_quo", "install_government", "cut_down_to_size"]
		},
		colonial_integration: {
			name: "Colonial Integration",
			description: "Attacker's total deployed AP are over 4x that of their target's deployed military. Target is behind on tech.",
			icon: "<:globe:716811246556545035>",
			infamy: 2,
			peace_demands: ["status_quo", "puppet", "annexation"]
		},
		free_oppressed_people: {
			name: "Free Oppressed People",
			description: "Attacker is a democracy/HM Government, target is not. Target has over 3 infamy.",
			icon: "<:diplomacy:716827579323121666>",
			infamy: 2,
			peace_demands: ["status_quo", "install_government"]
		},
		independence: {
			name: "Independence",
			description: "The attacker has been a puppet for more than 5 turns to the target.",
			icon: "<:revolt:716819535964930149>",
			infamy: 2,
			peace_demands: ["status_quo", "liberation"]
		},
		revanchism: {
			name: "Revanchism",
			description: "Target occupies land once controlled by the attacker.",
			icon: "<:old_map:716821884867444746>",
			infamy: 2,
			peace_demands: ["status_quo", "retake_cores"]
		},
		anschluss: {
			name: "Anschluss",
			description: "Target is your puppet, and refused to be annexed by you.",
			icon: "<:old_scroll:716828676880334881>",
			infamy: 3,
			peace_demands: ["status_quo", "annexation"]
		},
		diplomatic_insult: {
			name: "Diplomatic Insult",
			description: "Target has formally insulted the attacker.",
			icon: "<:cb:716828676855169107>",
			infamy: 5,
			peace_demands: ["status_quo"]
		},
		lebensraum: {
			name: "Lebensraum",
			description: "Attacker is communist, fascist, or absolute monarchy.",
			icon: "<:land_vehicles:716821195215077406>",
			infamy: 5,
			peace_demands: ["puppet", "annexation"]
		},
		acquire_state: {
			name: "Acquire State",
			description: "Attacker's capital is less than 100 provinces away from target's capital. Attacker's total AP are over twice that of target's.",
			icon: "<:provinces:716809229603700737>",
			infamy: 5,
			peace_demands: ["puppet", "annexation"]
		}
	}
};

var flavour_text = {
	failed_initative: [
		"walked into an intersection, and became too paranoid to attack.",
		"heard what they thought were gunshots from the forest, and decided to go on the defensive instead.",
		"were too exhausted to attack.",
		"failed to seize the initiative, and decided to brace for the next attack instead.",
		"had a commander known for poor planning, and so decided not to go on the attack.",
		"were going to attack, but ultimately decided not to.",
		"had a commander who decided that attacking simply wasn't worth it.",
		"decided to defend instead.",
		"decided to hold their ground.",
		"decided against slogging through the mud in front of them and being bogged down.",
		"took their time to strengthen their left flank.",
		"took their time to strengthen their right flank.",
		"took their time to strengthen their centre.",
		"fell for the enemy's ruse de guerre, wasting valuable time.",
		"didn't realise that the enemy had shifted their forces the previous night, and so decided to dig in.",
		"decided to dig in instead.",
		"heard what they thought was a shot from an angry Franc-Tireur, and so spent the night burning down the neighbouring town instead.",
		"became nervous, and lost their cool.",
		"decided against attacking.",
		"had a commander known for his cautiousness, and so decided not to attack.",
		"spent the day surveying the enemy's position.",
		"were too exhausted to go on the offensive.",
		"realised they were being enveloped from behind, and so decided to commit more troops there.",
		"spent the day planning.",
		"spent the night doing nothing.",
		"realised the weather was too bad to go on an offensive.",
		"failed to attack due to communication issues.",
		"were itching to go on the attack, but the order never came.",
		"waited for reinforcements, only for those reinforcements to never arrive.",
		"were too demoralised to go on the offensive.",
		"had a commander who had to deal with a few mutineers.",
		"failed to see the weaknesses of their enemy, and so failed to go on the offensive.",
		"had to bridge a river first before being able to attack their enemy.",
		"had to cross through a valley first before being able to attack their enemy.",
		"had to cross through a mountain pass first."
	],
	successful_manoeuvre: [
		"managed to manoeuvre out of harm's way.",
		"intercepted enemy communications detailing their attack plan, and so planned accordingly.",
		"managed to dodge the salvo.",
		"were well-dug in by the time the attack came.",
		"watched as the enemy tried to charge through the muddy mess that had become the battlefield after the spring rains.",
		"realised an attack was imminent, and so withdrew from their positions.",
		"were petrified of being trapped in an enemy intersection, and so withdrew.",
		"barely escaped the enemy's attack.",
		"took cover.",
		"managed to elude the enemy.",
		"intercepted a transmission from the enemy, and withdrew to another line.",
		"managed to withdraw behind a river just in time.",
		"managed a fighting retreat successfully.",
		"were intially stunned by the enemy's attack, but managed to retreat and regroup successfully anyway.",
		"saw the barrels of petroil the enemy was storing up, and decided to withdraw."
	],
	light_attack: [
		"forces decide to return harassing fire!",
		"soldiers failed to seize their planned objectives due to leadership incompetence.",
		"soldiers initially broke through, only to realise they had fallen victim to a Carthaginian encirclement.",
		"forces managed to push hard on the enemy centre, but the left and right flanks held, stalling their objective.",
		"units were forced to withdraw after light skirmishes.",
		"units engaged in light skirmishes, but had to withdraw due to unfavourable conditions.",
		"soldiers launched a wide-scale attack, only for the weather to turn sour.",
		"were slowed by their reliance on draft animals."
	],
	medium_attack: [
		"forces return fire!",
		"units stunned the enemy with a huge artillery barrage before seizing the enemy's defensive positions in an unorganised rush.",
		"forces unleash fire!",
		"soldiers attempted to attack the enemy from behind, and inflicted significant damage, but were driven off.",
		"soldiers attacked during favourable weather conditions, causing significant casualties for the enemy."
	],
	heavy_attack: [
		"forces unleash a devastating salvo!",
		"troops unleash a devastating volley onto an unsuspecting enemy.",
		"soldiers forced the enemy soldiers into a complete rout, making them withdraw over the river.",
		"troops created a ruse de guerre, which the enemy fell for.",
		"soldiers mined the bridges in the locality. As the enemy began crossing the bridges, they decided to blow them up!",
		"launches an offensive operation against the enemy, which proves highly effective."
	],
	attacker_lost: [
		"was forced to retreat after suffering heavy losses!"
	],
	defender_lost: [
		"was too under-strength to continue fighting."
	],
	
	rigged_elections: [
		"held 'elections' in a manner international observers deemed 'unfair'. Due to errors in counting, the ruling party walked away with " + randomNumber(101, 117) + "% of the vote. ",
		"today stated that their ruling party won " + randomNumber(97, 100) + "% of the vote. The opposition leader claimed yesterday claimed that the polls were rigged, but was today identified as a corpse in the boot of a white van. ",
		"went to the polls yesterday. Many of the voters looked at the ballot, which contained only one option, before realising that a bayonet was being pointed at their face. ",
		"would have gone to the polls, if only there were any open. ",
		"held elections. Rumours allege that men with beards and moustaches cast their ballot, went to the barber shop, came back without a moustache, cast their vote, went back to the barber shop, came back with a neat trim, cast another ballot, went back to the barber, came back shaved like a monk, and cast another vote. They then went down to the local wig shop to purchase some fake hair, before casting a fifth vote. A local mayor was particularly outraged upon realising that several hundred unidentified decedents (all of whom had been a member of the opposition), were somehow being tallied in the vote. Voter turnout in his constituency was " + randomNumber(200, 300) + "%, but his outrage was silenced when his remains were found plastered to the windscreen of his car. ",
		"had elections. The 'Prime Minister' of the country unveiled a new voting booth, one he said 'would obtain an acceptable standard of precision, ensure that all votes are counted accurately, and submitted legally'. Photos smuggled out of this secretive state revealed a voting booth with a built-in Kalashnikov. "
	]
};

user = "";
input = "";

building_list = [];
news = [];

//Framework
{
	//Config logic
	{
		for (var i = 0; i < config.units.length; i++) {
			for (var x = 0; x < config.unit_stats[config.units[i]].costs.length; x++) {
				if (config.unit_stats[config.units[i]].costs[x][1] == "soldiers") {
					if (config.unit_stats[config.units[i]].quantity != undefined) {
						config.unit_stats[config.units[i]].manpower_cost = config.unit_stats[config.units[i]].costs[x][0]/config.unit_stats[config.units[i]].quantity;
					}
				}
			}
		}
		
		config.valid_technologies = Object.keys(config.technology);
	}
	
	//Operating functions
	{
		function parseNumber (arg0_number) {
			return Intl.NumberFormat('de').format(parseInt(arg0_number));
		}
		
		function parseInteger (arg0_number) {
			return Intl.NumberFormat('de').format(parseInt(Math.ceil(arg0_number)));
		}
		
		function saveConfig () {
			var bot_settings = [
				'bot_prefix = "' + bot_prefix + '";',
				'start_date = new Date(2020, 03, 26, 16, 09);',
				'turn_timer = ' + turn_timer + ';',
				'announcements_channel = "' + announcements_channel + '";',
				'map_channel = "' + map_channel + '";',
				'war_channel = "' + war_channel + '";',
				'authorised_role = "' + authorised_role + '";'
			];
			fs.writeFile('config.txt', bot_settings.join("\n"), function (err,data) {
				if (err) {
					return console.log(err);
				}
				//console.log(data);
			});
		}
		
		function equalsIgnoreCase (arg0, arg1) {
			if (arg0.toLowerCase() == (bot_prefix + arg1).toLowerCase()) {
				return true;
			} else {
				return false;
			}
		}
		
		function returnMention (arg0) {
			//console.log(user.id.toString());
			var user_exists = false;
			
			if (arg0.match(/^[<0-9>(@)!]+$/)) {
				var mention_id = arg0.replace(/(<)(@)(!)/g,"");
				mention_id = mention_id.replace(/(<)(@)/g,"");
				mention_id = mention_id.replace(">","");
				
				return mention_id;
			} else {
				var mention_id = "";
				var nation_found = [false, ""];
				var user_id = "";
				for (var i = 0; i < main.user_array.length; i++) {
					console.log("[Triumph & Tragedy]: User mention fetched: " + main.users[main.user_array[i]].name);
					if (main.users[main.user_array[i]].name.toLowerCase().indexOf(arg0.toLowerCase()) != -1) {
						nation_found = [true, main.users[main.user_array[i]].name];
						mention_id = main.user_array[i];
					}
				}
				
				if (nation_found[0] == true && nation_found[1] != arg0) { //Loop back again to prioritise any exact matches
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]].name.toLowerCase() == arg0.toLowerCase()) {
							nation_found = [true, main.users[main.user_array[i]].name];
							mention_id = main.user_array[i];
						}
					}
				}
				
				if (nation_found[0] != true) {
					var user_object = client.users.cache.find(user => user.username.toLowerCase() == arg0.toLowerCase());
					if (user_object != undefined) {
						user_id = user_object.id.toString();
					}
					
					if (main.users[user_id] != undefined) {
						user_exists = true;
					}
				} else {
					return mention_id;
				}
				
				console.log("[Triumph & Tragedy]: User mentioned was found. Value set to: " + nation_found);
			}
			
			if (user_exists) {
				return user_id;
			}
		}
		
		function parseMilliseconds (duration) {
			var milliseconds = parseInt((duration % 1000) / 100),
			seconds = Math.floor((duration / 1000) % 60),
			minutes = Math.floor((duration / (1000 * 60)) % 60),
			hours = Math.floor((duration / (1000 * 60 * 60)) % 24);

			return hours + " hours, " + minutes + " minutes, " + seconds + " seconds";
		}
		
		function hasRole (arg0_msg, arg1_role) {
			if (arg0_msg.member == undefined) {
				return false;
			} else {
				if (arg0_msg.member.roles.cache.some(role => role.name === arg1_role)) {
					return true;
				} else {
					return false;
				}
			}
		}
		
		function longMessage (arg0_msg, arg1_array, arg2_amount, arg3_dm) {
			var msg = arg0_msg;
			var default_amount = 20;
			var dm_array = [];
			if (arg3_dm == undefined) {
				dm_array = [false, ""];
			}
			if (arg2_amount != undefined) {
				default_amount = arg2_amount;
			}
			if (arg1_array.length > default_amount) {
				var temp_array_string = [];
				for (var i = 0; i < arg1_array.length; i++) {
					if (temp_array_string.length < default_amount) {
						temp_array_string.push(arg1_array[i]);
					} else {
						if (dm_array[0]) {
							client.users.fetch(dm_array[1]).then((user) => {
								if (user != undefined) {
									user.send(temp_array_string.join("\n"));
								}
							});
						} else {
							msg.channel.send(temp_array_string.join("\n"));
						}
						temp_array_string = [];
						temp_array_string.push(arg1_array[i]);
					}
								
					if (arg1_array.length > default_amount) {
						if (i == arg1_array.length-1) {
							if (dm_array[0]) {
								client.users.fetch(dm_array[1]).then((user) => {
									if (user != undefined) {
										user.send(temp_array_string.join("\n"));
									}
								});
							} else {
								msg.channel.send(temp_array_string.join("\n"));
							}
							temp_array_string = [];
						}
					}
				}
			} else {
				if (dm_array[0]) {
					client.users.fetch(dm_array[1]).then((user) => {
						if (user != undefined) {
							user.send(arg1_array.join("\n"));
						}
					});
				} else {
					msg.channel.send(arg1_array.join("\n"));
				}
			}
		}
	}

	//Logic functions
	{
		function initGlobal () {
			if (main.users.global == undefined) { main.users.global = {}; }
			if (main.users.global.blockade_arrays == undefined) { main.users.global.blockade_arrays = {}; }
			if (main.users.global.blockades == undefined) { main.users.global.blockades = {}; }
			if (main.users.global.wars == undefined) { main.users.global.wars = {}; }
			if (main.users.occupations == undefined) { main.users.occupations = []; }
			//Battle functions
			if (main.users.global.battle_tick == undefined) { main.users.global.battle_tick = main.lastTurn; }
			//Event functions
			if (main.users.global.current_scope == undefined) { main.users.global.current_scope = ""; }
			
			//Market functions
			for (var i = 0; i < config.materials.length; i++) {
				if (main.users.global[config.materials[i] + "_stock"] == undefined) {
					main.users.global[config.materials[i] + "_stock"] = config.resource_base_stock;
					for (var x = 0; x < config.resource_list.length; x++) {
						if (config.resource_list[x][0] == config.materials[i]) {
							main.users.global[config.materials[i] + "_buy_price"] = Math.ceil(config.resource_list[x][1]);
							main.users.global[config.materials[i] + "_sell_price"] = Math.ceil(config.resource_list[x][1]*0.5);
						}
					}
				}
			}
		}
		
		function initUser (arg0_user) {
			initGlobal();
			var current_user = arg0_user.toString();
			var already_registered = false;
			for (var i = 0; i < main.user_array.length; i++) {
				if (main.user_array[i] == current_user) {
					already_registered = true;
				}
			}
			
			//Customisation
			
			if (main.users[current_user] == undefined) { main.users[current_user] = {}; }
			if (main.users[current_user].name == undefined) { main.users[current_user].name = ""; }
			if (main.users[current_user].flag == undefined) { main.users[current_user].flag = "https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png"; }
			if (main.users[current_user].colour == undefined) { main.users[current_user].colour = [randomNumber(0,255),randomNumber(0,255),randomNumber(0,255)]; }
			if (main.users[current_user].id == undefined) { main.users[current_user].id = arg0_user; }
			if (main.users[current_user].government == undefined) { main.users[current_user].government = ""; }
			if (main.users[current_user].technology_level == undefined) { main.users[current_user].technology_level = 1; }
			if (main.users[current_user].population == undefined) { main.users[current_user].population = 0; }
			
			if (main.users[current_user].motto == undefined) { main.users[current_user].motto = 'No motto set.'; }
			
			if (main.users[current_user].initial_manpower == undefined) { main.users[current_user].initial_manpower = 0; }
			if (main.users[current_user].manpower_percentage == undefined) { main.users[arg0_user].manpower_percentage = 1; }
			if (main.users[current_user].used_manpower == undefined) { main.users[current_user].used_manpower = 0; }
			if (main.users[current_user].active_personnel == undefined) { main.users[current_user].active_personnel = 0; }
			if (main.users[current_user].mobilised_manpower == undefined) { main.users[current_user].mobilised_manpower = [0, ""]; }
			
			if (main.users[current_user].money == undefined) { main.users[current_user].money = 10000; }
			if (main.users[current_user].stability == undefined) { main.users[current_user].stability = 75; }
			if (main.users[current_user].stability_decay == undefined) { main.users[current_user].stability_decay = 0; }
			if (main.users[current_user].coup_this_turn == undefined) { main.users[current_user].coup_this_turn = false; }
			if (main.users[current_user].overthrow_this_turn == undefined) { main.users[current_user].overthrow_this_turn = ""; }
			if (main.users[current_user].news_this_turn == undefined) { main.users[current_user].news_this_turn = ""; }
			
			//Array for enabled mechanics (especially temporary story-driven ones)
			if (main.users[current_user].enabled_mechanics == undefined) { main.users[current_user].enabled_mechanics = []; }
			
			//Colonisation
			if (main.users[current_user].capital_id == undefined) { main.users[current_user].capital_id = 0; }
			if (main.users[current_user].expeditions == undefined) { main.users[current_user].expeditions = []; }
			
			//Cooldowns
			if (main.users[current_user].last_mobilised == undefined) { main.users[current_user].last_mobilised = 0; }
			
			//Building cap
			if (main.users[current_user].provinces == undefined) { main.users[current_user].provinces = 0; }
			if (main.users[current_user].building_count == undefined) { main.users[current_user].building_count = 0; }
			if (main.users[current_user].building_cap == undefined) { main.users[current_user].building_cap = 10; }
			
			//Sub-objects
			if (main.users[current_user]["buildings"] == undefined) { main.users[current_user]["buildings"] = {}; }
			if (main.users[current_user]["cities"] == undefined) { main.users[current_user]["cities"] = {}; }
			if (main.users[current_user]["inventory"] == undefined) { main.users[current_user]["inventory"] = {}; }
			if (main.users[current_user]["military"] == undefined) { main.users[current_user]["military"] = {}; }
			if (main.users[current_user]["modifiers"] == undefined) { main.users[current_user]["modifiers"] = {}; }
			if (main.users[current_user]["politics"] == undefined) { main.users[current_user]["politics"] = {}; }
			if (main.users[current_user]["pops"] == undefined) { main.users[current_user]["pops"] = {}; }
			
			//Modifiers
			if (main.users[current_user].prestige == undefined) { main.users[current_user].prestige = 0; }
			if (main.users[current_user].tax_rate == undefined) { main.users[current_user].tax_rate = 0; }
			if (main.users[current_user].max_tax == undefined) { main.users[current_user].max_tax = 0; }
			if (main.users[current_user].blockaded == undefined) { main.users[current_user].blockaded = false; }
			
			if (main.users[current_user].production_buildings_modifier == undefined) { main.users[current_user].production_buildings_modifier = 1; }
			if (main.users[current_user].pop_growth_modifier == undefined) { main.users[current_user].pop_growth_modifier = 1.0539; }
			
			if (main.users[current_user].infamy == undefined) { main.users[current_user].infamy = 0; }
			if (main.users[current_user].at_war == undefined) { main.users[current_user].at_war = []; }
			
			if (main.users[current_user].modifiers.army_upkeep == undefined) { main.users[current_user].modifiers.army_upkeep = 1; }
			if (main.users[current_user].modifiers.national_manpower == undefined) { main.users[current_user].modifiers.national_manpower = 1; }
			if (main.users[current_user].modifiers.non_core_manpower == undefined) { main.users[current_user].modifiers.non_core_manpower = config.non_core_manpower; }
			if (main.users[current_user].modifiers.army_travel_speed == undefined) { main.users[current_user].modifiers.army_travel_speed = 1; }
			if (main.users[current_user].modifiers.colonist_travel_speed == undefined) { main.users[current_user].modifiers.colonist_travel_speed = 1; }
			if (main.users[current_user].modifiers.training_cost == undefined) { main.users[current_user].modifiers.training_cost = 1; }
			
			if (main.users[current_user].modifiers.starting_diplomatic_slots == undefined) { main.users[current_user].modifiers.starting_diplomatic_slots = 3; }
			if (main.users[current_user].modifiers.cb_generation_speed == undefined) { main.users[current_user].modifiers.cb_generation_speed = 1; }
			if (main.users[current_user].modifiers.infamy_loss == undefined) { main.users[current_user].modifiers.infamy_loss = config.infamy_loss; }
			if (main.users[current_user].modifiers.stability_modifier == undefined) { main.users[current_user].modifiers.stability_modifier = 0; }
			if (main.users[current_user].modifiers.political_capital_gain == undefined) { main.users[current_user].modifiers.political_capital_gain = config.political_capital_gain; }
			if (main.users[current_user].modifiers.war_exhaustion_rate == undefined) { main.users[current_user].modifiers.war_exhaustion_rate = 1; }
			if (main.users[current_user].modifiers.war_exhaustion == undefined) { main.users[current_user].modifiers.war_exhaustion = 0; }
			if (main.users[current_user].modifiers.reform_desire_gain == undefined) { main.users[current_user].modifiers.reform_desire_gain = 0.02; }
			if (main.users[current_user].modifiers.reform_desire == undefined) { main.users[current_user].modifiers.reform_desire = 0; }
			
			if (main.users[current_user].modifiers.prestige_gain == undefined) { main.users[current_user].modifiers.prestige_gain = 0; }
			
			if (main.users[current_user].modifiers.tax_efficiency == undefined) { main.users[current_user].modifiers.tax_efficiency = 0.15; }
			if (main.users[current_user].modifiers.research_efficiency == undefined) { main.users[current_user].modifiers.research_efficiency = 0.20; }
			if (main.users[current_user].modifiers.production_efficiency == undefined) { main.users[current_user].modifiers.production_efficiency = 1; }
			if (main.users[current_user].modifiers.building_cost == undefined) { main.users[current_user].modifiers.building_cost = 1; }
			if (main.users[current_user].modifiers.unit_cost == undefined) { main.users[current_user].modifiers.unit_cost = 1; }
			if (main.users[current_user].modifiers.training_cost == undefined) { main.users[current_user].modifiers.training_cost = 1; }
			if (main.users[current_user].modifiers.rgo_throughput == undefined) { main.users[current_user].modifiers.rgo_throughput = config.rgo_modifier; }
			if (main.users[current_user].modifiers.shipment_time == undefined) { main.users[current_user].modifiers.shipment_time = 1; }
			
			if (main.users[current_user].modifiers.extra_building_slots == undefined) { main.users[current_user].modifiers.extra_building_slots = 0; }
			if (main.users[current_user].modifiers.maximum_expeditions == undefined) { main.users[current_user].modifiers.maximum_expeditions = 1; }
			
			if (main.users[current_user].temporary_modifiers == undefined) { main.users[current_user].temporary_modifiers = []; }
			
			//New Modifiers from 5.1
			{
				//Political
				if (main.users[current_user].modifiers.administrative_efficiency == undefined) { main.users[current_user].modifiers.administrative_efficiency = 0.5; }
				if (main.users[current_user].modifiers.advisor_cost == undefined) { main.users[current_user].modifiers.advisor_cost = 1; }
				if (main.users[current_user].modifiers.centralisation == undefined) { main.users[current_user].modifiers.centralisation = 0; }
				if (main.users[current_user].modifiers.crime_rate == undefined) { main.users[current_user].modifiers.crime_rate = 0.05; }
				if (main.users[current_user].modifiers.centralisation_gain == undefined) { main.users[current_user].modifiers.centralisation_gain = 0; }
				if (main.users[current_user].modifiers.influence == undefined) { main.users[current_user].modifiers.influence = 0; }
				if (main.users[current_user].modifiers.influence_gain == undefined) { main.users[current_user].modifiers.influence_gain = 5; }
				if (main.users[current_user].modifiers.jingoism == undefined) { main.users[current_user].modifiers.jingoism = 0; }
				if (main.users[current_user].modifiers.opinion_modifier == undefined) { main.users[current_user].modifiers.opinion_modifier = 0; }
				if (main.users[current_user].modifiers.overextension == undefined) { main.users[current_user].modifiers.overextension = 0; }
				if (main.users[current_user].modifiers.republicanism == undefined) { main.users[current_user].modifiers.republicanism = 0; }
				if (main.users[current_user].modifiers.ruling_party_support == undefined) { main.users[current_user].modifiers.ruling_party_support = 0; }
				
				//Economic
				for (var i = 0; i < config.pop_array.length; i++) {
					if (main.users[current_user].modifiers[config.pop_array[i] + "_growth_modifier"] == undefined) { main.users[current_user].modifiers[config.pop_array[i] + "_growth_modifier"] = 1; }
				}
				for (var i = 0; i < config.materials.length; i++) {
					if (main.users[current_user].modifiers[config.materials[i] + "_gain"] == undefined) { main.users[current_user].modifiers[config.materials[i] + "_gain"] = 1; }
				}
				for (var i = 0; i < config.building_categories.length; i++) {
					if (main.users[current_user].modifiers[config.building_categories[i] + "_building_slots"] == undefined) { main.users[current_user].modifiers[config.building_categories[i] + "_building_slots"] = 1; }
				}
				
				if (main.users[current_user].modifiers.construction_speed == undefined) { main.users[current_user].modifiers.construction_speed = 1; }
				if (main.users[current_user].modifiers.isolation == undefined) { main.users[current_user].modifiers.isolation = 0.50; }
				if (main.users[current_user].modifiers.research_slots == undefined) { main.users[current_user].modifiers.research_slots = 3; }
				if (main.users[current_user].modifiers.shipment_capacity == undefined) { main.users[current_user].modifiers.shipment_capacity = 50; }
				
				//Military
				for (var i = 0; i < config.units.length; i++) {
					if (main.users[current_user].modifiers[config.units[i] + "_ap"] == undefined) { main.users[current_user].modifiers[config.units[i] + "_ap"] = 1; }
					if (main.users[current_user].modifiers[config.units[i] + "_dp"] == undefined) { main.users[current_user].modifiers[config.units[i] + "_dp"] = 1; }
					if (main.users[current_user].modifiers[config.units[i] + "_mp"] == undefined) { main.users[current_user].modifiers[config.units[i] + "_mp"] = 1; }
					if (main.users[current_user].modifiers[config.units[i] + "_ip"] == undefined) { main.users[current_user].modifiers[config.units[i] + "_ip"] = 1; }
					if (main.users[current_user].modifiers[config.units[i] + "_movement"] == undefined) { main.users[current_user].modifiers[config.units[i] + "_movement"] = 1; }
				}
				
				if (main.users[current_user].modifiers.attrition_rate == undefined) { main.users[current_user].modifiers.attrition_rate = 1; }
				if (main.users[current_user].modifiers.army_professionalism == undefined) { main.users[current_user].modifiers.army_professionalism = 1; }
				if (main.users[current_user].modifiers.blockade_efficiency == undefined) { main.users[current_user].modifiers.blockade_efficiency = 0.2; }
				if (main.users[current_user].modifiers.casualty_reduction == undefined) { main.users[current_user].modifiers.casualty_reduction = 1; }
				if (main.users[current_user].modifiers.command_power_gain == undefined) { main.users[current_user].modifiers.command_power_gain = 1; }
				if (main.users[current_user].modifiers.mobilisation_size == undefined) { main.users[current_user].modifiers.mobilisation_size = 1; }
				if (main.users[current_user].modifiers.navy_professionalism == undefined) { main.users[current_user].modifiers.navy_professionalism = 1; }
				if (main.users[current_user].modifiers.supply_consumption == undefined) { main.users[current_user].modifiers.supply_consumption = 1; }
				
				//Colonisation
				if (main.users[current_user].modifiers.colonial_immigration_rate == undefined) { main.users[current_user].modifiers.colonial_immigration_rate = 1; }
				if (main.users[current_user].modifiers.colonial_maintenance == undefined) { main.users[current_user].modifiers.colonial_maintenance = 1; }
				if (main.users[current_user].modifiers.colonial_power_gain == undefined) { main.users[current_user].modifiers.colonial_power_gain = 1; }
				if (main.users[current_user].modifiers.colonial_power_cap == undefined) { main.users[current_user].modifiers.colonial_power_cap = 50; }
				
				if (main.users[current_user].modifiers.colonial_power == undefined) { main.users[current_user].modifiers.colonial_power = 0; }
			}
			
			//Unit modifiers
			for (var i = 0; i < config.unit_categories.length; i++) {
				if (main.users[current_user].modifiers[config.unit_categories[i] + "_ap"] == undefined) { main.users[current_user].modifiers[config.unit_categories[i] + "_ap"] = 1; }
				if (main.users[current_user].modifiers[config.unit_categories[i] + "_dp"] == undefined) { main.users[current_user].modifiers[config.unit_categories[i] + "_dp"] = 1; }
			}
			
			//Obsoletion mechanics
			if (main.users[current_user]["available_units"] == undefined) { main.users[current_user]["available_units"] = []; }
			if (main.users[current_user]["available_buildings"] == undefined) { main.users[current_user]["available_buildings"] = []; }
			if (main.users[current_user]["available_governments"] == undefined) { main.users[current_user]["available_governments"] = []; }
			if (main.users[current_user].enable_blockades == undefined) { main.users[current_user].enable_blockades = false; }
			if (main.users[current_user].enable_mobilisation == undefined) { main.users[current_user].enable_mobilisation = false; }
			if (main.users[current_user].mobilise_unit == undefined) { main.users[current_user].mobilise_unit = ""; }
			
			if (main.users[current_user].researched_technologies == undefined) { main.users[current_user].researched_technologies = []; }
			if (main.users[current_user].researching == undefined) { main.users[current_user].researching = []; }
			if (main.users[current_user].research_queue == undefined) { main.users[current_user].research_queue = []; }
			
			//Events
			if (main.users[current_user].events == undefined) { main.users[current_user].events = []; }
			if (main.users[current_user].triggered_events == undefined) { main.users[current_user].triggered_events = {}; }
			if (main.users[current_user].previous_option_id == undefined) { main.users[current_user].previous_option_id = 0; }
			
			//Crafting values
			if (main.users[current_user].actions == undefined) { main.users[current_user].actions = 10; }
			
			if (main.users[current_user].civilian_actions == undefined) { main.users[current_user].civilian_actions = 0; }
			if (main.users[current_user].civilian_actions_percentage == undefined) { main.users[current_user].civilian_actions_percentage = 0; }
			if (main.users[current_user].refining_actions == undefined) { main.users[current_user].refining_actions = 0; }
			
			for (var i = 0; i < config.unit_categories.length; i++) {
				if (main.users[current_user][config.unit_categories[i] + "_cp"] == undefined) { main.users[current_user][config.unit_categories[i] + "_cp"] = 0; }
			}
			
			//Add all materials to inventory
			for (var i = 0; i < config.materials.length; i++) {
				if (main.users[current_user]["inventory"][config.materials[i]] == undefined) { main.users[current_user]["inventory"][config.materials[i]] = 0; }
				if (main.users[current_user]["modifiers"][config.materials[i]] == undefined) { main.users[current_user]["modifiers"][config.materials[i]] = 1; }
			}
			if (main.users[current_user].knowledge_per_turn == undefined) { main.users[current_user].knowledge_per_turn = 0; }
			if (main.users[current_user]["modifiers"].actions == undefined) { main.users[current_user]["modifiers"].actions = 1; }
			
			//Research
			if (main.users[current_user].techs_researched == undefined) { main.users[current_user].techs_researched = 0; }
			for (var i = 0; i < config.tech_categories.length; i++) {
				if (main.users[current_user][config.tech_categories[i] + "_researched"] == undefined) { main.users[current_user][config.tech_categories[i] + "_researched"] = 0; }
			}
			
			//Add all buildings
			for (var i = 0; i < config.buildings.length; i++) {
				if (main.users[current_user]["buildings"][config.buildings[i]] == undefined) { main.users[current_user]["buildings"][config.buildings[i]] = 0; }
				if (main.users[current_user]["modifiers"][config.buildings[i]] == undefined) { main.users[current_user]["modifiers"][config.buildings[i]] = 1; }
			}
			
			//Politics
			if (main.users[current_user].political_capital == undefined) { main.users[current_user].political_capital = 150; }
			if (main.users[current_user].available_reforms == undefined) { main.users[current_user].available_reforms = []; }
			if (main.users[current_user].political_instability_modifier == undefined) { main.users[current_user].political_instability_modifier = 0; }
			if (main.users[current_user].political_reform_desire_modifier == undefined) { main.users[current_user].political_reform_desire_modifier = 0; }
			if (main.users[current_user].political_capital_gain_modifier == undefined) { main.users[current_user].political_capital_gain_modifier = 0; }
			
			//Add all political parties
			for (var i = 0; i < config.government_list.length; i++) {
				if (main.users[current_user]["politics"][config.government_list[i]] == undefined) { main.users[current_user]["politics"][config.government_list[i]] = 0; }
			}
			for (var i = 0; i < config.government_list.length; i++) {
				if (main.users[current_user]["modifiers"][config.government_list[i]] == undefined) { main.users[current_user]["modifiers"][config.government_list[i]] = 1; }
				if (main.users[current_user]["modifiers"][config.government_list[i] + "_discontent"] == undefined) { main.users[current_user]["modifiers"][config.government_list[i] + "_discontent"] = 0; }
			}
			
			//Cities
			if (main.users[current_user]["cities"].province_array == undefined) { main.users[current_user]["cities"].province_array = []; }
			if (main.users[current_user]["cities"].city_array == undefined) { main.users[current_user]["cities"].city_array = []; }
			if (main.users[current_user].city_cap == undefined) { main.users[current_user].city_cap = 3; }
			if (main.users[current_user].city_count == undefined) { main.users[current_user].city_count = 0; }
			
			if (main.users[current_user].random_drop == undefined) { main.users[current_user].random_drop = randomNumber(7, 10); }
			
			if (main.users[current_user].deduction == undefined) { main.users[current_user].deduction = 0.01; }
			if (main.users[current_user].city_random_end == undefined) { main.users[current_user].city_random_end = randomNumber(7, 10); }
			if (main.users[current_user].city_production_modifier == undefined) { main.users[current_user].city_production_modifier = 0.60; }
			if (main.users[current_user].city_research_modifier == undefined) { main.users[current_user].city_research_modifier = 0.50; }
			if (main.users[current_user].city_stability_modifier == undefined) { main.users[current_user].city_stability_modifier = 0.50; }
			
			//Population
			if (main.users[current_user].culture == undefined) { main.users[current_user].culture = ""; }
			if (main.users[current_user].accepted_cultures == undefined) { main.users[current_user].accepted_cultures = []; }
			if (main.users[current_user]["pops"].pop_array == undefined) { main.users[current_user]["pops"].pop_array = []; }
			for (var i = 0; i < config.pop_array.length; i++) {
				if (main.users[current_user][config.pop_array[i]] == undefined) { main.users[current_user][config.pop_array[i]] = 0; }
				if (main.users[current_user]["used_" + config.pop_array[i]] == undefined) { main.users[current_user]["used_" + config.pop_array[i]] = 0; }
			}
			if (main.users[current_user].pop_tax_efficiency == undefined) { main.users[current_user].pop_tax_efficiency = 0; }
			if (main.users[current_user].pop_stability == undefined) { main.users[current_user].pop_stability = 0; }
			if (main.users[current_user].pop_research_efficiency == undefined) { main.users[current_user].pop_research_efficiency = 0; }
			if (main.users[current_user].pop_knowledge == undefined) { main.users[current_user].pop_knowledge = 0; }
			
			//Assimilation and accepted cultures
			if (main.users[current_user].assimilations == undefined) { main.users[current_user].assimilations = []; }
			if (main.users[current_user].cultural_integrations == undefined) { main.users[current_user].cultural_integrations = []; }
			
			//Add all military units
			for (var i = 0; i < config.units.length; i++) {
				if (main.users[current_user]["military"][config.units[i]] == undefined) { main.users[current_user]["military"][config.units[i]] = 0; }
			}
			
			if (main.users[current_user]["armies"] == undefined) { main.users[current_user]["armies"] = {}; }
			if (main.users[current_user]["armies"].army_array == undefined) { main.users[current_user]["armies"].army_array = []; }
			
			if (main.users[current_user].last_election == undefined) { main.users[current_user].last_election = 0; }
			
			//Trade [[3, "iron"], "213287117017710593", 3]
			if (main.users[current_user].auto_trades == undefined) { main.users[current_user].auto_trades = []; }
			if (main.users[current_user].trade_array == undefined) { main.users[current_user].trade_array = []; }
			
			//Stats
			if (main.users[current_user].last_turn_income == undefined) { main.users[current_user].last_turn_income = 0; }
			if (main.users[current_user].stability_reform_desire == undefined) { main.users[current_user].stability_reform_desire = 0; }
			
			if (already_registered == false) {
				//City bonuses
				main.users[current_user].modifiers.production_efficiency = main.users[current_user].modifiers.production_efficiency + main.users[current_user].city_production_modifier;
				main.users[current_user].modifiers.research_efficiency = main.users[current_user].modifiers.research_efficiency + main.users[current_user].city_research_modifier;
				main.users[current_user].stability = main.users[current_user].stability + main.users[current_user].city_stability_modifier;
				
				//Starting kit
				main.users[current_user].government = "anarchy";
				main.users[current_user].politics.anarchy = 100;
				main.users[current_user].actions = config.starting_actions;
				main.users[current_user].mobilise_unit = config.mobilise_unit;
				main.users[current_user].money = 35000;
				main.users[current_user]["inventory"].wood = 10;
				main.users[current_user]["inventory"].stone = 15;
				main.users[current_user]["inventory"].food = 50;
				main.users[current_user]["military"].conquistadors = randomNumber(3,15);
				
				main.users[current_user]["available_buildings"] = ["guilds","farms","quarries","lumberjacks","barracks","dockyards","schools","libraries"];
				main.users[current_user]["available_units"] = ["skirmishers","spearmen","swordsmen","knights","archers","longbowmen","conquistadors"];
				
				//Starting governments
				main.users[current_user].available_governments = ["absolute_monarchy", "constitutional_monarchy", "democracy"];
				
				//Push at end
				main.user_array.push(current_user);
			}
			
			//Temp logic
			{
				main.users[current_user].actions = Math.round(main.users[current_user].actions);
				if (main.users[current_user].used_manpower < 0) {
					main.users[current_user].used_manpower = 0;
				} else if (main.users[current_user].used_manpower > main.users[current_user].manpower) {
					main.users[current_user].used_manpower = main.users[current_user].manpower;
				}
					
				if (main.users[current_user].used_soldiers < 0) {
					main.users[current_user].used_soldiers = 0;
				}
				
				//Round all materials and other things to whole numbers
				
				main.users[current_user].stability = Math.round(main.users[current_user].stability);
				for (var i = 0; i < config.materials.length; i++) {
					main.users[current_user].inventory[config.materials[i]] = Math.round(main.users[current_user].inventory[config.materials[i]]);
				}
				
				var user = main.users[current_user];
				var cities = main.users[current_user].cities;
				
				for (var i = 0; i < cities.city_array.length; i++) {
					cities[cities.city_array[i]].building_cap = 5 + Math.ceil(cities[cities.city_array[i]].population/200000) + Math.ceil(10*(user.provinces/user.city_count));
				}
				
				for (var i = 0; i < config.unit_categories.length; i++) {
					main.users[current_user][config.unit_categories[i] + "_cp"] = Math.round(main.users[current_user][config.unit_categories[i] + "_cp"]);
				}
				
				//Reforms
				var all_reform_categories = Object.keys(config.reforms);
				for (var i = 0; i < all_reform_categories.length; i++) {
					var all_reforms_in_category = Object.keys(config.reforms[all_reform_categories[i]]);
					for (var x = 0; x < all_reforms_in_category.length; x++) {
						if (all_reforms_in_category[x] == "name") {
							all_reforms_in_category.splice(x, 1);
						}
					}
					
					if (main.users[current_user][all_reform_categories[i]] == undefined) { main.users[current_user][all_reform_categories[i]] = all_reforms_in_category[0]; }
				}
				
				//Relations
				var temp_user_array = main.user_array;
				if (main.users[current_user].used_diplomatic_slots == undefined) { main.users[current_user].used_diplomatic_slots = 0; }
				if (main.users[current_user].rival_slots == undefined) { main.users[current_user].rival_slots = 0; }
				if (main.users[current_user].relations == undefined) { main.users[current_user].relations = []; }
				if (main.users[current_user].allies == undefined) { main.users[current_user].allies = []; }
				if (main.users[current_user].rivals == undefined) { main.users[current_user].rivals = []; }
				if (main.users[current_user].guarantees == undefined) { main.users[current_user].guarantees = []; }
				if (main.users[current_user].military_access == undefined) { main.users[current_user].military_access = []; }
				if (main.users[current_user].non_aggression_pacts == undefined) { main.users[current_user].non_aggression_pacts = []; }
				if (main.users[current_user].vassals == undefined) { main.users[current_user].vassals = []; }
				
				if (main.users[current_user].casus_belli == undefined) { main.users[current_user].casus_belli = []; }
				if (main.users[current_user].justifications == undefined) { main.users[current_user].justifications = []; }
				if (main.users[current_user].wargoals == undefined) { main.users[current_user].wargoals = []; }
				if (main.users[current_user].blockaded_by == undefined) { main.users[current_user].blockaded_by = ""; }
				
				if (main.users[current_user].vassal_years == undefined) { main.users[current_user].vassal_years = 0; }
				
				//[[value, player_id, [improving/decreasing/none, turns]]
				for (var i = 0; i < temp_user_array.length; i++) {
					var player_currently_exists_in_array = false;
					for (var x = 0; x < user.relations.length; x++) {
						if (user.relations[x][1] == temp_user_array[i]) {
							player_currently_exists_in_array = true;
						}
					}
					
					if (player_currently_exists_in_array == false) {
						//Add relation as neutral
						if (temp_user_array[i] != current_user) { //Can't have relations with yourself
							user.relations.push([0, temp_user_array[i], ["none", 0]]);
						}
					}
				}
			}
		}
		
		function nextTurn (arg0_user) {
			let user = client.users.cache.find(user => user.id.toString() == arg0_user);
			var user_id = main.users[arg0_user];
			var age = main.users[arg0_user].technology_level-1;
			var inventory = main.users[arg0_user]["inventory"];
			var cities = main.users[arg0_user]["cities"];
			
			//News variables:
			
			var national_news = "";
			
			var famine_loss = Math.ceil(user_id.population*0.1);
			
			//Army movement and Combat
			{
				for (var i = 0; i < user_id.armies.army_array.length; i++) {
					user_id.armies[user_id.armies.army_array[i]].submarine_cooldown = false;
					if (user_id.armies[user_id.armies.army_array[i]].moving_to != user_id.armies[user_id.armies.army_array[i]].province) {
						var new_province = 0;
						var current_speed = Math.ceil(config.army_speed*user_id.modifiers.army_travel_speed);
						if ((parseInt(user_id.armies[user_id.armies.army_array[i]].province)-parseInt(user_id.armies[user_id.armies.army_array[i]].moving_to)) < 0) {
							//200-20 < 181
							for (var x = 0; x < current_speed; x++) {
								if (user_id.armies[user_id.armies.army_array[i]].province != user_id.armies[user_id.armies.army_array[i]].moving_to) {
									user_id.armies[user_id.armies.army_array[i]].province =(parseInt(user_id.armies[user_id.armies.army_array[i]].province) + 1).toString();
								}
								//Add combat check here to test if the army has collided into the armies of any hostile users
								if (user_id.at_war.length > 0) {
									for (var y = 0; y < user_id.at_war.length; y++) {
										for (var z = 0; z < main.user_array.length; z++) {
											if (main.users[main.user_array[z]].name == user_id.at_war[y]) {
												for (var a = 0; a < main.users[main.user_array[z]].armies.army_array.length; a++) {
													var army_obj = main.users[main.user_array[z]].armies[main.users[main.user_array[z]].armies.army_array[a]];
													if (army_obj.province == user_id.armies[user_id.armies.army_array[i]].province) {
														if (army_obj.name != "deleted-army" && user_id.armies[user_id.armies.army_array[i]].name != "deleted-army") {
															combat(main.user_array[z], army_obj.name, user_id.id, user_id.armies[user_id.armies.army_array[i]].name, army_obj.province, "none");
														}
													}
												}
											}
										}
									}
								}
							}
						} else {
							//250+20 < 260
							for (var x = 0; x < current_speed; x++) {
								if (user_id.armies[user_id.armies.army_array[i]].province != user_id.armies[user_id.armies.army_array[i]].moving_to) {
									user_id.armies[user_id.armies.army_array[i]].province = (parseInt(user_id.armies[user_id.armies.army_array[i]].province) - 1).toString();
								}
								//Add combat check here to test if the army has collided into the armies of any hostile users
								if (user_id.at_war.length > 0) {
									for (var y = 0; y < user_id.at_war.length; y++) {
										for (var z = 0; z < main.user_array.length; z++) {
											if (main.users[main.user_array[z]].name == user_id.at_war[y]) {
												for (var a = 0; a < main.users[main.user_array[z]].armies.army_array.length; a++) {
													var army_obj = main.users[main.user_array[z]].armies[main.users[main.user_array[z]].armies.army_array[a]];
													if (army_obj.province == user_id.armies[user_id.armies.army_array[i]].province) {
														if (army_obj.name != "deleted-army" && user_id.armies[user_id.armies.army_array[i]].name != "deleted-army") {
															combat(main.user_array[z], army_obj.name, user_id.id, user_id.armies[user_id.armies.army_array[i]].name, army_obj.province, "none");
														}
													}
												}
											}
										}
									}
								}
							}
						}
						
						if (user_id.armies[user_id.armies.army_array[i]].moving_to == user_id.armies[user_id.armies.army_array[i]].province) {
							user_id.armies[user_id.armies.army_array[i]].state = "stationed";
						}
					} else {
						user_id.armies[user_id.armies.army_array[i]].state = "stationed";
						user_id.armies[user_id.armies.army_array[i]].stationary_turns++;
					}
					
					//Check if the nation the army belongs to has military access through the province, if not, add the territorial violation CB to that user.
					var has_mil_access = false;
					var other_user = "";
					for (var x = 0; x < main.user_array.length; x++) {
						if (main.users[main.user_array[x]].pops[user_id.armies.army_array[i].province] != undefined) {
							if (user_id.pops[user_id.armies.army_array[i].province] == undefined) {
								for (var y = 0; y < user_id.military_access.length; y++) {
									if (user_id.military_access[y] == main.user_array[x]) {
										has_mil_access = true;
									}
								}
								if (has_mil_access == false) {
									other_user = main.users[main.user_array[x]];
								}
							} else {
								has_mil_access = true;
							}
						} else {
							has_mil_access = true;
						}
					}
					
					if (has_mil_access == false) {
						other_user.casus_belli.push(["territorial_violation", usr.id, 3]);
						returnChannel(war_channel).send("<@" + other_user.id + "> has gained the **Territorial Violation** CB on <@" + user_id.id + ">!");
					}
					
					//Reduce cooldown timer if above 0
					if (user_id.armies[user_id.armies.army_array[i]].can_move[1] > 0) {
						user_id.armies[user_id.armies.army_array[i]].can_move[1]--;
					}
					if (user_id.armies[user_id.armies.army_array[i]].can_move[1] == 0) {
						user_id.armies[user_id.armies.army_array[i]].can_move[0] = true;
					}
					
					//Blockade cooldown timers
					if (user_id.armies[user_id.armies.army_array[i]].blockade_recovery_turns > 0) {
						user_id.armies[user_id.armies.army_array[i]].blockade_recovery_turns--;
					}
				}
				
				//Naval blockade cooldown
				for (var i = 0; i < main.user_array.length; i++) {
					if (user_id["blockade_cooldown_" + main.user_array[i]] != undefined) {
						if (user_id["blockade_cooldown_" + main.user_array[i]] > 0) {
							user_id["blockade_cooldown_" + main.user_array[i]]--;
						}
						if (user_id["blockade_cooldown_" + main.user_array[i]] == 0) {
							delete user_id["blockade_cooldown_" + main.user_array[i]];
						}
					}
				}
			}
			
			//Building production
			{
				user_id.actions = user_id.actions + config.starting_actions; //Base actions
				
				user_id.actions = user_id.actions + 5; //Base actions
				
				//All buildings
				
				/*Crafting Points (CP):
				 ground_units_cp
				 ground_artillery_cp
				 ground_vehicles_cp
				 aeroplanes_cp
				 naval_units_cp
				 colonists_cp
				*/
				
				user_id.ground_units_cp = 0;
				user_id.ground_artillery_cp = 0;
				user_id.ground_vehicles_cp = 0;
				user_id.aeroplanes_cp = 0;
				user_id.naval_units_cp = 0;
				user_id.colonists_cp = 0;
				
				if (cities.city_array.length > 0) {
					for (var i = 0; i < cities.city_array.length; i++) {
						var province_occupied = false;
						
						if (main.users.global.occupations != undefined) {
							for (var x = 0; x < main.users.global.occupations.length; x++) {
								if (main.users.global.occupations[x][0] == cities[cities.city_array[i]].province) {
									province_occupied = true;
								}
							}
						}
						
						if (province_occupied == false) {
							for (var x = 0; x < config.buildings.length; x++) {
								for (var y = 0; y < cities[cities.city_array[i]]["buildings"][config.buildings[x]]; y++) {
									var object_count = cities[cities.city_array[i]]["buildings"][config.buildings[x]];
									
									if (config.building_stats[config.buildings[x]].produces != undefined) {
										for (var z = 0; z < config.building_stats[config.buildings[x]].produces.length; z++) {
											if (Array.isArray(config.building_stats[config.buildings[x]].produces[z][0])) {
												var actual_resource = false;
												var is_knowledge = false;
												for (var a = 0; a < config.materials.length; a++) {
													if (config.building_stats[config.buildings[x]].produces[z][1] == config.materials[a]) {
														actual_resource = true;
														if (config.building_stats[config.buildings[x]].produces[z][1] == "knowledge") {
															is_knowledge = true;
														}
													}
												}
												if (actual_resource == false) {
													user_id[config.building_stats[config.buildings[x]].produces[z][1]] = user_id[config.building_stats[config.buildings[x]].produces[z][1]] + randomNumber(config.building_stats[config.buildings[x]].produces[z][0][0]*user_id.modifiers.production_efficiency, config.building_stats[config.buildings[x]].produces[z][0][1]*user_id.modifiers.production_efficiency);
												} else {
													if (is_knowledge == false) {
														user_id["inventory"][config.building_stats[config.buildings[x]].produces[z][1]] = user_id["inventory"][config.building_stats[config.buildings[x]].produces[z][1]] + Math.ceil(randomNumber(config.building_stats[config.buildings[x]].produces[z][0][0]*user_id["modifiers"][config.building_stats[config.buildings[x]].produces[z][1]]*user_id.modifiers.production_efficiency, config.building_stats[config.buildings[x]].produces[z][0][1])*user_id["modifiers"][config.building_stats[config.buildings[x]].produces[z][1]]*user_id["modifiers"][config.building_stats[config.buildings[x]].produces[z][1]]*user_id.modifiers.production_efficiency);
													} else {
														user_id["inventory"][config.building_stats[config.buildings[x]].produces[z][1]] = user_id["inventory"][config.building_stats[config.buildings[x]].produces[z][1]] + Math.ceil(randomNumber(config.building_stats[config.buildings[x]].produces[z][0][0]*user_id["modifiers"][config.building_stats[config.buildings[x]].produces[z][1]], config.building_stats[config.buildings[x]].produces[z][0][1])*user_id["modifiers"][config.building_stats[config.buildings[x]].produces[z][1]]*user_id["modifiers"][config.building_stats[config.buildings[x]].produces[z][1]]);
													}
												}
											} else {
												var actual_resource = false;
												var is_knowledge = false;
												for (var a = 0; a < config.materials.length; a++) {
													if (config.building_stats[config.buildings[x]].produces[z][1] == config.materials[a]) {
														actual_resource = true;
														if (config.building_stats[config.buildings[x]].produces[z][1] == "knowledge") {
															is_knowledge = true;
														}
													}
												}
												if (actual_resource == false) {
													user_id[config.building_stats[config.buildings[x]].produces[z][1]] = user_id[config.building_stats[config.buildings[x]].produces[z][1]] + config.building_stats[config.buildings[x]].produces[z][0]*user_id.modifiers.production_efficiency;
												} else {
													if (is_knowledge == false) {
														user_id["inventory"][config.building_stats[config.buildings[x]].produces[z][1]] = user_id["inventory"][config.building_stats[config.buildings[x]].produces[z][1]] + config.building_stats[config.buildings[x]].produces[z][0]*user_id["modifiers"][config.building_stats[config.buildings[x]].produces[z][1]]*user_id.modifiers.production_efficiency;
													} else {
														user_id["inventory"][config.building_stats[config.buildings[x]].produces[z][1]] = user_id["inventory"][config.building_stats[config.buildings[x]].produces[z][1]] + config.building_stats[config.buildings[x]].produces[z][0]*user_id["modifiers"][config.building_stats[config.buildings[x]].produces[z][1]];
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				
				//Knowledge
				user_id.inventory.knowledge = user_id.inventory.knowledge*user_id.modifiers.research_efficiency;
				user_id.inventory.knowledge = user_id.inventory.knowledge + Math.ceil((user_id.faculty/100000)*config.pops.faculty.knowledge_per_100k);
				user_id.knowledge_per_turn = user_id.inventory.knowledge;
			}
			
			//Colonisation
			{
				//["conquistadors", turn_amount, [province_ids]]
				for (var i = 0; i < user_id.expeditions.length; i++) {
					if (user_id.expeditions[i][1] == 1) {
						for (var x = 0; x < user_id.expeditions[i][2].length; x++) {
							main.province_array.push(user_id.expeditions[i][2][x]);
							user_id.cities.province_array.push(user_id.expeditions[i][2][x]);
							user_id.pops.pop_array.push(user_id.expeditions[i][2][x]);
							user_id.provinces++;
							//Generate new pops
							
							var total_population = randomNumber(15000, 150000);
							var remaining_population = total_population;
							user_id.pops[user_id.expeditions[i][2][x]] = {};
							
							for (var y = 0; y < config.pop_array.length; y++) {
								if (config.pops[config.pop_array[y]].specialised_pop) {
									console.log("[Triumph & Tragedy]: Generating " + config.pop_array[y] + " for Province " + user_id.expeditions[i][2][x] + "...");
									
									var randomPercentage = randomNumber((config.pops[config.pop_array[y]].chance*100)/2, (config.pops[config.pop_array[y]].chance*100)*2);
									console.log(randomPercentage + "% - " + Math.ceil(remaining_population*(randomPercentage/100)) + " Pops");
									user_id.pops[user_id.expeditions[i][2][x]][config.pop_array[y]] = Math.ceil(remaining_population*(randomPercentage/100));
									console.log(user_id.pops[user_id.expeditions[i][2][x]][config.pop_array[y]]);
									remaining_population = remaining_population - Math.ceil(remaining_population*(randomPercentage/100));
								}
							}
							user_id.pops[user_id.expeditions[i][2][x]].workers = remaining_population;
							user_id.pops[user_id.expeditions[i][2][x]].population = total_population;
							user_id.pops[user_id.expeditions[i][2][x]].culture = user_id.culture;
							user_id.pops[user_id.expeditions[i][2][x]].political_concern = {};
							remaining_population = 0;
						}
						national_news = national_news + "\nSettlers from " + user_id.name + " have finished colonising Province(s) " + user_id.expeditions[i][2].join(", ") + "!";
						user_id.expeditions.splice(i, 1);
					} else {
						user_id.expeditions[i][1]--;
					}
				}
			}
			
			//Diplomacy
			{
				if (user_id.infamy > 0) {
					user_id.infamy = user_id.infamy - user_id.infamy_loss;
				}
				if (user_id.infamy < 0) {
					user_id.infamy = 0;
				}
				
				//CB cooldowns
				{
					var remove_cbs = [];
					if (user_id.casus_belli.length > 0) {
						for (var i = 0; i < user_id.casus_belli.length; i++) {
							if (user_id.casus_belli[i][2] == 1) {
								remove_cbs.push(user_id.casus_belli[i]);
							} else {
								user_id.casus_belli[i][2]--;
							}
						}
					}
					if (remove_cbs.length > 0) {
						for (var i = 0; i < remove_cbs.length; i++) {
							for (var x = 0; x < user_id.casus_belli.length; x++) {
								if (user_id.casus_belli[x] == remove_cbs[i]) {
									user_id.casus_belli.splice(x, 1);
								}
							}
						}
					}
				}
				
				//CB handouts
				{
					//containment
					if (user_id.infamy > 8) {
						returnChannel(war_channel).send("<@" + user_id.id + "> has exceeded the infamy limit! Everyone may now justify a containment wargoal on this user.");
						for (var i = 0; i < main.user_array.length; i++) {
							if (main.user_array[i] != user_id.id) {
								main.users[main.user_array[i]].casus_belli.push(["containment", usr.id, 1]);
							}
						}
					}
					
					var attacker_ap = 0;
					for (var i = 0; i < user_id.armies.army_array.length; i++) {
						for (var x = 0; x < config.units.length; x++) {
							attacker_ap = attacker_ap + user_id.armies[user_id.armies.army_array[i]][config.units[x]]*config.unit_stats[config.units[x]].ap;
						}
					}
					
					//colonial_integration
					for (var i = 0; i < main.user_array.length; i++) {
						var defender_ap = 0;
						
						for (var x = 0; x < main.users[main.user_array[i]].armies.army_array.length; x++) {
							for (var y = 0; y < config.units.length; y++) {
								defender_ap = defender_ap + main.users[main.user_array[i]].armies[main.users[main.user_array[i]].armies.army_array[x]][config.units[y]]*config.unit_stats[config.units[y]].ap;
							}
						}
					
						if (attacker_ap > defender_ap*4) {
							if (main.user_array[i] != user_id.id) {
								user_id.casus_belli.push(["colonial_integration", main.user_array[i], 1]);
							}
						}
					}
					
					//free_oppressed_people
					if (user_id.government == "democracy" || user_id.government == "constitutional_monarchy") {
						for (var i = 0; i < main.user_array.length; i++) {
							if (main.users[main.user_array[i]].infamy > 3) {
								if (main.users[main.user_array[i]].government != "democracy" && main.users[main.user_array[i]].government != "constitutional_monarchy") {
									if (main.user_array[i] != user_id.id) {
										user_id.casus_belli.push(["free_oppressed_people", main.user_array[i], 1]);
									}
								}
							}
						}
					}
					
					//independence
					if (user_id.vassal_years > 5) {
						for (var i = 0; i < main.user_array.length; i++) {
							for (var x = 0; x < main.users[main.user_array[i]].vassals.length; x++) {
								if (main.users[main.user_array[i]].vassals[x] == user_id.id) {
									if (main.user_array[i] != user_id.id) {
										user_id.casus_belli.push(["independence", main.user_array[i], 1]);
									}
								}
							}
						}
					}
					
					//revanchism
					for (var i = 0; i < main.user_array.length; i++) {
						var all_provs = Object.keys(main.users[main.user_array[i]].pops);
						
						for (var x = 0; x < all_provs.length; x++) {
							if (main.user_array[i] != user_id.id) {
								if (main.users[main.user_array[i]].pops[all_provs[x]].culture == user_id.culture) {
									user_id.casus_belli.push(["revanchism", main.user_array[i], 1]);
								}
							}
						}
					}
					
					//lebensraum
					if (user_id.government == "absolute_monarchy" || user_id.government == "fascism" || user_id.government == "communism") {
						for (var i = 0; i < main.user_array.length; i++) {
							if (main.user_array[i] != user_id.id) {
								user_id.casus_belli.push(["lebensraum", main.user_array[i], 1]);
							}
						}
					}
					
					//acquire_state
					for (var i = 0; i < main.user_array.length; i++) {
						if (Math.abs(main.users[main.user_array[i]].capital_id-user_id.capital_id) < 100) {
							var attacker_ap = 0;
							var defender_ap = 0;
							
							for (var x = 0; x < user_id.armies.army_array.length; x++) {
								for (var y = 0; y < config.units.length; y++) {
									attacker_ap = attacker_ap + user_id.armies[user_id.armies.army_array[x]][config.units[y]]*config.unit_stats[config.units[y]].ap;
								}
							}
							for (var x = 0; x < main.users[main.user_array[i]].armies.army_array.length; x++) {
								for (var y = 0; y < config.units.length; y++) {
									defender_ap = defender_ap + main.users[main.user_array[i]].armies[main.users[main.user_array[i]].armies.army_array[x]]*config.unit_stats[config.units[y]].ap;
								}
							}
							
							if (attacker_ap > defender_ap*2) {
								if (main.user_array[i] != user_id.id) {
									user_id.casus_belli.push(["acquire_state", main.user_array[i], 1]);
								}
							}
						}
					}
				}
				
				//Improve/decrease relations
				//[[value, player_id, [improving/decreasing/none, turns]]
				
				if (user_id.relations.length > 0) {
					for (var i = 0; i < user_id.relations.length; i++) {
						if (user_id.relations[i][2][1] > 0) {
							user_id.relations[i][2][1]--;
						} else {
							user_id.relations[i][2][1] = 0;
						}
						
						if (user_id.relations[i][2][1] == 0) {
							user_id.relations[i][2][0] = "none";
						}
						
						//[[0,"453420991536824340",["improving",4]]]
						//Increase/decrease relations
						if (user_id.relations[i][2][0] == "improving") {
							if (user_id.relations[i][0]+10 <= 100) {
								user_id.relations[i][0] = user_id.relations[i][0] + 10;
							} else {
								user_id.relations[i][0] = 100;
								user_id.relations[i][2][0] = "none";
								user_id.relations[i][2][1] = 0;
							}
						} else if (user_id.relations[i][2][0] == "decreasing") {
							if (user_id.relations[i][0]-10 >= -100) {
								user_id.relations[i][0] = user_id.relations[i][0] - 10;
								user_id.casus_belli.push(["diplomatic_insult", main.user_array[i], 1]);
							} else {
								user_id.relations[i][0] = -100;
								user_id.relations[i][2][0] = "none";
								user_id.relations[i][2][1] = 0;
							}
						}
					}
				}
				
				//Non-Aggression Pact
				//[[user_id, turns_before_expiry]]
				if (user_id.non_aggression_pacts.length > 0) {
					for (var i = 0; i < user_id.non_aggression_pacts.length; i++) {
						if (user_id.non_aggression_pacts[i][1] > 0) {
							user_id.non_aggression_pacts[i][1]--;
						}
						if (user_id.non_aggression_pacts == 0) {
							localisation.push(user_id.name);
							printEvent(user_id.non_aggression_pacts[i][0], "non_aggression_pact_expired");
							for (var x = 0; x < main.users[user_id.non_aggression_pacts[i][0]].non_aggression_pacts.length; x++) {
								if (main.users[user_id.non_aggression_pacts[i][0]].non_aggression_pacts[x][0] == arg0_user) {
									main.users[user_id.non_aggression_pacts[i][0]].non_aggression_pacts.splice(x, 1);
								}
							}
							user_id.non_aggression_pacts.splice(x, 1);
						}
					}
				}
				
				if (user_id.vassals.length > 0) {
					for (var i = 0; i < user_id.vassals.length; i++) {
						main.users[user_id.vassals[i]].vassal_years++;
					}
				}
				
				//Prestige
				user_id.prestige = user_id.prestige + user_id.modifiers.prestige_gain;
				
				if (user_id.prestige < 0) {
					user_id.prestige = 0;
				}
				
				//Wargoal justification
				if (user_id.justifications.length > 0) {
					var elements_for_removal = [];
					var removed_elements = 0;
					for (var i = 0; i < user_id.justifications.length; i++) {
						if (user_id.justifications[i][2] > 0) {
							user_id.justifications[i][2]--;
						}
						
						if (user_id.justifications[i][2] > 0) {
							returnChannel(war_channel).send("War justification will complete in **" + parseNumber(user_id.justifications[i][2]) + "** turns.");
						}
						
						if (user_id.justifications[i][2] == 0) {
							returnChannel(war_channel).send("<@" + user_id.id + "> has finished justification on <@" + user_id.justifications[i][1] + ">! (CB: **" + config.casus_belli[user_id.justifications[i][0]].name + "**).");
							//[CB, nation]
							user_id.wargoals.push([user_id.justifications[i][0], user_id.justifications[i][1]]);
							elements_for_removal.push(user_id.justifications[i]);
						}
					}
					for (var i = 0; i < elements_for_removal.length; i++) {
						for (var x = 0; x < user_id.justifications.length; x++) {
							if (user_id.justifications[x] == elements_for_removal[i]) {
								user_id.justifications.splice(x, 1);
							}
						}
					}
				}
				
				//War Exhaustion Ticker
				if (user_id.at_war.length > 0) {
					if (user_id.modifiers.war_exhaustion+user_id.modifiers.war_exhaustion_rate < 100 && user_id.modifiers.war_exhaustion+user_id.modifiers.war_exhaustion_rate > 0) {
						user_id.modifiers.war_exhaustion = user_id.modifiers.war_exhaustion + user_id.modifiers.war_exhaustion_rate;
					} else if (user_id.modifiers.war_exhaustion+user_id.modifiers.war_exhaustion_rate >= 100) {
						user_id.modifiers.war_exhaustion = 100;
					} else {
						user_id.modifiers.war_exhaustion = 0;
					}
				}
			}
			
			//Events
			{
				//Check for event trigger
				var all_events = Object.keys(config.events);
				
				if (all_events.length > 0) {
					for (var i = 0; i < all_events.length; i++) {
						console.log("[Triumph & Tragedy]: Going through Event " + all_events[i]);
						if (config.events[all_events[i]].trigger != undefined) {
							if (config.events[all_events[i]].trigger(user_id)) {
								printEvent(arg0_user, all_events[i]);
								
								if (user_id.triggered_events[all_events[i]] == undefined) {
									user_id.triggered_events[all_events[i]] = 0;
								} else {
									user_id.triggered_events[all_events[i]]++;
								}
							}
						}
					}
				}
				
				//Auto-expiry
				if (user_id.events.length > 0) {
					for (var i = 0; i < user_id.events.length; i++) {
						if (user_id.events[i][0][1] > 0) {
							user_id.events[i][0][1]--;
						} else {
							//Automatically pick an option
							console.log("[Triumph & Tragedy]: " + user_id.events[i][2]);
							var all_options = [];
							for (var x = 0; x < user_id.events[i][2].length+1; x++) {
								var alphabet = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
								if (config.events[user_id.events[i][0][0]]["option_" + alphabet[x]] != undefined) {
									all_options.push("option_" + alphabet[x]);
								}
								if (x == user_id.events[i][2].length) {
									config.events[user_id.events[i][0][0]][randomElement(all_options)];
								} else {
									var random_chance = randomNumber(0, 100);
									if (random_chance <= user_id.events[i][2][x]) {
										config.events[user_id.events[i][0][0]]["option_" + alphabet[x]](user_id);
										if (user != undefined) {
											user.send("<:old_scroll:716828676880334881> Event **" + user_id.events[i][0][0] + "** was automatically resolved.");
										}
									}
								}
							}
							user_id.events.splice(i, 1);
						}
					}
				}
			}
			
			//Modifiers
			{
				var get_temporary_modifiers = user_id.temporary_modifiers;
				console.log("[Triumph & Tragedy]: Temporary Modifiers for " + user_id.name + ": " + get_temporary_modifiers);
				
				if (get_temporary_modifiers.length > 0) {
					for (var i = 0; i < get_temporary_modifiers.length; i++) {
						//[modifier_id, amount, turns_before_expiry, already_applied]
						var current_id = get_temporary_modifiers[i][0];
						var current_amount = get_temporary_modifiers[i][1];
						
						//Check if modifier expired
						if (get_temporary_modifiers[i][2] > 0) {
							user_id.temporary_modifiers[i][2]--;
						} else if (get_temporary_modifiers[i][2] == 0) {
							if (current_id != "stability" && current_id != "pop_growth_modifier") {
								user_id.modifiers[current_id] = user_id.modifiers[current_id] - get_temporary_modifiers[i][1];
							} else {
								user_id[current_id] = user_id[current_id] - parseInt(get_temporary_modifiers[i][1]);
							}
							user_id.temporary_modifiers.splice(i, 1);
						}
						
						if (get_temporary_modifiers[i] != undefined) {
							if (get_temporary_modifiers[i][3] != true) {
								if (current_id != "stability" && current_id != "pop_growth_modifier") {
									user_id.modifiers[current_id] = user_id.modifiers[current_id] + get_temporary_modifiers[i][1];
								} else {
									user_id[current_id] = user_id[current_id] - parseInt(get_temporary_modifiers[i][1]);
								}
								user_id.temporary_modifiers[i][3] = true;
							}
						}
					}
				}
			}
			
			//Politics
			{
				//Political Discontent Modifiers - Keep at top, applies modifiers
				{
					//Subtract first to level the playing field
					user_id.modifiers.political_capital_gain = user_id.modifiers.political_capital_gain - user_id.political_capital_gain_modifier;
					user_id.modifiers.reform_desire_gain = user_id.modifiers.reform_desire_gain - user_id.political_reform_desire_modifier;
					user_id.modifiers.stability_modifier = user_id.modifiers.stability_modifier - user_id.political_instability_modifier;
					user_id.political_capital_gain_modifier = 0;
					user_id.political_reform_desire_modifier = 0;
					user_id.political_instability_modifier = 0;
					
					//Negatively impacts stability, reform desire gain, and political capital gain; only begins impacting if party discontent is over 25.
					//Max political_capital_gain_modifier = -5
					//Max political_reform_desire_modifier = 0.2
					//Max political_instability_modifier = -35
					for (var i = 0; i < config.government_list.length; i++) {
						if (user_id["politics"][config.government_list[i]] > 0) {
							if (user_id["modifiers"][config.government_list[i] + "_discontent"] > 25) {
								user_id.political_capital_gain_modifier = user_id.political_capital_gain_modifier + (-5*user_id["politics"][config.government_list[i]]*(user_id["modifiers"][config.government_list[i] + "_discontent"]/100));
								user_id.political_reform_desire_modifier = user_id.political_reform_desire_modifier + (0.2*user_id["politics"][config.government_list[i]]*(user_id["modifiers"][config.government_list[i] + "_discontent"]/100));
								user_id.political_instability_modifier = user_id.political_instability_modifier + (-35*user_id["politics"][config.government_list[i]]*(user_id["modifiers"][config.government_list[i] + "_discontent"]/100));
							}
						}
					}
					
					//Reapply modifiers
					user_id.modifiers.political_capital_gain = user_id.modifiers.political_capital_gain + user_id.political_capital_gain_modifier;
					user_id.modifiers.reform_desire_gain = user_id.modifiers.reform_desire_gain + user_id.political_reform_desire_modifier;
					user_id.modifiers.stability_modifier = user_id.modifiers.stability_modifier + user_id.political_instability_modifier;
				}
				
				//Political Capital
				{
					user_id.political_capital = user_id.political_capital + user_id.modifiers.political_capital_gain;
					
					//accepted_cultures maintenance for political capital, 1 per accepted culture.
					for (var i = 0; i < user_id.accepted_cultures.length; i++) {
						if (user_id.accepted_cultures[i] != user_id.culture) {
							user_id.political_capital = user_id.political_capital - config.accepted_culture_maintenance_cost;
						}
					}
					
					user_id.political_capital = Math.round(user_id.political_capital);
				}
				
				//Politics
				{
					var most_popular_percentage = 0;
					var most_popular_party = "";
					for (var i = 0; i < config.government_list.length; i++) {
						if (user_id["politics"][config.government_list[i]] >= most_popular_percentage) {
							most_popular_percentage = user_id["politics"][config.government_list[i]];
							most_popular_party = config.government_list[i];
						}
					}
					
					var total_change = 0;
					for (var i = 0; i < config.government_list.length; i++) {
						var valid_ideology = false;
						for (var x = 0; x < user_id.available_governments.length; x++) {
							if (user_id.available_governments[x] == config.government_list[i]) {
								valid_ideology = true;
							}
						}
						
						if (valid_ideology) {
							total_change = total_change + user_id["modifiers"][config.government_list[i]];
							user_id["politics"][config.government_list[i]] = user_id["politics"][config.government_list[i]] + user_id["modifiers"][config.government_list[i]];
						}
					}
					console.log("[Triumph & Tragedy]: Most Popular Party in " + user_id.name + " is: " + most_popular_party);
					console.log("[Triumph & Tragedy]: Total Change in Popularity: " + total_change);
					
					user_id["politics"][most_popular_party] = user_id["politics"][most_popular_party] - total_change;
					
					//Make sure all percentages equal 100%.
					var total_percentage = 0;
					
					for (var i = 0; i < config.government_list.length; i++) {
						if (user_id["politics"][config.government_list[i]] < 0) {
							user_id["politics"][config.government_list[i]] = 0;
						}
						total_percentage = total_percentage + user_id["politics"][config.government_list[i]];
					}
					if (total_percentage < 100) {
						user_id["politics"][most_popular_party] = user_id["politics"][most_popular_party] + (100-total_percentage);
					} else if (total_percentage > 100) {
						user_id["politics"][most_popular_party] = user_id["politics"][most_popular_party] - (total_percentage-100);
					}
					
					if (user_id["politics"][most_popular_party] < 0) {
						user_id["politics"][most_popular_party] = 0;
					}
					
					//Reconduct check after processing
					for (var i = 0; i < config.government_list.length; i++) {
						if (user_id["politics"][config.government_list[i]] >= most_popular_percentage) {
							most_popular_percentage = user_id["politics"][config.government_list[i]];
							most_popular_party = config.government_list[i];
						}
					}
					
					//Conduct election - 8 >= 5
					if (main.roundCount >= user_id.last_election+3) {
						var election_winner = most_popular_party;
						
						if (config.governments[user_id.government].has_elections == true) {
							setGovernment(user_id, most_popular_party);
							user_id.last_election = main.roundCount;
							national_news = national_news + "\nThe " + config.governments[most_popular_party].name[1].toLowerCase() + " managed to secure an electoral victory for themselves in the country of " + user_id.name + ".";
						} else {
							national_news = national_news + "\nThe country of " + user_id.name + " " + randomElement(flavour_text.rigged_elections);
							user_id.last_election = main.roundCount;
						}
					}
					
					//Reset political parties if anarchy
					if (user_id.government == "anarchy") {
						for (var i = 0; i < config.government_list.length; i++) {
							user_id.politics[config.government_list[i]] = 0;
						}
						user_id.politics["anarchy"] = 100;
					}
				}
				
				//Reform Desire
				{
					var total_reform_desire_gain = user_id.modifiers.reform_desire_gain;
					for (var i = 0; i < config.government_list.length; i++) {
						if (user_id.politics[config.government_list[i]] > 0) {
							if (config.governments[config.government_list[i]].reform_desire != undefined) {
								total_reform_desire_gain = total_reform_desire_gain + config.governments[config.government_list[i]].reform_desire*(user_id.politics[config.government_list[i]]/100);
							}
						}
					}
					if (total_reform_desire_gain > 0.15) { //15% cap
						total_reform_desire_gain = 0.15;
					}
					
					user_id.modifiers.reform_desire = user_id.modifiers.reform_desire + total_reform_desire_gain;
					
					if (user_id.modifiers.reform_desire < 0) {
						user_id.modifiers.reform_desire = 0;
					} else if (user_id.modifiers.reform_desire > 1) {
						user_id.modifiers.reform_desire = 1;
					}
					
					//If no reforms are unlocked, reset Reform Desire
					if (user_id.available_reforms.length == 0) {
						user_id.modifiers.reform_desire = 0;
					}
					
					//Check if reform desire is at 100%, if so, add discontent to all parties with a popularity greater than 0%.
					if (user_id.modifiers.reform_desire == 1) {
						for (var i = 0; i < config.government_list.length; i++) {
							if (user_id.politics[config.government_list[i]] > 0) {
								user_id.modifiers[config.government_list[i] + "_discontent"] = user_id.modifiers[config.government_list[i] + "_discontent"] + 10;
								if (user_id.modifiers[config.government_list[i] + "_discontent"] > 100) {
									user_id.modifiers[config.government_list[i] + "_discontent"] = 0;
								}
							}
						}
					}
				}
				
				//Stability and revolt risk
				{
					//Infamy decay
					if (user_id.infamy > 0) {
						user_id.infamy = user_id.infamy - 0.5;
					}
					
					var stab_tax_rate = user_id.tax_rate*100;
					var stab_party_popularity = (user_id["politics"][user_id.government]*0.75);
					var stab_government_modifier = 0;
					var age_modifier = 0;
					
					if (config.governments[user_id.government].stability != undefined) {
						stab_government_modifier = config.governments[user_id.government].stability;
					}
					
					if (user_id.technology_level == 3) {
						age_modifier = 5;
					} else if (user_id.technology_level == 4) {
						age_modifier = 15;
					} else if (user_id.technology_level == 5) {
						age_modifier = 10;
					} else if (user_id.technology_level == 6) {
						age_modifier = 20;
					} else if (user_id.technology_level == 9) {
						age_modifier = -15;
					}
					
					user_id.stability = Math.ceil(25 + stab_party_popularity + stab_government_modifier - Math.ceil(stab_tax_rate) - Math.ceil(user_id.provinces/5) + age_modifier + user_id.stability_decay + user_id.modifiers.stability_modifier);
					
					if (user_id.stability > 100) {
						user_id.stability = 100;
					} else if (user_id.stability < 0) {
						user_id.stability = 0;
					}
					
					if (user_id.stability_decay > 0) {
						user_id.stability_decay--;
						user_id.stability--;
					}
					
					var dice_roll = randomNumber(0, 100);
					if (dice_roll > user_id.stability+60 || user_id.coup_this_turn == true) {
						user_id.tax_rate = 0;
						var coup_list = [];
						for (var i = 0; i < user_id.available_governments.length; i++) {
							coup_list.push(user_id.available_governments[i]);
						}
						var element_to_remove = 0;
						for (var i = 0; i < coup_list.length; i++) {
							if (coup_list[i] == user_id.government) {
								element_to_remove = i;
							}
						}
						coup_list.splice(element_to_remove, 1);
						var new_government = randomElement(coup_list);
						
						console.log("[Triumph & Tragedy]: Couped to: " + new_government + " out of the following available governments: " + coup_list.join(", ") + ". This decision was made by the AI.");
						//Revolt
						setGovernment(user_id, new_government);
						
						national_news = national_news + "The country of " + user_id.name + " fell into a state of civil unrest, allowing supporters of " + user_id.government + " to coup the government!\n";
						national_news = national_news + "Rioters then went on strike, leading the country of " + user_id.name + " to lose all their actions!\n";
						user_id.coup_this_turn = false;
						user_id.actions = 0;
					}
					
					if (user_id.overthrow_this_turn != "") {
						user_id.tax_rate = 0;
						var new_government = "";
						var valid_government = false;
						
						//Check if valid ideology
						for (var i = 0; i < user_id.available_governments.length; i++) {
							if (user_id.available_governments[i] == user_id.overthrow_this_turn) {
								valid_government = true;
							}
						}
						
						if (valid_government) {
							setGovernment(user_id, user_id.overthrow_this_turn);
						}
						
						national_news = national_news + "The country of " + user_id.name + " fell into a state of civil unrest, leading supporters of " + user_id.government + " to overthrow the government!\n";
						national_news = national_news + "A general strike was called across " + user_id.name + ", causing them to lose all their actions!\n";
						user_id.overthrow_this_turn = "";
						user_id.actions = 0;
					}
					
				}
			}
			
			//Population and Upkeep
			{
				//Subtract previous bonuses
				user_id.modifiers.tax_efficiency = user_id.modifiers.tax_efficiency - (user_id.aristocrats/100000)*config.pops.aristocrats.tax_efficiency_per_100k;
				user_id.stability = user_id.stability - (user_id.aristocrats/100000)*config.pops.aristocrats.stability_per_100k;
				user_id.modifiers.research_efficiency = user_id.modifiers.research_efficiency - (user_id.faculty/100000)*config.pops.faculty.research_efficiency_per_100k;
				
				//Tax
				var previous_money = user_id.money;
				user_id.money = user_id.money + Math.ceil((user_id.actions*config.money_per_action)*user_id.tax_rate*user_id.modifiers.tax_efficiency);
				user_id.money = user_id.money - Math.ceil(user_id.used_soldiers/100*(user_id.modifiers.army_upkeep));
				user_id.last_turn_income = user_id.money - previous_money;
				
				//Food
				if (user_id.population > user_id["inventory"].food*1000000) {
					if (config.governments[user_id.government].famine_penalty != undefined) {
						if (user_id.pops.pop_array.length > 0) {
							for (var i = 0; i < user_id.pops.pop_array.length; i++) {
								for (var x = 0; x < config.pop_array.length; x++) {
									user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]] = user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]] - Math.ceil(user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]]*config.governments[user_id.government].famine_penalty);
								}
							}
						}
						national_news = national_news + "\nA famine struck citizens of " + user_id.name + " resulting in " + parseNumber(Math.ceil(user_id.population*config.governments[user_id.government].famine_penalty)) + " fatalities.";
					}
					inventory.food = 0;
				} else {
					for (var i = 0; i < user_id.pops.pop_array.length; i++) {
						for (var x = 0; x < config.pop_array.length; x++) {
							user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]] = Math.ceil(user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]]*user_id.pop_growth_modifier);
						}
					}
					inventory.food = inventory.food - Math.ceil(user_id.population/1000000);
				}
				
				inventory.food = Math.ceil(inventory.food);
				
				//Recalculate all pop types
				user_id.population = 0;
				
				var complete_population = 0;
				for (var i = 0; i < config.pop_array.length; i++) {
					user_id[config.pop_array[i]] = 0;
				}
				
				for (var i = 0; i < user_id.pops.pop_array.length; i++) {
					var prov_population = 0;
					for (var x = 0; x < config.pop_array.length; x++) {
						prov_population = prov_population + user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]];
						
						var is_core_manpower = false;
						for (var y = 0; y < user_id.accepted_cultures.length; y++) {
							if (user_id.accepted_cultures[y] == user_id.pops[user_id.pops.pop_array[i]].culture) {
								is_core_manpower = true;
							}
						}
						
						if (is_core_manpower) {
							user_id[config.pop_array[x]] = user_id[config.pop_array[x]] + user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]];
						} else {
							user_id[config.pop_array[x]] = user_id[config.pop_array[x]] + Math.ceil(user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]]*user_id.modifiers.non_core_manpower);
						}
					}
					console.log("[Triumph & Tragedy]: Population for Province " + user_id.pops.pop_array[i] + ": " + prov_population);
					user_id.pops[user_id.pops.pop_array[i]].population = prov_population;
					complete_population = complete_population + prov_population;
				}
				
				//Soldiers
				user_id.soldiers = user_id.soldiers*user_id.modifiers.national_manpower;
				user_id.population = complete_population;
				
				//Recalculate all city pops
				for (var i = 0; i < cities.city_array.length; i++) {
					var total_population = 0;
					for (var x = 0; x < config.pop_array.length; x++) {
						total_population = total_population + user_id.pops[cities[cities.city_array[i]].province][config.pop_array[x]];
					}
					cities[cities.city_array[i]].population = total_population;
				}
				
				user_id.initial_manpower = Math.ceil(user_id.soldiers*user_id.manpower_percentage*user_id.modifiers.national_manpower);
				
				//Upkeep
				if (Math.ceil(user_id.used_soldiers/100*(user_id.modifiers.army_upkeep)) > user_id.money) {
					national_news = national_news + "\nTroops in the " + user_id.name + " deserted en masse. Analysts estimate up to 15% of their armed forces and even colonists may have quite simply dissipated.";
					
					user_id.used_soldiers = user_id.used_soldiers - Math.ceil(user_id.used_soldiers*0.15);
					
					for (var i = 0; i < config.units.length; i++) {
						user_id["military"][config.units[i]] = Math.ceil(user_id["military"][config.units[i]]*0.85);
					}
					
					if (user_id.armies.army_array.length > 0) {
						for (var x = 0; x < user_id.armies.army_array.length; x++) {
							for (var i = 0; i < config.units.length; i++) {
								user_id["armies"][user_id.armies.army_array[x]][config.units[i]] = Math.ceil(user_id.armies[user_id.armies.army_array[x]][config.units[i]]*0.85);
							}
						}
					}
				}
				
				//Recalculate bonuses
				user_id.modifiers.tax_efficiency = user_id.modifiers.tax_efficiency + (user_id.aristocrats/100000)*config.pops.aristocrats.tax_efficiency_per_100k;
				user_id.stability = user_id.stability + (user_id.aristocrats/100000)*config.pops.aristocrats.stability_per_100k;
				user_id.modifiers.research_efficiency = user_id.modifiers.research_efficiency + (user_id.faculty/100000)*config.pops.faculty.research_efficiency_per_100k;
				
				//Civilian Actions
				{
					user_id.civilian_actions = Math.ceil(user_id.actions*user_id.civilian_actions_percentage);
					
					national_news = national_news + "\nThe country of " + user_id.name + " now has " + Math.floor(user_id.actions) + " actions, of which " + (Math.ceil(user_id.civilian_actions*0.5) + Math.ceil(user_id.civilian_actions*0.5)) + " were automatically used by the populace.";
					
					mine(arg0_user, "none", Math.ceil(user_id.civilian_actions*0.5));
					forage(arg0_user, "none", Math.ceil(user_id.civilian_actions*0.5));
				}
			
				//Cultural Assimilation
				{
					//assimilations: [turns, culture, province]
					if (user_id.assimilations.length > 0) {
						var remove_elements = [];
						for (var i = 0; i < user_id.assimilations.length; i++) {
							if (user_id.assimilations[i][0] > 0) {
								user_id.assimilations[i][0]--;
							}
						
							if (user_id.assimilations[i][0] == 0) {
								var province_belongs_to_user = false;
								for (var i = 0; i < user_id.pops.pop_array.length; i++) {
									if (user_id.pops.pop_array[i] == user_id.assimilations[i][2]) {
										province_belongs_to_user = true;
									}
								}
								
								if (province_belongs_to_user) {
									user_id.pops[user_id.assimilations[i][2]].culture = user_id.assimilations[i][1];
									remove_elements.push(user_id.assimilations[i]);
								}
							}
						}
						//Remove elements from assimilations array
						for (var i = 0; i < remove_elements.length; i++) {
							for (var x = 0; x < user_id.assimilations.length; x++) {
								if (user_id.assimilations[x] == remove_elements[i]) {
									user_id.assimilations.splice(x, 1);
								}
							}
						}
						remove_elements = [];
					}
					
					//cultural_integrations: [turns, culture]
					if (user_id.cultural_integrations.length > 0) {
						var remove_elements = [];
						for (var i = 0; i < user_id.cultural_integrations.length; i++) {
							if (user_id.cultural_integrations[i][0] > 0) {
								user_id.cultural_integrations[i][0]--;
							}
							
							if (user_id.cultural_integrations[i][0] == 0) {
								user_id.accepted_cultures.push(user_id.cultural_integrations[i][1]);
								remove_elements.push(user_id.cultural_integrations[i]);
							}
						}
						//Remove elements from cultural_integrations array
						for (var i = 0; i < remove_elements.length; i++) {
							for (var x = 0; x < user_id.cultural_integrations.length; x++) {
								if (user_id.cultural_integrations[x] == remove_elements[i]) {
									user_id.cultural_integrations.splice(x, 1);
								}
							}
						}
						remove_elements = [];
					}
				}
			}
			
			//Resources and RGO
			{
				for (var i = 0; i < config.materials.length; i++) {
					user_id.modifiers[config.materials[i]] = 1;
				}
				for (var i = 0; i < cities.city_array.length; i++) {
					user_id.modifiers[cities[cities.city_array[i]].resource] = user_id.modifiers[cities[cities.city_array[i]].resource] + user_id.modifiers.rgo_throughput;
				}
			}
			
			//Technology
			{
				var research_removal_array = [];
				if (user_id.researching.length > 0) {
					for (var i = 0; i < user_id.researching.length; i++) {
						if (user_id.researching[i][0]+(user_id.inventory.knowledge/user_id.researching.length) >= config.technology[user_id.researching[i][1]].research_cost) {
							national_news = national_news + "\nThe nation of " + user_id.name + " finished researching **" + user_id.researching[i][1] + "**!";
							//Technology effect
							config.technology[user_id.researching[i][1]].unlocks(user_id);
							user_id.researched_technologies.push(user_id.researching[i][1]);
							user_id.techs_researched++;
							user_id[config.technology[user_id.researching[i][1]].category + "_researched"]++;
							research_removal_array.push(user_id.researching[i]);
						} else {
							user_id.researching[i][0] = user_id.researching[i][0] + Math.round(user_id.inventory.knowledge/user_id.researching.length);
						}
					}
					
					user_id.inventory.knowledge = 0;
				}
				
				for (var i = 0; i < research_removal_array.length; i++) {
					if (user_id.researching.length > 0) {
						for (var x = 0; x < user_id.researching.length; x++) {
							if (user_id.researching[x] == research_removal_array[i]) {
								user_id.researching.splice(x, 1);
							}
						}
					}
				}
				
				//Run through queue array until a valid technology is discovered, then append and remove from queue array. Iterate through for as many times as needed. WIP
				var research_queue_removal_array = [];
				for (var i = 0; i < user_id.research_queue.length; i++) {
					var technology_exists = false;
					
					for (var x = 0; x < config.valid_technologies.length; x++) {
						if (config.valid_technologies[x] == user_id.research_queue[i]) {
							technology_exists = true;
						}
					}
					
					if (technology_exists) {
						var tech_array_dump = [];
						var tech_category_techs_available = [];
						
						for (var x = 0; x < config.valid_technologies.length; x++) {
							var tech_available = false;
							
							if (config.technology[config.valid_technologies[x]].prerequisite_techs != undefined) {
								var prerequisite_checks = 0;
								for (var y = 0; y < config.technology[config.valid_technologies[x]].prerequisite_techs.length; y++) {
									for (var z = 0; z < user_id.researched_technologies.length; z++) {
										if (config.technology[config.valid_technologies[x]].prerequisite_techs[y] == user_id.researched_technologies[z]) {
											prerequisite_checks++;
										}
									}
								}
								
								if (prerequisite_checks == config.technology[config.valid_technologies[x]].prerequisite_techs.length) {
									tech_available = true;
								}
							} else { //No prerequisite checks found, so must be a starting tech
								tech_available = true;
							}
							
							//Check if user has already researched tech
							for (var y = 0; y < user_id.researched_technologies.length; y++) {
								if (user_id.researched_technologies[y] == config.valid_technologies[x]) {
									tech_available = false;
								}
							}
							
							//Append to valid tech dump for later categorisation
							if (tech_available) {
								tech_array_dump.push(config.valid_technologies[x]);
							}
						}
						
						//Execute research function
						
						var can_research = false;
						for (var x = 0; x < tech_array_dump.length; x++) {
							if (tech_array_dump[x] == user_id.research_queue[i]) {
								can_research = true;
							}
						}
						
						if (can_research) {
							research_queue_removal_array.push(user_id.research_queue[i]);
							research(user_id.id, user_id.research_queue[i], "none");
						}
					}
				}
				
				for (var i = 0; i < research_queue_removal_array.length; i++) {
					for (var x = 0; x < user_id.research_queue.length; x++) {
						if (user_id.research_queue[x] == research_queue_removal_array[i]) {
							user_id.research_queue.splice(x, 1);
						}
					}
				}
				
				user_id.inventory.knowledge = 0;
			}
			
			//Trade
			{
				//[[3, "iron"], "213287117017710593", 3]
				if (user_id.auto_trades.length > 0) {
					//[other_user_id, amount, item_type]
					for (var i = 0; i < user_id.auto_trades.length; i++) {
						if (main.users[user_id.auto_trades[i][0]].blockaded == false) {
							give(user_id.id, user_id.auto_trades[i][0], user_id.auto_trades[i][1], user_id.auto_trades[i][2], "item", "none");
						}
					}
				}
				
				if (user_id.trade_array.length > 0) {
					for (var i = 0; i < user_id.trade_array.length; i++) {
						//Decrease shipment timer by 1
						if (user_id.trade_array[i][2] > 0) {
							user_id.trade_array[i][2]--;
						}
						//Check if shipment is ready
						if (user_id.trade_array[i][2] == 0) {
							if (main.users[user_id.trade_array[i][1]] != undefined) {
								if (main.users[user_id.trade_array[i][1]].blockaded == false) {
									if (user_id.trade_array[i][0][1] != "money") {
										main.users[user_id.trade_array[i][1]]["inventory"][user_id.trade_array[i][0][1]] = main.users[user_id.trade_array[i][1]]["inventory"][user_id.trade_array[i][0][1]] + user_id.trade_array[i][0][0];
									} else {
										main.users[user_id.trade_array[i][1]].money = main.users[user_id.trade_array[i][1]].money + user_id.trade_array[i][0][0];
									}
								}
							}
							user_id.trade_array.splice(i, 1);
						}
					}
				}
			}
			
			news.push(national_news);
			user_id.pops.pop_array = Object.keys(user_id.pops);
			user_id.pops.pop_array.pop();
		}
	}
	
	//Command functions
	{
		//[["fleet_in_being", "+20% Early Sail DP"], ["fleet_in_being","-5% Army Travel Time"], ["fleet_in_being", "-5% Colonist Travel Time"], ...]
		modifier_label_arrays = [];
		
		function deleteElement (arg0_array, arg1_element, arg2_mode) {
			for (var i = 0; i < arg0_array.length; i++) {
				if (arg0_array[i] == arg1_element) {
					arg0_array.splice(i, 1);
				}
			}
			if (arg2_mode != undefined) {
				var usr = arg2_mode[0];
				if (arg2_mode[1] == "obsolete_units") {
					if (usr.obsolete_units == undefined) {
						usr.obsolete_units = [arg1_element];
					} else {
						var already_in_array = false;
						for (var i = 0; i < usr.obsolete_units.length; i++) {
							if (usr.obsolete_units[i] == arg1_element) {
								already_in_array = true;
							}
						}
						if (already_in_array == false) {
							usr.obsolete_units.push(arg1_element);
						}
					}
				}
			}
		}
		
		function randomElement (arg0_array) {
			return arg0_array[Math.floor(Math.random() * arg0_array.length)];
		}
		
		//Basic command functions
		{
			function settle (arg0_user, arg1_msg, arg2_provs) { //arg2_provs is an array type
				var usr = main.users[arg0_user];
				
				if (usr.expeditions.length < usr.modifiers.maximum_expeditions) {
					var provs = arg2_provs;
					var prov_checks = 0;
					var has_unit = false;
					var unit_type = "";
					
					for (var i = 0; i < config.units.length; i++) {
						if (config.unit_stats[config.units[i]].colonise_provinces != undefined) {
							if (arg2_provs.length == config.unit_stats[config.units[i]].colonise_provinces) {
								unit_type = config.units[i];
							}
						}
					}
					if (unit_type != "") {
						if (usr.military[unit_type] > 0) {
							has_unit = true;
							usr.used_soldiers = usr.used_soldiers - config.unit_stats[unit_type].manpower_cost;
						}
					} else {
						has_unit = false;
					}
					
					if (usr.used_soldiers < 0) {
						usr.used_soldiers = 0;
					}
					
					if (has_unit) {
						var taken_provinces = [];
						var specified_number = true;
						
						for (var i = 0; i < arg2_provs.length; i++) {
							var province_taken = false;
							
							for (var x = 0; x < main.province_array.length; x++) {
								if (main.province_array[x] == arg2_provs[i]) {
									province_taken = true;
								}
							}
							
							if (province_taken == true) {
								prov_checks--;
								taken_provinces.push(arg2_provs[i]);
							} else if (arg2_provs[i].match(/[a-zA-Z]/) || parseInt(arg2_provs[i]) > 1711 || parseInt(arg2_provs[i]) < 0) {
								prov_checks--;
								specified_number = false;
							} else {
								prov_checks++;
							}
						}
						
						if (prov_checks == arg2_provs.length) {
							if (usr.provinces == 0) { //Ensure that the first settler has zero travel time.
								for (var i = 0; i < arg2_provs.length; i++) {
									main.province_array.push(arg2_provs[i]);
									usr.cities.province_array.push(arg2_provs[i]);
									usr.provinces++;
									usr.military[unit_type]--;
								}
								
								usr.capital_id = parseInt(arg2_provs[0]); //Set capital ID
								arg1_msg.channel.send("Settlers from **" + usr.name + "** settled the province of **" + arg2_provs.join(", ") + "**!");
								displaySVG(returnChannel(map_channel));
							} else {
								usr.military[unit_type]--;
								
								//Get distance and colonisation time
								var average_prov_id = 0;
								var prov_distance = 0;
								var prov_colonisation_turns = 0;
								for (var i = 0; i < arg2_provs.length; i++) {
									average_prov_id = average_prov_id + parseInt(arg2_provs[i]);
								}
								
								average_prov_id = Math.ceil(average_prov_id/arg2_provs.length);
								
								prov_distance = Math.abs(usr.capital_id - average_prov_id);
								prov_colonisation_turns = Math.ceil(prov_distance/(config.colonisation_speed*usr.modifiers.colonist_travel_speed));
					
								//["conquistadors", turn_amount, [province_ids]]
								
								usr.expeditions.push([unit_type, prov_colonisation_turns+2, arg2_provs]);
								
								arg1_msg.channel.send("Settlers from **" + usr.name + "** have set out to colonise the province(s) of " + arg2_provs.join(", ") + ". They will arrive in **" + prov_colonisation_turns + "** turns. They will then take an additional **2** turns to colonise.");
							}
						} else {
							var suffix = "";
							if (taken_provinces.length > 0) {
								suffix = suffix + "Province(s) **" + taken_provinces.join(", ") + "** were already settled. ";
							}
							if (specified_number == false) {
								suffix = suffix + "One of the provinces you specified was not numeric! Specify Province IDs, not names.";
							}
							arg1_msg.channel.send("One of the provinces you have specified turned out to be invalid! " + suffix);
						}
					} else {
						arg1_msg.channel.send("You must specify a valid amount of arguments according to the unit you wish to use.");
					}
				} else {
					arg1_msg.channel.send("You have reached your maximum limit of **" + usr.modifiers.maximum_expeditions + "** ongoing expeditions!");
				}
			}
			
			function demolish (arg0_user, arg1_msg, arg2_building, arg3_amount, arg4_city) {
				var usr = main.users[arg0_user];
				
				var building_exists = false;
				var building_id = 0;
				var city_exists = [false, 0];
				
				for (var i = 0; i < config.buildings.length; i++) {
					if (config.buildings[i] == arg2_building) {
						building_exists = true;
						building_id = i;
					}
				}
				
				//Soft match
				for (var i = 0; i < usr.cities.city_array.length; i++) {
					if (usr.cities[usr.cities.city_array[i]].name.toLowerCase().indexOf(arg4_city.toLowerCase()) != -1) {
						city_exists = [true, usr.cities.city_array[i]];
					}
				}
				
				//Hard match
				for (var i = 0; i < usr.cities.city_array.length; i++) {
					if (usr.cities[usr.cities.city_array[i]].name.toLowerCase() == arg4_city.toLowerCase()) {
						city_exists = [true, usr.cities.city_array[i]];
					}
				}
				
				console.log("[Triumph & Tragedy]: Fetched city_exists as the following value: " + city_exists[1]);
				
				var is_being_justified_on = false;
				
				for (var i = 0; i < main.user_array.length; i++) {
					if (main.users[main.user_array[i]].justifications.length > 0) {
						for (var x = 0; x < main.users[main.user_array[i]].justifications.length; x++) {
							if (main.users[main.user_array[i]].justifications[1] == arg0_user) {
								is_being_justified_on = true;
							}
						}
					}
				}
				
				if (is_being_justified_on == false) {
					if (building_exists) {
						//Get manpower cost
						var building_manpower_cost = 0;
						
						for (var i = 0; i < config.building_stats[config.buildings[i]].costs.length; i++) {
							if (config.building_stats[config.buildings[i]].costs[i][1] == "manpower") {
								building_manpower_cost = config.building_stats[config.buildings[i]].costs[i][0];
							} 
						}
						
						if (city_exists) {
							if (usr["cities"][city_exists[1]]["buildings"][arg2_building] >= arg3_amount) {
								var pop_type = "";
								for (var i = 0; i < config.building_stats[arg2_building].costs.length; i++) {
									var is_pop = false;
									var local_comparison = config.building_stats[arg2_building]["costs"][i][1];
									for (var x = 0; x < config.pop_array.length; x++) {
										if (config.pop_array[x] == local_comparison) {
											is_pop = true;
										}
									}
									if (is_pop) {
										pop_type = local_comparison;
									}
								}
								
								if (pop_type != "") {
									usr["used_" + pop_type] = usr["used_" + pop_type] - building_manpower_cost*arg3_amount;
								}
								usr["cities"][city_exists[1]]["buildings"][arg2_building] = usr["cities"][city_exists[1]]["buildings"][arg2_building] - arg3_amount;
								usr["cities"][city_exists[1]].building_count = usr["cities"][city_exists[1]].building_count - arg3_amount;
								
								if (arg2_building == "aerodromes") {
									usr["buildings"].aerodromes--;
								} else if (arg2_building == "aeroports") {
									usr["buildings"].aeroports--;
								} else if (arg2_building == "artillery_factories") {
									usr["buildings"].artillery_factories--;
								} else if (arg2_building == "auto_plants") {
									usr["buildings"].auto_plants--;
								} else if (arg2_building == "barracks") {
									usr["buildings"].barracks--;
								} else if (arg2_building == "dockyards") {
									usr["buildings"].dockyards--;
								}
								
								arg1_msg.channel.send(arg3_amount + " " + arg2_building + " were demolished. You were refunded " + building_manpower_cost*arg3_amount + " manpower, and " + arg3_amount + " building slots were freed up.");
							} else {
								arg1_msg.channel.send("You don't have that many **" + arg2_building + "**!");
							}
						} else {
							arg1_msg.channel.send("The city you have specified proved as elusive as El Dorado!");
						}
					} else {
						arg1_msg.channel.send("The type of building that you have specified does not exist!");
					}
				} else {
					arg1_msg.channel.send("You can't demolish buildings whilst being justified on!");
				}
			}
			
			function mine (arg0_user, arg1_msg, arg2_actions) {
				var user_id = main.users[arg0_user];
				var inventory = main.users[arg0_user]["inventory"];
				
				var resource_list = "";
				var out_of_actions = false;
				
				var resources_dug_array = [];
				var resources_dug = {
				};
				
				var output_array = [];
				var output_string = "";
				
				if (arg2_actions < 1001) {
					for (var i = 0; i < arg2_actions; i++) {
						if (user_id.actions > 0) {
							var random_resource = randomElement(config.mineable_materials);
							user_id.actions--;
							inventory[random_resource] = inventory[random_resource] + 1;
							
							var resource_already_exists = false;
							for (var x = 0; x < resources_dug_array.length; x++) {
								if (resources_dug_array[x] == random_resource) {
									resource_already_exists = true;
								}
							}
							
							if (resource_already_exists == false) {
								resources_dug_array.push(random_resource);
								resources_dug[random_resource] = 1;
							} else {
								resources_dug[random_resource]++;
							}
						} else {
							out_of_actions = true;
						}
					}
					console.log("[Triumph & Tragedy]: Resources were dug up as: " + resources_dug_array);
				} else {
					if (arg1_msg != "none") {
						arg1_msg.channel.send("The number you have specified is too large!");
					}
				}
				
				if (resources_dug_array.length != 0) {
					//Generate output array:
						
					var material_icon = [];
					
					for (var i = 0; i < resources_dug_array.length; i++) {
						for (var x = 0; x < config.resource_icons.length; x++) {
							if (config.materials[x] == resources_dug_array[i]) {
								material_icon.push(config.resource_icons[x]);
							}
						}
						
						if (i == resources_dug_array.length-1) {
							var resource_dug_up = resources_dug_array[i];
							
							if (resources_dug_array.length > 1) {
								output_array.push(" and " + resources_dug[resources_dug_array[i]] + " " + material_icon[i] + " " + resources_dug_array[i]);
							} else {
								output_array.push(" " + resources_dug[resources_dug_array[i]] + " " + material_icon[i] + " " + resources_dug_array[i]);
							}
						} else {
							output_array.push(" " + resources_dug[resources_dug_array[i]] + " " + material_icon[i] + " " + resources_dug_array[i]);
						}
					}
					output_string = "You dug up" + output_array.join(",") + ".";
				} else {
					output_string = "Your miners were too exhausted to continue mining!";
				}
				
				if (arg1_msg != "none") {
					arg1_msg.channel.send(output_string);
					if (out_of_actions) {
						if (output_string != "Your miners were too exhausted to continue mining!") {
							arg1_msg.channel.send("You then proceeded to run out of actions.");
						}
					}
				}
			}
			
			function forage (arg0_user, arg1_msg, arg2_actions) {
				var user_id = main.users[arg0_user];
				var inventory = main.users[arg0_user]["inventory"];
				
				var salvaged_wood = 0;
				var out_of_actions = false;
				
				if (arg2_actions < 1001) {
					for (var i = 0; i < arg2_actions; i++) {
						if (user_id.actions > 0) {
							user_id.actions--;
							inventory["wood"] = inventory["wood"] + 1;
							salvaged_wood++;
						} else {
							out_of_actions = true;
						}
					}
				} else {
					if (arg1_msg != "none") {
						arg1_msg.channel.send("The number you have specified is too large!");
					}
				}
				
				if (arg1_msg != "none") {
					if (salvaged_wood != 0) {
						arg1_msg.channel.send("You chopped " + salvaged_wood + " <:wood:716791408928751636> wood.");
						if (out_of_actions) {
							arg1_msg.channel.send("You then proceeded to run out of actions.");
						}
					} else {
						arg1_msg.channel.send("Your loggers were too exhausted to continue logging!");
					}
				}
			}
			
			function refine (arg0_user, arg1_msg, arg2_actions) {
				var user_id = main.users[arg0_user];
				var inventory = main.users[arg0_user]["inventory"];
				
				var refined_steel = 0;
				var out_of_actions = false;
				
				if (arg2_actions < 1001) {
					for (var i = 0; i < arg2_actions; i++) {
						if (user_id.refining_actions > 0) {
							if (inventory.iron > 0 && inventory.coal > 0) {
								user_id.refining_actions--;
								inventory["steel"]++;
								inventory["iron"]--;
								inventory["coal"]--;
								refined_steel++;
							}
						} else {
							out_of_actions = true;
						}
					}
				} else {
					arg1_msg.channel.send("The number you have specified is too large!");
				}
				
				if (arg1_msg != "none") {
					arg1_msg.channel.send("You refined " + refined_steel + " <:steel:716791408828088420> steel out of " + refined_steel + " <:coal:716791408714973204> coal and " + refined_steel + " <:iron:716791408819961866> iron.");
					if (out_of_actions) {
						arg1_msg.channel.send("Your steelworkers then proceeded to collapse from exhaustion. They'll be back at their shift tomorrow.");
					}
				}
			}
			
			function buy (arg0_user, arg1_msg, arg2_amount, arg3_type) {
				if (main.users[arg0_user] != undefined) {
					var user_id = main.users[arg0_user];
					var inventory = main.users[arg0_user]["inventory"];
					
					var resource_exists = false;
					
					//Market processing
					for (var i = 0; i < config.resource_list.length; i++) {
						if (arg3_type == config.resource_list[i][0]) {
							resource_exists = true;
							if (user_id.blockaded == true) {
								arg1_msg.channel.send("You can't buy items whilst blockaded!");
							} else {
								if (isNaN(parseInt(arg2_amount)) == false) {
								var market = main.users.global;
								if (user_id.money <= arg2_amount*market[arg3_type + "_buy_price"]) {
									arg1_msg.channel.send("You don't have enough money to buy that much " + config.resource_list[i][0] + "!");
								} else {
									if (arg2_amount < market[arg3_type + "_stock"]) {
										var valid_purchase = true;
										
										if (market[arg3_type + "_stock"] >= 50) {
											if (arg2_amount > market[arg3_type + "_stock"]*0.2) {
												valid_purchase = false;
											}
										}
										
										if (valid_purchase) {
											arg1_msg.channel.send("You bought " + arg2_amount + " " + arg3_type + " for **" + parseNumber(arg2_amount*market[arg3_type + "_buy_price"]) + "**.");
											user_id.money = user_id.money - arg2_amount*market[arg3_type + "_buy_price"];
											inventory[arg3_type] = inventory[arg3_type] + arg2_amount;
											var previous_stock = market[arg3_type + "_stock"];
											market[arg3_type + "_stock"] = market[arg3_type + "_stock"] - arg2_amount;
											//Increase buy price
											market[arg3_type + "_buy_price"] = market[arg3_type + "_buy_price"]*(previous_stock/market[arg3_type + "_stock"]);
											market[arg3_type + "_sell_price"] = market[arg3_type + "_sell_price"]*(previous_stock/market[arg3_type + "_stock"]);
										} else {
											arg1_msg.channel.send("You can only buy up to **20%** of the goods in a large market at once!");
										}
									} else {
										arg1_msg.channel.send("There isn't enough stock remaining in the global market to purchase this much **" + arg3_type + "**!");
									}
								}
								} else {
									arg1_msg.channel.send("You must specify a valid number in order to sell items!");
								}
							}
						}
					}
					
					if (resource_exists == false && arg3_type != "list") {
						arg1_msg.channel.send("That resource isn't for sale!");
					}
				}
			}
			
			function sell (arg0_user, arg1_msg, arg2_amount, arg3_type) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var inventory = usr.inventory;
					
					var resource_exists = false;
					
					//Market processing
					for (var i = 0; i < config.resource_list.length; i++) {
						if (arg3_type == config.resource_list[i][0]) {
							resource_exists = true;
							if (usr.blockaded) {
								arg1_msg.channel.send("You can't sell items whilst blockaded!");
							} else {
								if (isNaN(parseInt(arg2_amount)) == false) {
									var market = main.users.global;
									if (arg2_amount > inventory[arg3_type]) {
										arg1_msg.channel.send("You don't have enough **" + arg3_type + "** to do that! You're " + parseNumber(arg2_amount-inventory[arg3_type]) + " " + arg3_type + " short.");
									} else {
										arg1_msg.channel.send("You sold " + arg2_amount + " " + arg3_type + " for **" + parseNumber(arg2_amount*market[arg3_type + "_sell_price"]) + "**.");
										usr.money = usr.money + arg2_amount*market[arg3_type + "_sell_price"];
										inventory[arg3_type] = inventory[arg3_type] - arg2_amount;
										var previous_stock = market[arg3_type + "_stock"];
										market[arg3_type + "_stock"] = market[arg3_type + "_stock"] + arg2_amount;
										//Decrease buy/sell price
										market[arg3_type + "_buy_price"] = market[arg3_type + "_buy_price"]*(previous_stock/market[arg3_type + "_stock"]);
										market[arg3_type + "_sell_price"] = market[arg3_type + "_sell_price"]*(previous_stock/market[arg3_type + "_stock"]);
									}
								} else {
									msg.channel.send("You must specify a valid number in order to sell items!");
								}
							}
						}
					}
					
					if (resource_exists == false) {
						msg.channel.send("The resource you have specified doesn't even exist! Make sure you've spelled it correctly and used the command in the correct way.");
					}
				} else {
					msg.channel.send("You must found a nation in order to sell goods to the **World Market**!");
				}
			}
			
			function sellGold (arg0_user, arg1_msg, arg2_actions) {
				if (main.users[arg0_user] != undefined) {
					var user_id = main.users[arg0_user];
					var inventory = main.users[arg0_user]["inventory"];
					var auction_list = "";
					var out_of_gold = false;
					
					if (arg2_actions < 1001) {
						for (var i = 0; i < arg2_actions; i++) {
							if (inventory.gold > 0) {
								var sold_for = randomNumber(800, 1350);
								inventory.gold--;
								user_id.money = user_id.money + sold_for;
								auction_list = auction_list + "" + sold_for.toString() + ", ";
							} else {
								out_of_gold = true;
							}
						}
					} else {
						arg1_message.channel.send("The number you have specified is too large!");
					}
					
					if (auction_list == "") {
						arg1_msg.channel.send("You don't even have gold!");
					} else {
						arg1_msg.channel.send("You sold " + arg2_actions + " gold for " + auction_list + " on the auction block.");
						if (out_of_gold) {
							arg1_msg.channel.send("You then proceeded to run out of gold.");
						}
					}
				} else {
					arg1_msg.channel.send("You don't even have a country!");
				}
			}
			
			function sellPetrol (arg0_user, arg1_msg, arg2_actions) {
				if (main.users[arg0_user] != undefined) {
					var user_id = main.users[arg0_user];
					var inventory = main.users[arg0_user]["inventory"];
					var auction_list = "";
					var out_of_petrol = false;
					
					if (arg2_actions < 1001) {
						for (var i = 0; i < arg2_actions; i++) {
							if (inventory.petroil > 0) {
								var sold_for = randomNumber(750, 1000);
								inventory.petroil--;
								user_id.money = user_id.money + sold_for;
								auction_list = auction_list + "" + sold_for.toString() + ", ";
							} else {
								out_of_petrol = true;
							}
						}
					} else {
						arg1_message.channel.send("The number you have specified is too large!");
					}
					
					if (auction_list == "") {
						arg1_msg.channel.send("You don't even have petrol!");
					} else {
						arg1_msg.channel.send("You sold " + arg2_actions + " petrol for " + auction_list + " on the auction block.");
						if (out_of_petrol) {
							arg1_msg.channel.send("You then proceeded to run out of petrol.");
						}
					}
				} else {
					arg1_msg.channel.send("You don't even have a country!");
				}
			}
			
			function setGovernment (arg0_user, arg1_type) {
				var user_id = arg0_user;
				console.log("[Triumph & Tragedy]: User ID Object: " + user_id);
				user_id.government = arg1_type;
				user_id.politics.anarchy = 0;
				
				var local_config = config.governments[arg1_type];
				if (local_config.maximum_manpower != undefined) {
					user_id.manpower_percentage = local_config.maximum_manpower;
				}
				if (local_config.maximum_tax_rate != undefined) {
					user_id.max_tax = local_config.maximum_tax_rate;
				}
				if (local_config.civilian_actions != undefined) {
					user_id.civilian_actions_percentage = local_config.civilian_actions;
				}
			}
		}
		
		//Cheat functions and API (Cheats)
		{
			function addPops (arg0_user, arg1_amount, arg2_type) {
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					var random_province = randomElement(usr.pops.pop_array);
					if (config.pops[arg2_type] != undefined) {
						usr.pops[random_province][arg2_type] = usr.pops[random_province][arg2_type] + parseInt(arg1_amount);
						usr[arg2_type] = usr[arg2_type] + parseInt(arg1_amount);
						usr.population = usr.population + parseInt(arg1_amount);
					}
				}
			}
		
			function armyDeserts (arg0_user, arg1_percentage) {
				var user_id = main.users[arg0_user];
				
				user_id.used_soldiers = user_id.used_soldiers - Math.ceil(user_id.used_soldiers*arg1_percentage);
				
				for (var i = 0; i < config.units.length; i++) {
					user_id["military"][config.units[i]] = Math.ceil(user_id["military"][config.units[i]]*(1-arg1_percentage));
				}
				
				if (user_id.armies.army_array.length > 0) {
					for (var x = 0; x < user_id.armies.army_array.length; x++) {
						for (var i = 0; i < config.units.length; i++) {
							user_id["armies"][user_id.armies.army_array[x]][config.units[i]] = Math.ceil(user_id.armies[user_id.armies.army_array[x]][config.units[i]]*(1-arg1_percentage));
						}
					}
				}
			}
			
			function removePops (arg0_user, arg1_amount, arg2_type) {
				var usr = main.users[arg0_user];
				
				//Shuffle pops
				var shuffled_provinces = usr.pops.pop_array;
				var current_index = usr.pops.pop_array.length, temporary_value, random_index;
				while (0 != current_index) {
					random_index = Math.floor(Math.random()*current_index);
					current_index -= 1;
					temporary_value = shuffled_provinces[current_index];
					shuffled_provinces[current_index] = shuffled_provinces[random_index];
					shuffled_provinces[random_index] = temporary_value;
				}
				
				var remaining_population = arg1_amount;
				//Begin subtracting
				for (var i = 0; i < shuffled_provinces.length; i++) {
					if (remaining_population > 0) {
						if (usr.pops[shuffled_provinces[i]][arg2_type] >= remaining_population) {
							usr.pops[shuffled_provinces[i]][arg2_type] = usr.pops[shuffled_provinces[i]][arg2_type] - remaining_population;
							remaining_population = 0;
						} else if (usr.pops[shuffled_provinces[i]][arg2_type] < remaining_population) {
							remaining_population = remaining_population - usr.pops[shuffled_provinces[i]][arg2_type];
							usr.pops[shuffled_provinces[i]][arg2_type] = 0;
						}
					}
				}
			}
			
			function researchAllTechs (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var all_technologies = Object.keys(config.technology);
					
					for (var i = 0; i < all_technologies.length; i++) {
						var tech_already_researched = false;
						
						for (var x = 0; x < usr.researched_technologies.length; x++) {
							if (usr.researched_technologies[x] == all_technologies[i]) {
								tech_already_researched = true;
							}
						}
						
						if (tech_already_researched == false) {
							usr.researched_technologies.push(all_technologies[i]);
							usr[config.technology[all_technologies[i]].category + "_researched"]++;
							usr.techs_researched++;
							if (config.technology[all_technologies[i]].unlocks != undefined) {
								config.technology[all_technologies[i]].unlocks(usr);
							}
						}
					}
					
					msg.channel.send("**You have successfully researched all valid technologies!**");
				} else {
					msg.channel.send("Remember to register a country first before using cheat/debug commands!");
				}
			}
			
			function unlockAllReforms (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var all_reform_categories = Object.keys(config.reforms);
					
					usr.available_reforms = all_reform_categories;
					msg.channel.send("**You have successfully unlocked all reforms.**");
				} else {
					msg.channel.send("You must have a country first in order to unlock all reforms!");
				}
			}
			
			function unlockReform (arg0_user, arg1_reform) {
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var reform_exists = false;
					var reform_already_unlocked = false;
					var all_reform_categories = Object.keys(config.reforms);
					
					//Check if reform exists or is already added
					for (var i = 0; i < all_reform_categories.length; i++) {
						if (all_reform_categories[i] == arg1_reform) {
							reform_exists = true;
						}
					}
					for (var i = 0; i < usr.available_reforms.length; i++) {
						if (usr.available_reforms[i] == arg1_reform) {
							reform_already_unlocked = true;
						}
					}
					
					if (reform_exists == true && reform_already_unlocked == false) {
						var all_reforms_in_category = Object.keys(config.reforms[arg1_reform]);
						for (var i = 0; i < all_reforms_in_category.length; i++) {
							if (all_reforms_in_category[i] == "name") {
								all_reforms_in_category.splice(i, 1);
							}
						}
						
						var reform_obj = config.reforms[arg1_reform][all_reforms_in_category[0]];
						usr.available_reforms.push(arg1_reform);
						
						if (reform_obj.political_appeasement != undefined) {
							for (var i = 0; i < config.government_list.length; i++) {
								if (reform_obj.political_appeasement[config.government_list[i] + "_discontent"] != undefined) {
									usr.modifiers[config.government_list[i] + "_discontent"] = usr.modifiers[config.government_list[i] + "_discontent"] + reform_obj.political_appeasement[config.government_list[i] + "_discontent"]*-1;
								}
							}
						}
						if (reform_obj.effects != undefined) {
							for (var i = 0; i < reform_obj.effects.length; i++) {
								if (reform_obj.effects[i][0] == "stability" || reform_obj.effects[i][0] == "max_tax" || reform_obj.effects[i][0] == "manpower_percentage" || reform_obj.effects[i][0] == "pop_growth_modifier") {
									usr[reform_obj.effects[i][0]] = usr[reform_obj.effects[i][0]] + reform_obj.effects[i][1];
								} else {
									usr.modifiers[reform_obj.effects[i][0]] = usr.modifiers[reform_obj.effects[i][0]] + reform_obj.effects[i][1];
								}
							}
						}
					}
				}
			}
		}
		
		//Army & Combat functions
		{
			//War interface
			{
				function printWar (arg0_user, arg1_war, arg2_msg) {
					var msg = arg2_msg;
					var print_war_array = [];
					var is_involved = false;
					
					var war_exists = [false, ""];
					var all_wars = Object.keys(main.users.global.wars);
					
					for (var i = 0; i < all_wars.length; i++) { //soft match first
						if (main.users.global.wars[all_wars[i]].name.toLowerCase().indexOf(arg1_war.toLowerCase()) != -1) {
							war_exists = [true, all_wars[i]];
						}
					}
					for (var i = 0; i < all_wars.length; i++) { //hard match second
						if (main.users.global.wars[all_wars[i]].name.toLowerCase() == arg1_war.toLowerCase()) {
							war_exists = [true, all_wars[i]];
						}
					}
					
					if (war_exists[0]) {
						var war_obj = main.users.global.wars[war_exists[1]];
						print_war_array.push("__**" + war_obj.name + ":**__");
						
						print_war_array.push("Defender Warscore: **" + war_obj.defender_warscore + "**%  Attacker Warscore: **" + war_obj.attacker_warscore + "%**");
						print_war_array.push("------------------");
						print_war_array.push("`Participant Name  User  Casualties`");
						print_war_array.push("**Attackers:**\n");
						print_war_array.push("Total Casualties: **" + parseNumber(war_obj.attacker_total_casualties) + "**");
						
						//See if user is involved in the war
						for (var i = 0; i < war_obj.attackers.length; i++) {
							print_war_array.push("**" + main.users[war_obj.attackers[i]].name + "**  <@" + war_obj.attackers[i] + ">  " + parseNumber(war_object[war_obj.attackers[i] + "_casualties"]));
							if (war_obj.attackers[i] == arg0_user) {
								is_involved = true;
							}
						}
						print_war_array.push("**Defenders:**\n");
						print_war_array.push("Total Casualties: **" + parseNumber(war_obj.defender_total_casualties) + "**");
						for (var i = 0; i < war_obj.defenders.length; i++) {
							print_war_array.push("**" + main.users[war_obj.defenders[i]].name + "**  <@" + war_obj.defenders[i] + ">  " + parseNumber(war_object[war_obj.defenders[i] + "_casualties"]));
							if (war_obj.defenders[i] == arg0_user) {
								is_involved = true;
							}
						}
						if (is_involved) {
							print_war_array.push("------------------");
							print_war_array.push("**Settle for Peace:**");
							var has_peace_treaty_active = false;
							var all_peace_offers = Object.keys(war_obj.peace_offers);
							
							if (all_peace_offers.length > 0) {
								for (var i = 0; i < all_peace_offers.length; i++) {
									if (war_obj.peace_offers[all_peace_offers[i]].country == arg0_user) {
										has_peace_treaty_active = true;
									}
								}
							}
							
							if (has_peace_treaty_active) {
								print_war_array.push("`" + bot_prefix + 'view-peace-treaty "' + war_obj.name + '"`');
							} else {
								print_war_array.push("`" + bot_prefix + 'sign-peace-treaty "' + war_obj.name + '"`');
							}
						}
					
						const embed_war_stats = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**War Overview:\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(print_war_array.join("\n"))
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'view-war "' + war_obj.name + '".', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
							
						msg.channel.send(embed_war_stats);
					} else {
						msg.channel.send("The war you have specified does not even exist! Type `" + bot_prefix + "war-list` for a complete list of active conflicts.");
					}
				}
				
				function printWars (arg0_msg) {
					var msg = arg0_msg;
					var wars_list_array = [];
					
					var all_wars = Object.keys(main.users.global.wars);
					if (all_wars.length > 0) {
						wars_list_array.push("`War Name  Number of Nations Involved  Defender Warscore - Attacker Warscore  Total Casualties`");
						if (all_wars.length > 0) {
							for (var i = 0; i < all_wars.length; i++) {
								var war_obj = main.users.global.wars[all_wars[i]];
								var number_of_nations = war_obj.attackers.length + war_obj.defenders.length;
								var total_casualties = war_obj.attacker_total_casualties + war_obj.defender_total_casualties;
								wars_list_array.push("**" + war_obj.name + "**  " + parseNumber(number_of_nations) + "  **" + parseNumber(war_obj.defender_warscore) + "%** - **" + parseNumber(war_obj.attacker_warscore) + "%**  " + parseNumber(total_casualties));
							}
						}
					} else {
						wars_list_array.push("_There are currently no ongoing conflicts._");
					}
					
					const embed_war_list = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**War List:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(wars_list_array.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'war-list.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					msg.channel.send(embed_war_list);
				}
			}
			
			//Army order functions
			{
				function mergeArmy (arg0_user, arg1_msg, arg2_name, arg3_name) {
					var msg = arg1_msg;
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						//Check if armies exist
						var army1_exists = [false, ""];
						var army2_exists = [false, ""];
						var fatal_error = [false, ""];
						//arg2_name - Army 1
						//arg3_name - Army 2
						
						//Check if either armies exist
						for (var i = 0; i < usr.armies.army_array.length; i++) {
							if (usr.armies[usr.armies.army_array[i]].name == arg2_name) {
								army1_exists = [true, usr.armies.army_array[i]];
							}
							if (usr.armies[usr.armies.army_array[i]].name == arg3_name) {
								army2_exists = [true, usr.armies.army_array[i]];
							}
						}
						
						var aeroplane_capacity = 0;
						var aeroplane_count = 0;
						var total_units = 0;
						if (army1_exists[0] && army2_exists[0]) {
							//Army computations: potential errors if user is trying to merge (navy, air);
							//Get aeroplane capacity of first army
							for (var i = 0; i < config.units.length; i++) {
								total_units = total_units + usr.armies[army1_exists[1]][config.units[i]];
								total_units = total_units + usr.armies[army2_exists[1]][config.units[i]];
								if (config.unit_stats[config.units[i]].carrier_capacity != undefined) {
									aeroplane_capacity = aeroplane_capacity + usr.armies[army1_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].carrier_capacity;
									aeroplane_capacity = aeroplane_capacity + usr.armies[army2_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].carrier_capacity;
								}
							}
							for (var i = 0; i < config.aeroplanes.length; i++) {
								aeroplane_count = aeroplane_count + usr.armies[army1_exists[1]][config.aeroplanes[i]];
								aeroplane_count = aeroplane_count + usr.armies[army2_exists[1]][config.aeroplanes[i]];
							}
							if ((usr.armies[army1_exists[1]].type == "air force" || usr.armies[army1_exists[1]].type == "navy" || usr.armies[army1_exists[1]].type == "army") && (usr.armies[army2_exists[1]].type == "air force" || usr.armies[army2_exists[1]].type == "navy" || usr.armies[army2_exists[1]].type == "army")) {
								if ((usr.armies[army1_exists[1]].type == "air force" && usr.armies[army2_exists[1]].type == "navy") || (usr.armies[army1_exists[1]].type == "navy" && usr.armies[army2_exists[1]].type == "air force")) {
									if (aeroplane_capacity == 0) {
										fatal_error = [true, "You don't have any ships capable of carrying aircraft in the fleet you are trying to merge to!"];
									} else if (aeroplane_count > aeroplane_capacity) {
										fatal_error = [true, "You don't have enough air capacity in the fleet you are trying to merge to! Consider assigning another aircraft carrier to your fleet."];
									}
								} else if ((usr.armies[army1_exists[1]].type == "army" && usr.armies[army2_exists[1]].type == "navy") || (usr.armies[army1_exists[1]].type == "navy" && usr.armies[army2_exists[1]].type == "army")) {
									fatal_error = [true, "Your ships are not capable of going on land!"];
								}
								
								if (fatal_error[0] == false) {
									//Merge the two armies
									
									for (var i = 0; i < config.units.length; i++) {
										usr.armies[army1_exists[1]][config.units[i]] = usr.armies[army1_exists[1]][config.units[i]] + usr.armies[army2_exists[1]][config.units[i]];
										usr.armies[army2_exists[1]][config.units[i]] = 0;
									}
									//Delete army2
									msg.channel.send("The **" + usr.armies[army2_exists[1]].name + "** was merged into the **" + usr.armies[army1_exists[1]].name + "**.");
									deleteArmy(arg0_user, "none", usr.armies[army2_exists[1]].name);
								} else {
									msg.channel.send(fatal_error[1]);
								}
							}
						} else {
							msg.channel.send("One of the armies you have specified did not exist!");
						}
					} else {
						msg.channel.send("You are trying to merge two nonexistent armies from a nonexistent country!");
					}
				}
			
				function moveArmy (arg0_user, arg1_msg, arg2_name, arg3_province) {
					var msg = arg1_msg;
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						var army_exists = [false, ""];
						
						//Check if army exists
						for (var i = 0; i < usr.armies.army_array.length; i++) {
							if (usr.armies[usr.armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
								army_exists = [true, usr.armies.army_array[i]];
							}
						}
						
						for (var i = 0; i < usr.armies.army_array.length; i++) {
							if (usr.armies[usr.armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
								army_exists = [true, usr.armies.army_array[i]];
							}
						}
						
						if (army_exists[0]) {
							if (arg2_name != "deleted-army") {
								//Check if army can move
								if (usr.armies[army_exists[1]].can_move[0]) {
									//Check if army has anyone in it
									var has_at_least_one_unit = false;
									for (var i = 0; i < config.units.length; i++) {
										if (usr.armies[army_exists[1]][config.units[i]] > 0) {
											has_at_least_one_unit = true;
										}
									}
									
									if (has_at_least_one_unit) {
										//Check if province exists
										if (usr.armies[army_exists[1]].type == "army" || usr.armies[army_exists[1]].type == "air force") {
											if (parseInt(arg3_province) > 0 && parseInt(arg3_province) < 1711) {
												if (parseInt(arg3_province) != usr.armies[army_exists[1]].province) {
													usr.armies[army_exists[1]].moving_to = arg3_province;
													var time_to_arrival = Math.ceil(Math.abs(parseInt(usr.armies[army_exists[1]].province - parseInt(arg3_province)))/(config.army_speed*usr.modifiers.army_travel_speed));
													msg.channel.send("The **" + usr.armies[army_exists[1]].name + "** is now en route to Province **" + arg3_province + "**. It will arrive in approximately **" + time_to_arrival + "** turns.");
													
													//Set status and orders
													usr.stationary_turns = 0;
													usr.armies[army_exists[1]].order = "moving";
													usr.armies[army_exists[1]].state = "moving";
												} else {
													msg.channel.send("Your army is already in the province you have specified!");
												}
											} else {
												msg.channel.send("You must enter a valid province ID between **0** and **1711**!");
											}
										} else {
											msg.channel.send("You can't move navies around on dry land!");
										}
									} else {
										msg.channel.send("You can't move around empty armies!");
									}
								} else {
									msg.channel.send("The army you have specified cannot move at the current time! It can move again in **" + usr.armies[army_exists[1]].can_move[1] + "** turns.");
								}
							} else {
								msg.channel.send("You can't move a deleted army!");
							}
						} else {
							msg.channel.send("No army by the name of **" + arg2_name + "** could be found!");
						}
					} else {
						msg.channel.send("You don't even have a country!");
					}
				}
			}
			
			//Naval order functions
			{
				function blockade (arg0_user, arg1_user, arg2_name, arg3_mode, arg4_msg) {
					var msg = arg4_msg;
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						
						if (main.users[arg1_user] != undefined) {
							var ot_user = main.users[arg1_user];
							var fleet_exists = [false, ""];
							
							//Find fleet, soft match first, hard match last
							for (var i = 0; i < usr.armies.army_array.length; i++) {
								if (usr.armies[usr.armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
									if (usr.armies[usr.armies.army_array[i]].type == "navy") {
										fleet_exists = [true, usr.armies.army_array[i]];
									}
								}
							}
							
							for (var i = 0; i < usr.armies.army_array.length; i++) {
								if (usr.armies[usr.armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
									if (usr.armies[usr.armies.army_array[i]].type == "navy") {
										fleet_exists = [true, usr.armies.army_array[i]];
									}
								}
							}
							
							if (fleet_exists[0]) {
								if (arg3_mode == "add") {
									var fleet_already_in_blockade = false;
									var all_blockades = Object.keys(main.users.global.blockades);
									
									for (var i = 0; i < all_blockades.length; i++) {
										for (var x = 0; x < main.users.global.blockades[all_blockades[i]].length; x++) {
											if (main.users.global.blockades[all_blockades[i]][x] == fleet_exists[1]) {
												fleet_already_in_blockade = true;
											}
										}
									}
									
									if (fleet_already_in_blockade == false) {
										if (usr.blockaded == false) {
											if (usr.armies[fleet_exists[1]].blockade_recovery_turns == 0) {
												if (main.users.global.blockades[arg1_user] == undefined) {
													if (usr["blockade_cooldown_" + arg1_user] == undefined) {
														if (usr.enable_blockades) {
															main.users.global.blockades[arg1_user] = [fleet_exists[1]];
															main.users.global.blockade_arrays[arg1_user] = [arg0_user];
															msg.channel.send("You have instituted a blockade on <@" + arg1_user + ">. They may challenge it any time by typing `" + bot_prefix + "challenge-blockade`.");
															main.users[arg1_user].blockaded = true;
															
															//Check if users are already at war, if not, give the blockaded user the 'Theft' CB.
															var already_at_war = false;
															if (usr.at_war.length > 0) {
																for (var i = 0; i < usr.at_war.length; i++) {
																	if (usr.at_war[i] == main.users[arg1_user].name) {
																		already_at_war = true;
																	}
																}
															}
															
															if (already_at_war == false) {
																ot_user.casus_belli.push(["theft", usr.id, 10]);
																usr.infamy = usr.infamy + 5;
																returnChannel(war_channel).send("<@" + ot_user.id + "> has gained the **Theft** CB on <@" + usr.id + ">!");
															}
														} else {
															msg.channel.send("You have not unlocked the ability to blockade users yet! Research **Naval Blockades** in your tech tree first.");
														}
													} else {
														msg.channel.send("You have blockaded this user too recently to impose another blockade on them! Wait at least **" + usr["blockade_cooldown_" + arg1_user] + "** turns before trying again.");
													}
												} else {
													var already_at_war = false;
													if (usr.at_war.length > 0) {
														for (var i = 0; i < usr.at_war.length; i++) {
															if (usr.at_war[i] == main.users[arg1_user].name) {
																already_at_war = true;
															}
														}
													}
													
													if (already_at_war) {
														main.users.global.blockades[arg1_user].push(fleet_exists[1]);
														main.users.global.blockade_arrays[arg1_user].push(arg0_user);
														msg.channel.send("You have assigned the **" + usr.armies[fleet_exists[1]].name + "** to reinforce the blockade on <@" + arg1_user + ">."); 
													} else {
														msg.channel.send("You can't reinforce a blockade of someone you're not at war with!");
													}
												}
												usr.armies[fleet_exists[1]].state = "blockading **" + ot_user.name + "**.";
											} else {
												msg.channel.send("The fleet you have specified is still recovering from a previous blockade! Wait at least **" + usr.armies[fleet_exists[1]].blockade_recovery_turns + "** more turns before sending them back out again.");
											}
										} else {
											msg.channel.send("You can't blockade other users whilst blockaded!");
										}
									} else {
										msg.channel.send("The fleet you have specified is already instituting a blockade!");
									}
								} else if (arg3_mode == "remove") {
									if (main.users.global.blockades[arg1_user] != undefined) {
										var fleet_in_blockade_array = false;
										var fleet_index = 0;
										for (var i = 0; i < main.users.global.blockades[arg1_user].length; i++) {
											if (main.users.global.blockades[arg1_user][i] == fleet_exists[1]) {
												fleet_in_blockade_array = true;
												fleet_index = i;
											}
										}
										
										if (fleet_in_blockade_array) {
											if (main.users.global.blockades[arg1_user].length > 1) {
												main.users.global.blockades[arg1_user].splice(fleet_index, 1);
												main.users.global.blockade_arrays.splice(fleet_index, 1);
												msg.channel.send("You have withdrawn the **" + usr.armies[fleet_exists[1]].name + "** from the blockade on <@" + arg1_user + ">.");
											} else {
												delete main.users.global.blockades[arg1_user];
												msg.channel.send("You have ended your blockade on <@" + arg1_user + ">.");
												usr["blockade_cooldown_" + arg1_user] = 3;
												main.users[arg1_user].blockaded = false;
											}
											usr.armies[fleet_exists[1]].state = "stationed";
										} else {
											msg.channel.send("This fleet has already withdrawn from the blockade!");
										}
									} else {
										msg.channel.send("There is no blockade on this user, and traffic is flowing normally. To impose a blockade, type `" + bot_prefix + "blockade <@user>`.");
									}
								}
							} else {
								msg.channel.send("The fleet you have specified turned out to be nonexistent! Please check `" + bot_prefix + "army-list` to make sure you've spelled out the name correctly.");
							}
						} else {
							msg.channel.send("The user you are trying to blockade doesn't even have a country!");
						}
					} else {
						msg.channel.send("You must have a country first in order to blockade other users!");
					}
				}
				
				function challengeBlockade (arg0_user, arg1_user, arg2_name, arg3_msg) {
					var msg = arg3_msg;
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						var fleet_exists = [false, ""];
						
						//Soft match first, hard match second
						for (var i = 0; i < usr.armies.army_array; i++) {
							if (usr.armies[usr.armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
								if (usr.armies[usr.armies.army_array[i]].type == "navy") {
									fleet_exists = [true, usr.armies.army_array[i]];
								}
							}
						}
						for (var i = 0; i < usr.armies.army_array; i++) {
							if (usr.armies[usr.armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
								if (usr.armies[usr.armies.army_array[i]].type == "navy") {
									fleet_exists = [true, usr.armies.army_array[i]];
								}
							}
						}
						
						if (main.users.global.blockades[arg1_user] != undefined) {
							var random_navy = Math.floor(Math.random()*main.users.global.blockades[arg1_user].length);
							var random_navy_user = main.users.global.blockade_arrays[arg1_user][random_navy];
							var random_processed_navy_name = main.users[random_navy_user].armies[main.users.global.blockades[arg1_user][random_navy]].name;
							combat(random_navy_user, random_processed_navy_name, arg0_user, usr.armies[fleet_exists[1]].name, "sea", msg);
							msg.channel.send("**You have decided to challenge the blockade imposed on your nation ...**");
						} else {
							msg.channel.send("There is currently no active blockade instituted on this user!");
						}
					} else {
						msg.channel.send("You must have a country in order to challenge blockades!");
					}
				}
				
				function submarineRaid (arg0_user, arg1_user, arg2_name, arg3_mode, arg4_msg) {
					var msg = arg3_msg;
					
					//modes: ["convoy", "naval", "reserves"]
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						
						if (main.users[arg1_user] != undefined) {
							var ot_user = main.users[arg1_user];
							var fleet_exists = [false, ""];
							
							//Soft match
							for (var i = 0; i < usr.armies.army_array.length; i++) {
								if (usr.armies[usr.armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
									fleet_exists = [true, usr.armies.army_array[i]];
								}
							}
							//Hard match
							for (var i = 0; i < usr.armies.army_array.length; i++) {
								if (usr.armies[usr.armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
									fleet_exists = [true, usr.armies.army_array[i]];
								}
							}
							
							if (fleet_exists[0]) {
								var has_navy = false;
								var navy_arrays = [];
								for (var i = 0; i < ot_user.armies.army_array.length; i++) {
									if (ot_user.armies[ot_user.armies.army_array[i]].type == "navy") {
										has_navy = true;
										navy_arrays.push(ot_user.armies.army_array[i]);
									}
								}
								
								if (has_navy) {
									var submarine_types = [];
									var destroyer_types = [];
									var cruiser_types = [];
									var helicopter_types = [];
									
									for (var i = 0; i < config.units.length; i++) {
										if (config.unit_stats[config.units[i]].submarine) {
											submarine_types.push(config.units[i]);
										}
									}
									for (var i = 0; i < config.units.length; i++) {
										if (config.unit_stats[config.units[i]].destroyer) {
											destroyer_types.push(config.units[i]);
										}
									}
									for (var i = 0; i < config.units.length; i++) {
										if (config.unit_stats[config.units[i]].cruiser) {
											cruiser_types.push(config.units[i]);
										}
									}
									for (var i = 0; i < config.units.length; i++) {
										if (config.unit_stats[config.units[i]].helicopter) {
											helicopter_types.push(config.units[i]);
										}
									}
									
									var pure_submarines = true;
									for (var i = 0; i < config.units.length; i++) {
										var is_submarine = false;
										for (var x = 0; x < submarine_types.length; x++) {
											if (config.units[i] == submarine_types[x]) {
												is_submarine = true;
											}
										}
										
										if (is_submarine == false) {
											if (usr.armies[fleet_exists[1]][config.units[i]] > 0) {
												pure_submarines = false;
											}
										}
									}
									
									if (pure_submarines) {
										var defender_ap = 0; //Sum up DP of all submarines, destroyers, and cruisers sitting in the selected scope. Cruisers count for half.
										var attacker_ap = 0;
										var submarines_lost = 0;
										
										//Calculate attacker AP
										for (var i = 0; i < usr.armies[fleet_exists[1]].length; i++) {
											for (var x = 0; x < submarine_types.length; x++) {
												attacker_ap = attacker_ap + usr.armies[fleet_exists[1]][submarine_types[x]]*config.unit_stats[submarine_types[x]].ap;
											}
										}
										
										var already_at_war = false;
										if (usr.at_war.length > 0) {
											for (var i = 0; i < usr.at_war.length; i++) {
												if (usr.at_war[i] == main.users[arg1_user].name) {
													already_at_war = true;
												}
											}
										}
										
										if (already_at_war) {
											if (usr.armies[fleet_exists[1]].submarine_cooldown == false) {
												if (mode == "convoy") { //Attacks a random import the user might have
													if (other_user.trade_array.length > 0) {
														for (var i = 0; i < ot_user.armies.army_array.length; i++) {
															for (var x = 0; x < submarine_types.length; x++) {
																defender_ap = defender_ap + ot_user.armies[ot_user.armies.army_array[i]][submarine_types[x]]*config.unit_stats[submarine_types[x]].ap;
															}
															for (var x = 0; x < destroyer_types.length; x++) {
																defender_ap = defender_ap + ot_user.armies[ot_user.armies.army_array[i]][destroyer_types[x]]*config.unit_stats[destroyer_types[x]].ap;
															}
															for (var x = 0; x < cruiser_types.length; x++) {
																defender_ap = defender_ap + Math.round(ot_user.armies[ot_user.armies.army_array[i]][cruiser_types[x]]*config.unit_stats[cruiser_types[x]].ap*0.5);
															}
															for (var x = 0; x < helicopter_types.length; x++) {
																defender_ap = defender_ap + ot_user.armies[ot_user.armies.army_array[i]][helicopter_types[x]]*config.unit_stats[helicopter_types[x]].ap;
															}
														}
														
														var succeed_chance = ((attacker_ap/defender_ap)*0.8)+0.2; //80% comes from the attacker to defender AP ratio, 20% base chance
														succeed_chance = succeed_chance*100;
														
														var random_chance = randomNumber(0, 100);
														
														if (random_chance <= succeed_chance) {
															//50-50 chance of losing a submarine or two
															submarines_lost = randomNumber(0,2);
															var submarines_lost_so_far = submarines_lost;
															var actual_sub_losses = 0;
															
															for (var i = 0; i < submarine_types.length; i++) {
																if (usr.armies[fleet_exists[1]][submarine_types[i]] > 0) {
																	if (usr.armies[fleet_exists[1]][submarine_types[i]] < submarines_lost) {
																		submarines_lost_so_far = submarines_lost_so_far + usr.armies[fleet_exists[1]][submarine_types[i]];
																		removePops(arg0_user, usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
																		usr.used_soldiers = usr.used_soldiers - usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost;
																		submarines_lost = submarines_lost - usr.armies[fleet_exists[1]][submarine_types[i]];
																		usr.armies[fleet_exists[1]][submarine_types[i]] = 0;
																	} else {
																		submarines_lost_so_far = submarines_lost_so_far + submarines_lost;
																		removePops(arg0_user, submarines_lost*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
																		usr.used_soldiers = usr.used_soldiers - submarines_lost*config.unit_stats[submarine_types[i]].manpower_cost;
																		usr.armies[fleet_exists[1]][submarine_types[i]] + usr.armies[fleet_exists[1]][submarine_types[i]] - submarines_lost;
																		submarines_lost = 0;
																	}
																}
															}
															
															submarines_lost = submarines_lost_so_far;
															
															//Destroy random import
															var element_to_remove = Math.floor(Math.random()*other_user.trade_array.length);
															msg.channel.send("Your submarines intercepted a shipment of " + other_user.trade_array[element_to_remove][0][0] + " " + other_user.trade_array[element_to_remove][0][1] + " at the cost of **" + submarines_lost + "** of their own.");
															other_user.trade_array.splice(element_to_remove, 1);
														} else {
															//Failure, you just lose submarines
															var random_counter_roll = randomNumber(0, defender_ap);
															var submarines_lost = 0;
															
															for (var i = 0; i < submarine_types.length; i++) {
																if (usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].dp < random_counter_roll) {
																	submarines_lost = submarines_lost + usr.armies[fleet_exists[1]][submarine_types[i]];
																	random_counter_roll = random_counter_roll - usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].dp;
																	usr.used_soldiers = usr.used_soldiers - usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost;
																	removePops(arg0_user, usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
																	usr.armies[fleet_exists[1]][submarine_types[i]] = 0;
																} else {
																	submarines_lost = submarines_lost - Math.floor(random_counter_roll/config.unit_stats[submarine_types[i]].dp);
																	random_counter_roll = 0;
																	usr.used_soldiers = usr.used_soldiers - Math.floor(random_counter_roll/config.unit_stats[submarine_types[i]].dp)*config.unit_stats[submarine_types[i]].manpower_cost;
																	removePops(arg0_user, Math.floor(random_counter_roll/config.unit_stats[submarine_types[i]].dp)*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
																	usr.armies[fleet_exists[1]][submarine_types[i]] = usr.armies[fleet_exists[1]][submarine_types[i]] - Math.floor(random_counter_roll/config.unit_stats[submarine_types[i]].dp);
																}
															}
															
															usr.armies[fleet_exists[1]].submarine_cooldown = true;
															msg.channel.send("Your submarines failed to intercept any merchant shipping. Instead, **" + submarines_lost + "** of our own submarines was sent to the deep blue depths of the high seas.");
														}
													} else {
														msg.channel.send("The target you have selected has no merchant shipping being conducted!");
													}
												} else if (mode == "naval") { //Attacks a random fleet
													var random_attacker_roll = randomNumber(0, attacker_ap);
													var random_defender_roll = randomNumber(0, defender_ap);
													var lost_defender_units = [];
													var lost_attacker_units = 0;
													
													var all_fleets = [];
													
													for (var i = 0; i < ot_user.armies.army_array.length; i++) {
														if (ot_user.armies[ot_user.armies.army_array[i]].type == "navy") {
															all_fleets.push(ot_user.armies.army_array[i]);
														}
													}
													
													var random_fleet = randomElement(all_fleets);
													
													//Calculate defender AP
													for (var x = 0; x < submarine_types.length; x++) {
														defender_ap = defender_ap + ot_user.armies[random_fleet][submarine_types[x]]*config.unit_stats[submarine_types[x]].ap;
													}
													for (var x = 0; x < destroyer_types.length; x++) {
														defender_ap = defender_ap + ot_user.armies[random_fleet][destroyer_types[x]]*config.unit_stats[destroyer_types[x]].ap;
													}
													for (var x = 0; x < cruiser_types.length; x++) {
														defender_ap = defender_ap + Math.round(ot_user.armies[random_fleet][cruiser_types[x]]*config.unit_stats[cruiser_types[x]].ap*0.5);
													}
													
													//Defender losses go first
													for (var i = 0; i < config.units.length; i++) {
														if (random_attacker_roll > ot_user.armies[random_fleet][config.units[i]]*unit_stats[config.units[i]].dp) {
															lost_defender_units.push(ot_user.armies[random_fleet][config.units[i]] + " " + config.unit_stats[config.units[i]].name);
															removePops(arg1_user, ot_user.armies[random_fleet][config.units[i]]*config.unit_stats[config.units[i]].manpower_cost, "soldiers");
															usr.used_soldiers = usr.used_soldiers - ot_user.armies[random_fleet][config.units[i]]*config.unit_stats[config.units[i]].manpower_cost;
															ot_user.armies[random_fleet][config.units[i]] = 0;
															random_attacker_roll = random_attacker_roll - ot_user.armies[random_fleet][config.units[i]]*unit_stats[config.units[i]].dp;
														} else {
															lost_defender_units.push(Math.floor(random_attacker_roll/(ot_user.armies[random_fleet][config.units[i]]*unit_stats[config.units[i]].dp)) + " " + config.unit_stats[config.units[i]].name);
															usr.used_soldiers = usr.used_soldiers - Math.floor(random_attacker_roll/(ot_user.armies[random_fleet][config.units[i]]*unit_stats[config.units[i]].dp))*config.unit_stats[config.units[i]].manpower_cost;
															removePops(arg1_user, Math.floor(random_attacker_roll/(ot_user.armies[random_fleet][config.units[i]]*unit_stats[config.units[i]].dp))*config.unit_stats[config.units[i]].manpower_cost, "soldiers");
															ot_user.armies[random_fleet][config.units[i]] = ot_user.armies[random_fleet][config.units[i]] - Math.floor(random_attacker_roll/(ot_user.armies[random_fleet][config.units[i]]*unit_stats[config.units[i]].dp));
															random_attacker_roll = 0;
														}
													}
													
													//Attacker losses go second
													for (var i = 0; i < submarine_types.length; i++) {
														if (random_defender_roll > usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].dp) {
															lost_attacker_units = lost_attacker_units + usr.armies[fleet_exists[1]][submarine_types[i]];
															removePops(arg0_user, usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
															usr.used_soldiers = usr.used_soldiers - usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost;
															random_defender_roll = random_defender_roll - usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].dp;
															usr.armies[fleet_exists[1]][submarine_types[i]] = 0;
														} else {
															lost_attacker_units = lost_attacker_units + Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp);
															removePops(arg0_user, Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp)*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
															usr.used_soldiers = usr.used_soldiers - Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp)*config.unit_stats[submarine_types[i]].manpower_cost;
															random_defender_roll = 0;
															usr.armies[fleet_exists[1]][submarine_types[i]] = usr.armies[fleet_exists[1]][submarine_types[i]] - Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp);
														}
													}
													
													usr.armies[fleet_exists[1]].submarine_cooldown = true;
													returnChannel(war_channel).send("<@" + arg1_user + "> lost " + lost_defender_units.join(", ") + " during a submarine attack on the **" + ot_user.armies[random_fleet].name + "**.\n\n<@" + arg0_user + "> also lost **" + lost_attacker_units + "** submarines.");
												} else if (mode == "reserves") { //Attacks naval reserves, air forces may intervene
													for (var i = 0; i < ot_user.armies.army_array.length; i++) {
														for (var x = 0; x < submarine_types.length; x++) {
															defender_ap = defender_ap + ot_user.armies[ot_user.armies.army_array[i]][submarine_types[x]]*config.unit_stats[submarine_types[x]].ap;
														}
														for (var x = 0; x < destroyer_types.length; x++) {
															defender_ap = defender_ap + ot_user.armies[ot_user.armies.army_array[i]][destroyer_types[x]]*config.unit_stats[destroyer_types[x]].ap;
														}
														for (var x = 0; x < cruiser_types.length; x++) {
															defender_ap = defender_ap + Math.round(ot_user.armies[ot_user.armies.army_array[i]][cruiser_types[x]]*config.unit_stats[cruiser_types[x]].ap*0.5);
														}
														for (var x = 0; x < helicopter_types.length; x++) {
															defender_ap = defender_ap + ot_user.armies[ot_user.armies.army_array[i]][helicopter_types[x]]*config.unit_stats[helicopter_types[x]].ap;
														}
													}
													for (var i = 0; i < submarine_types.length; i++) {
														defender_ap = defender_ap + ot_user.military[submarine_types[i]]*config.unit_stats[submarine_types[i]].ap;
													}
													for (var i = 0; i < destroyer_types.length; i++) {
														defender_ap = defender_ap + ot_user.military[destroyer_types[i]]*config.unit_stats[destroyer_types[i]].ap;
													}
													for (var i = 0; i < cruiser_types.length; i++) {
														defender_ap = defender_ap + ot_user.military[cruiser_types[i]]*config.unit_stats[cruiser_types[i]].ap;
													}
													for (var i = 0; i < helicopter_types.length; i++) {
														defender_ap = defender_ap + ot_user.military[helicopter_types[i]]*config.unit_stats[helicopter_types[i]].ap;
													}
													
													var random_attacker_roll = randomNumber(0, attacker_ap);
													var random_defender_roll = randomNumber(0, defender_ap);
													var lost_defender_units = [];
													var lost_attacker_units = 0;
													
													//Defender losses go first
													for (var i = 0; i < config.naval_units.length; i++) {
														if (random_attacker_roll > ot_user.military[config.naval_units[i]]*config.unit_stats[config.naval_units[i]].dp) {
															usr.used_soldiers = usr.used_soldiers - ot_user.military[config.naval_units[i]]*config.unit_stats[config.naval_units[i]].manpower_cost;
															removePops(arg0_user, ot_user.military[config.naval_units[i]]*config.unit_stats[config.naval_units[i]].manpower_cost, "soldiers");
															lost_defender_units.push(ot_user.military[config.naval_units[i]] + " " + config.unit_stats[config.naval_units[i]].name);
															ot_user.military[config.naval_units[i]] = 0;
															random_attacker_roll = random_attacker_roll - ot_user.military[config.naval_units[i]]*config.unit_stats[config.naval_units[i]].dp;
														} else {
															usr.used_soldiers = usr.used_soldiers - Math.floor(random_attacker_roll/config.unit_stats[config.naval_units[i]].dp)*config.unit_stats[config.naval_units[i]].manpower_cost;
															removePops(arg0_user, Math.floor(random_attacker_roll/config.unit_stats[config.naval_units[i]].dp)*config.unit_stats[config.naval_units[i]].manpower_cost, "soldiers");
															lost_defender_units.push(Math.floor(random_attacker_roll/config.unit_stats[config.naval_units[i]].dp) + " " + config.unit_stats[config.naval_units[i]].name);
															ot_user.military[config.naval_units[i]] = ot_user.military[config.naval_units[i]] - Math.floor(random_attacker_roll/config.unit_stats[config.naval_units[i]].dp);
														}
													}
													
													//Attacker losses go second
													for (var i = 0; i < submarine_types.length; i++) {
														if (random_defender_roll > usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].dp) {
															lost_attacker_units = lost_attacker_units + usr.armies[fleet_exists[1]][submarine_types[i]];
															removePops(arg0_user, usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
															usr.used_soldiers = usr.used_soldiers - usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost;
															random_defender_roll = random_defender_roll - usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].dp;
															usr.armies[fleet_exists[1]][submarine_types[i]] = 0;
														} else {
															lost_attacker_units = lost_attacker_units + Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp);
															removePops(arg0_user, Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp)*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
															usr.used_soldiers = usr.used_soldiers - Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp)*config.unit_stats[submarine_types[i]].manpower_cost;
															random_defender_roll = 0;
															usr.armies[fleet_exists[1]][submarine_types[i]] = usr.armies[fleet_exists[1]][submarine_types[i]] - Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp);
														}
													}
													
													usr.armies[fleet_exists[1]].submarine_cooldown = true;
													returnChannel(war_channel).send("<@" + arg1_user + "> lost " + lost_defender_units.join(", ") + " during a submarine attack on their reserves.\n\n<@" + arg0_user + "> also lost **" + lost_attacker_units + "** submarines.");
												}
											} else {
												msg.channel.send("You've already used up your submarine flotilla's special abilities for this turn! Wait until next round to attack again.");
											}
										} else {
											msg.channel.send("You may not torpedo the ships of neutral nations!");
										}
									} else {
										msg.channel.send("Your fleet must be comprised of only submarines in order to send them out on raiding missions!");
									}
								} else {
									msg.channel.send("The user you have specified has no active naval fleets in service!");
								}
							} else {
								msg.channel.send("A fleet by the name you have specified could not be found.");
							}
						} else {
							msg.channel.send("The user you are attempting to raid doesn't even have a navy!");
						}
					} else {
						msg.channel.send("You must have a country in order to start raiding shipping lanes!");
					}
				}
			}
			
			function newArmy (arg0_user, arg1_msg, arg2_name, arg3_province) {
				var msg = arg1_msg;
				var name_exists = false;
				
				if (main.users[arg0_user] != undefined) {
					if (arg2_name != "deleted-army") {
						var usr = main.users[arg0_user];
						var armies = main.users[arg0_user].armies;
						
						//Check if army already exists
						for (var i = 0; i < armies.army_array.length; i++) {
							if (armies.army_array[i] == arg2_name) {
								name_exists = true;
							}
						}
						
						if (name_exists) {
							msg.channel.send("There already exists an army by this name!");
						} else {
							//Create the army
							armies.army_array.push(arg2_name);
							armies[arg2_name] = {};
							armies[arg2_name].name = arg2_name;
							armies[arg2_name].type = ""; //Land (air_land, land), Air, Sea (air_sea, sea).
							armies[arg2_name].in_battle = false; //Used to test whether army is currently in a battle when checking for same-province hostile armies.
							armies[arg2_name].can_move = [true, 0]; //[can_move, turns_until_can_move].
							armies[arg2_name].blockade_recovery_turns = 0; //Turns before unit can reinforce a blockade.
							armies[arg2_name].stationary_turns = 0; //Turns that unit has not moved.
							armies[arg2_name].submarine_cooldown = false; //Submarine special ability cooldown, can only be activated once per turn.
							armies[arg2_name].ap = 1; //Modifiers for AP, DP, MP and IP.
							armies[arg2_name].dp = 1;
							armies[arg2_name].mp = 1;
							armies[arg2_name].ip = 1;
							if (arg3_province != undefined) {
								armies[arg2_name].province = arg3_province;
								armies[arg2_name].moving_to = arg3_province;
							} else {
								armies[arg2_name].province = usr.capital_id;
								armies[arg2_name].moving_to = usr.capital_id;
							}
							
							armies[arg2_name].state = "stationed";
							for (var i = 0; i < config.units.length; i++) {
								armies[arg2_name][config.units[i]] = 0;
							}
						}
					} else {
						msg.channel.send("Stop trying to cheese the system!");
					}
				} else {
					msg.channel.send("You don't have a country yet, you wannabe mercenary!");
				}
			}
			
			function editArmy (arg0_user, arg1_msg, arg2_name, arg3_amount, arg4_unit, arg5_mode) {
				var msg = arg1_msg;
				var army_exists = [false, ""];
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var armies = main.users[arg0_user].armies;
					var reserves = main.users[arg0_user].military;
					
					//Check if army exists - soft match
					for (var i = 0; i < armies.army_array.length; i++) {
						if (armies[armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					//Check if army exists - hard match
					for (var i = 0; i < armies.army_array.length; i++) {
						if (armies[armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					//Add units
					if (army_exists[0] && army_exists[1] != "deleted-army") {
						//Check if unit exists
						var unit_exists = false;
						for (var i = 0; i < config.units.length; i++) {
							if (config.units[i] == arg4_unit) {
								unit_exists = true;
							}
						}
						
						if (unit_exists) {
							//Check for mode (add, remove)
							if (arg5_mode == "add") {
								if (parseInt(arg3_amount) > reserves[arg4_unit]) {
									msg.channel.send("You don't have that many troops in reserve!");
								} else {
									var receiving_air_unit = false;
									var receiving_naval_unit = false;
									var receiving_land_unit = false;
									
									var has_air_unit = false;
									var has_naval_unit = false;
									var has_land_unit = false;
									
									var error_code = [false, ""];
									
									var carrier_capacity_count = 0;
									var aeroplane_count = 0;
									
									for (var i = 0; i < config.units.length; i++) {
										for (var x = 0; x < config.ground_units.length; x++) {
											if (armies[army_exists[1]][config.ground_units[x]] > 0) {
												has_land_unit = true;
											}
										}
										for (var x = 0; x < config.ground_artillery.length; x++) {
											if (armies[army_exists[1]][config.ground_artillery[x]] > 0) {
												has_land_unit = true;
											}
										}
										for (var x = 0; x < config.ground_vehicles.length; x++) {
											if (armies[army_exists[1]][config.ground_vehicles[x]] > 0) {
												has_land_unit = true;
											}
										}
										for (var x = 0; x < config.aeroplanes.length; x++) {
											if (armies[army_exists[1]][config.aeroplanes[x]] > 0) {
												has_air_unit = true;
											}
										}
										for (var x = 0; x < config.naval_units.length; x++) {
											if (armies[army_exists[1]][config.naval_units[x]] > 0) {
												has_naval_unit = true;
												if (config.unit_stats[naval_units[x]].carrier_capacity != undefined) {
													carrier_capacity_count = carrier_capacity_count + armies[army_exists[1]][config.naval_units[x]]*config.unit_stats[naval_units[x]].carrier_capacity;
												}
											}
										}
									}
									
									for (var i = 0; i < config.units.length; i++) {
										for (var x = 0; x < config.ground_units.length; x++) {
											if (arg4_unit == config.ground_units[i]) {
												receiving_land_unit = true;
											}
										}
										for (var x = 0; x < config.ground_artillery.length; x++) {
											if (arg4_unit == config.ground_artillery[i]) {
												receiving_land_unit = true;
											}
										}
										for (var x = 0; x < config.ground_vehicles.length; x++) {
											if (arg4_unit == config.ground_vehicles[i]) {
												receiving_land_unit = true;
											}
										}
										for (var x = 0; x < config.aeroplanes.length; x++) {
											if (arg4_unit == config.aeroplanes[i]) {
												receiving_air_unit = true;
											}
										}
										for (var x = 0; x < config.naval_units.length; x++) {
											if (arg4_unit == config.naval_units[i]) {
												receiving_naval_unit = true;
											}
										}
									}
									
									//Aeroplane count
									for (var x = 0; x < config.aeroplanes.length; x++) {
										if (armies[army_exists[1]][config.aeroplanes[x]] > 0) {
											aeroplane_count = aeroplane_count + armies[army_exists[1]][config.aeroplanes[x]];
										}
									}
									
									if (has_naval_unit) { //Classified as a navy
										if (receiving_air_unit) {
											if (aeroplane_count == 0) {
												error_code = [true, "Your navy doesn't have air capabilities! Consider assigning aircraft carriers to your navy first."];
											} else {
												if ((parseInt(arg3_amount)+aeroplane_count) > carrier_capacity_count) {
													error_code = [true, "Your aircraft carriers can't carry that many aeroplanes!"];
												}
											}
										}
										if (receiving_land_unit) {
											error_code = [true, "Your soldiers can't swim that far!"];
										}
									} else if (has_air_unit) { //Classified as an air force
										if (receiving_naval_unit) {
											if (aeroplane_count == 0) {
												error_code = [true, "The ships you have tried to assign don't have air capabilities! Consider assigning aircraft carriers instead."];
											} else {
												if ((parseInt(arg3_amount)+aeroplane_count) > carrier_capacity_count) {
													error_code = [true, "Your aircraft carriers can't carry that many aeroplanes!"];
												}
											}
										}
									} else if (has_land_unit) { //Classified as an army
										if (receiving_naval_unit) {
											error_code = [true, "That's not what I meant when I said landship ..."];
										}
									}
									
									//Check if provinces of the capital id and army are the same
									if (armies[army_exists[1]].province != usr.capital_id) {
										if (usr.at_war.length > 0) {
											error_code = [true, "You can't transfer to armies not in your capital province whilst at war!"];
										}
									}
									
									if (error_code[0]) {
										msg.channel.send(error_code[1]);
									} else {
										armies[army_exists[1]][arg4_unit] = armies[army_exists[1]][arg4_unit] + parseInt(arg3_amount);
										reserves[arg4_unit] = reserves[arg4_unit] - parseInt(arg3_amount);
											
										msg.channel.send("**" + parseNumber(parseInt(arg3_amount)) + "** " + arg4_unit + " were deployed in the " + armies[army_exists[1]].name + ".");
										
										//Recalculate army type
										for (var i = 0; i < config.units.length; i++) {
											for (var x = 0; x < config.ground_units.length; x++) {
												if (armies[army_exists[1]][config.ground_units[x]] > 0) {
													has_land_unit = true;
												}
											}
											for (var x = 0; x < config.ground_artillery.length; x++) {
												if (armies[army_exists[1]][config.ground_artillery[x]] > 0) {
													has_land_unit = true;
												}
											}
											for (var x = 0; x < config.ground_vehicles.length; x++) {
												if (armies[army_exists[1]][config.ground_vehicles[x]] > 0) {
													has_land_unit = true;
												}
											}
											for (var x = 0; x < config.aeroplanes.length; x++) {
												if (armies[army_exists[1]][config.aeroplanes[x]] > 0) {
													has_air_unit = true;
												}
											}
											for (var x = 0; x < config.naval_units.length; x++) {
												if (armies[army_exists[1]][config.naval_units[x]] > 0) {
													has_naval_unit = true;
													if (config.unit_stats[naval_units[x]].carrier_capacity != undefined) {
														carrier_capacity_count = carrier_capacity_count + armies[army_exists[1]][config.naval_units[x]]*config.unit_stats[naval_units[x]].carrier_capacity;
													}
												}
											}
										}
									
										{
											if ((has_naval_unit && has_air_unit) || (has_naval_unit)) {
												armies[army_exists[1]].type = "navy";
											} else if ((has_land_unit && has_air_unit) || (has_land_unit)) {
												armies[army_exists[1]].type = "army";
											} else if (has_air_unit && has_land_unit != true && has_naval_unit != true) {
												armies[army_exists[1]].type = "air force";
											}
										}
									}
								} 
							} else if (arg5_mode == "remove") {
								if (armies[army_exists[1]].blockade_recovery_turns == 0) {
									if (armies[army_exists[1]].submarine_cooldown == false) {
										if (parseInt(arg3_amount) > armies[army_exists[1]][arg4_unit]) {
											msg.channel.send("You don't have that many troops in " + armies[army_exists[1]].name + "!");
										} else {
											armies[army_exists[1]][arg4_unit] = armies[army_exists[1]][arg4_unit] - parseInt(arg3_amount);
											reserves[arg4_unit] = reserves[arg4_unit] + parseInt(arg3_amount);
												
											msg.channel.send("You placed **" + parseNumber(parseInt(arg3_amount)) + "** " + arg4_unit + " from the " + armies[army_exists[1]].name + " back into reserve.");
										}
									} else {
										msg.channel.send("The submarine flotilla you have specified is currently on cooldown! Wait until next turn to transfer submarines out of this flotilla.");
									}
								} else {
									msg.channel.send("The fleet you have specified is still recovering from a naval battle! The recovery is expected to take at least **" + armies[army_exists[1]].blockade_recovery_turns + "** more turns. Until then, no units can be transferred out of the fleet.");
								}
							} else {
								msg.channel.send("Something went wrong. Please DM Vis for more information.");
							}
						} else {
							msg.channel.send("The unit you have specified doesn't exist!");
						}
					} else {
						msg.channel.send("The army you have specified doesn't exist! Try putting it in double inverted commas if the name contains spaces.");
					}
				} else {
					msg.channel.send("You don't have a country yet, you wannabe mercenary!");
				}
			}
			
			function renameArmy (arg0_user, arg1_msg, arg2_name, arg3_newname) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var armies = main.users[arg0_user].armies;
					var army_exists = [false, ""];
					
					//Check if army exists - soft match
					for (var i = 0; i < armies.army_array.length; i++) {
						if (armies[armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					//Check if army exists - hard match
					for (var i = 0; i < armies.army_array.length; i++) {
						if (armies[armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					if (army_exists[0]) {
						var old_name = armies[army_exists[1]].name;
						armies[army_exists[1]].name = arg3_newname;
						msg.channel.send("You have updated the name of the " + old_name + " to the **" + arg3_newname + "**!");
					} else {
						msg.channel.send("The army you have specified is nonexistent!");
					}
				} else {
					msg.channel.send("You're stateless!");
				}
			}
			
			function disband (arg0_user, arg1_msg, arg2_unit, arg3_amount) {
				var usr = main.users[arg0_user];
				
				var unit_exists = false;
				var unit_id = "";
				
				for (var i = 0; i < config.units.length; i++) {
					if (config.units[i] == arg2_unit) {
						unit_exists = true;
						unit_id = arg2_unit;
					}
				}
				
				if (unit_exists) {
					if (usr["military"][arg2_unit] >= parseInt(arg3_amount)) {
						var unit_manpower_cost = 0;
						
						if (config.unit_stats[unit_id].costs != undefined) {
							for (var i = 0; i < config.unit_stats[unit_id].costs.length; i++) {
								if (config.unit_stats[unit_id].costs[i][1] == "manpower") {
									unit_manpower_cost = config.unit_stats[unit_id].costs[i][0];
								}
							}
						} else {
							unit_manpower_cost = 0;
						}
						
						usr.used_soldiers = usr.used_soldiers - (Math.ceil(unit_manpower_cost/config.unit_stats[unit_id].quantity))*parseInt(arg3_amount);
						usr.used_manpower = usr.used_manpower - (Math.ceil(unit_manpower_cost/config.unit_stats[unit_id].quantity))*parseInt(arg3_amount);
						usr["military"][arg2_unit] = usr["military"][arg2_unit] - parseInt(arg3_amount);
						
						arg1_msg.channel.send(parseInt(arg3_amount) + " " + arg2_unit + " were disbanded. You were refunded " + Math.ceil(Math.ceil(unit_manpower_cost/config.unit_stats[unit_id].quantity)*parseInt(arg3_amount)) + " manpower.");
					} else {
						arg1_msg.channel.send("You don't have that many **" + arg2_unit + "**!");
					}
				} else {
					arg1_msg.channel.send("The type of unit that you have specified does not exist!");
				}
			}
			
			function deleteArmy (arg0_user, arg1_msg, arg2_name) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var armies = main.users[arg0_user].armies;
					var army_exists = [false, ""];
					
					//Check if army exists - soft match
					for (var i = 0; i < armies.army_array.length; i++) {
						if (armies[armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					//Check if army exists - hard match
					for (var i = 0; i < armies.army_array.length; i++) {
						if (armies[armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					if (army_exists[0] && army_exists[1] != "deleted-army") {
						var old_name = armies[army_exists[1]].name;
						
						for (var i = 0; i < config.units.length; i++) {
							usr.military[config.units[i]] = usr.military[config.units[i]] + armies[army_exists[1]][config.units[i]];
							armies[army_exists[1]][config.units[i]] = 0;
						}
						
						//Check if army was reinforcing a blockade, if so, remove it.
						var all_blockades = main.users.global.blockades;
						for (var i = 0; i < all_blockades.length; i++) {
							for (var x = 0; x < main.users.global.blockades[all_blockades[i]].length; x++) {
								if (main.users.global.blockades[all_blockades[i]][x] == army_exists[1]) {
									main.users.global.blockades[all_blockades[i]].splice(x, 1);
								}
							}
						}
						
						armies[army_exists[1]].name = "deleted-army";
						if (arg1_msg != "none") {
							msg.channel.send("You have demobilised the **" + old_name + "**! They have now been returned to the reserves.");
						}
					} else {
						if (arg1_msg != "none") {
							msg.channel.send("The army you have specified is nonexistent!");
						}
					}
				} else {
					msg.channel.send("You're currently stateless!");
				}
			}
			
			function printArmy (arg0_user, arg1_msg, arg2_name) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var armies = main.users[arg0_user].armies;
					var army_exists = [false, ""];
					
					//Check if army exists - soft match
					for (var i = 0; i < armies.army_array.length; i++) {
						if (armies[armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					//Check if army exists - hard match
					for (var i = 0; i < armies.army_array.length; i++) {
						if (armies[armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					if (army_exists[0] && army_exists[1] != "deleted-army") {
						var military_string = [];
						
						military_string.push("<:globe:716811246556545035> Country: **" + main.users[arg0_user].name + "**");
						
						var empty_army = true;
						var ap = 0;
						var dp = 0;
						
						var has_air_unit = false;
						var has_naval_unit = false;
						var has_land_unit = false;
						
						var army_icon = "";
						var carrier_capacity_count = 0;
						var aeroplane_count = 0;
						
						var carrier_capacity_string = "";
									
						for (var i = 0; i < config.units.length; i++) {
							for (var x = 0; x < config.ground_units.length; x++) {
								if (armies[army_exists[1]][config.ground_units[x]] > 0) {
									empty_army = false;
									has_land_unit = true;
									army_icon = "<:manpower:716817688705499177>";
								}
							}
							for (var x = 0; x < config.ground_artillery.length; x++) {
								if (armies[army_exists[1]][config.ground_artillery[x]] > 0) {
									empty_army = false;
									has_land_unit = true;
									army_icon = "<:artillery:716821195055431681>";
								}
							}
							for (var x = 0; x < config.ground_vehicles.length; x++) {
								if (armies[army_exists[1]][config.ground_vehicles[x]] > 0) {
									empty_army = false;
									has_land_unit = true;
									army_icon = "<:land_vehicles:716821195215077406>";
								}
							}
							for (var x = 0; x < config.aeroplanes.length; x++) {
								if (armies[army_exists[1]][config.aeroplanes[x]] > 0) {
									empty_army = false;
									has_air_unit = true;
									army_icon = "<:aeroplanes:716821195407884358>";
								}
							}
							for (var x = 0; x < config.naval_units.length; x++) {
								if (armies[army_exists[1]][config.naval_units[x]] > 0) {
									empty_army = false;
									has_naval_unit = true;
									army_icon = "<:naval_units:716821195277729832>";
								}
							}
						}
						
						for (var x = 0; x < config.aeroplanes.length; x++) {
							if (armies[army_exists[1]][config.aeroplanes[x]] > 0) {
								aeroplane_count = aeroplane_count + armies[army_exists[1]][config.aeroplanes[x]];
							}
						}
						
						var submarine_types = [];
						var pure_submarines = true;
						
						for (var i = 0; i < config.units.length; i++) {
							if (config.unit_stats[config.units[i]].submarine) {
								submarine_types.push(config.units[i]);
							}
						}
						
						for (var i = 0; i < config.units.length; i++) {
							var is_submarine = false;
							for (var x = 0; x < submarine_types.length; x++) {
								if (config.units[i] == submarine_types[x]) {
									is_submarine = true;
								}
							}
										
							if (is_submarine == false) {
								if (usr.armies[army_exists[1]][config.units[i]] > 0) {
									pure_submarines = false;
								}
							}
						}
						
						carrier_capacity_count = carrier_capacity_count + (armies[army_exists[1]]["aircraft_carriers"]+armies[army_exists[1]]["supercarriers"])*config.carrier_capacity;
						
						if (carrier_capacity_count > 0) {
							carrier_capacity_string = " (Carrier Capacity: **" + aeroplane_count + "**/**" + carrier_capacity_count + "**)";
						}
						
						military_string.push("------------------ \n" + army_icon + " **" + armies[army_exists[1]].name + "**" + carrier_capacity_string + ":");
						
						if (carrier_capacity_count > 0) {
							military_string.push("<:aeroplanes:716821195407884358> **Aeroplanes** receive a **+50%** attack bonus whilst at sea.");
						}
						
						var relieve_unit_string = "";
						var move_unit_string = "";
						
						if (empty_army == false) {
							relieve_unit_string = "  `" + bot_prefix + "relieve-units`";
						}
						
						military_string.push("`" + bot_prefix + "rename-army`  `" + bot_prefix + "transfer-units`" + relieve_unit_string);
						//Army orders and commands display
						if (armies[army_exists[1]].type == "army") {
							military_string.push("`" + bot_prefix + "merge-army`  `" + bot_prefix + "move`");
						} else if (armies[army_exists[1]].type == "navy") {
							if (pure_submarines == false) {
								var fleet_already_in_blockade = false;
								var lift_blockade_string = "";
								var all_blockades = Object.keys(main.users.global.blockades);
									
								for (var i = 0; i < all_blockades.length; i++) {
									for (var x = 0; x < main.users.global.blockades[all_blockades[i]].length; x++) {
										if (main.users.global.blockades[all_blockades[i]][x] == army_exists[1]) {
											fleet_already_in_blockade = true;
										}
									}
								}
								
								if (fleet_already_in_blockade) {
									lift_blockade_string = "  `" + bot_prefix + "lift-blockade";
								}
								
								if (usr.enable_blockades) {
									military_string.push("`" + bot_prefix + "blockade`  `" + bot_prefix + "challenge-blockade`" + lift_blockade_string);
								} else {
									military_string.push("`" + bot_prefix + "challenge-blockade`" + lift_blockade_string);
								}
							} else {
								military_string.push("`" + bot_prefix + "convoy-raid`  `" + bot_prefix + "harbour-raid`  `" + bot_prefix + "torpedo-fleet`");
							}
						} else if (armies[army_exists[1]].type == "air force") {
							military_string.push("`" + bot_prefix + "merge-army`  `" + bot_prefix + "move`  `" + bot_prefix + "air-raid`");
						}
						
						military_string.push("------------------");
						
						for (var i = 0; i < config.units.length; i++) {
							ap = ap + main.users[arg0_user]["military"][config.units[i]]*config.unit_stats[config.units[i]].ap;
							dp = dp + main.users[arg0_user]["military"][config.units[i]]*config.unit_stats[config.units[i]].dp;
						}
						for (var i = 0; i < config.ground_units.length; i++) {
							if (armies[army_exists[1]][config.ground_units[i]] > 0) {
								military_string.push("<:active_personnel:716820390474940426> **" + config.ground_units[i] + "**: " + armies[army_exists[1]][config.ground_units[i]]);
								empty_army = false;
							}
						}
						for (var i = 0; i < config.ground_artillery.length; i++) {
							if (armies[army_exists[1]][config.ground_artillery[i]] > 0) {
								military_string.push("<:artillery:716821195055431681> **" + config.ground_artillery[i] + "**: " + armies[army_exists[1]][config.ground_artillery[i]]);
								empty_army = false;
							}
						}
						for (var i = 0; i < config.ground_vehicles.length; i++) {
							if (armies[army_exists[1]][config.ground_vehicles[i]] > 0) {
								military_string.push("<:land_vehicles:716821195215077406> **" + config.ground_vehicles[i] + "**: " + armies[army_exists[1]][config.ground_vehicles[i]]);
								empty_army = false;
							}
						}
						for (var i = 0; i < config.aeroplanes.length; i++) {
							if (armies[army_exists[1]][config.aeroplanes[i]] > 0) {
								military_string.push("<:aeroplanes:716821195407884358> **" + config.aeroplanes[i] + "**: " + armies[army_exists[1]][config.aeroplanes[i]]);
								empty_army = false;
							}
						}
						for (var i = 0; i < config.naval_units.length; i++) {
							if (armies[army_exists[1]][config.naval_units[i]] > 0) {
								military_string.push("<:naval_units:716821195277729832> **" + config.naval_units[i] + "**: " + armies[army_exists[1]][config.naval_units[i]]);
								empty_army = false;
							}
						}
						for (var i = 0; i < config.colonists.length; i++) {
							if (armies[army_exists[1]][config.colonists[i]] > 0) {
								military_string.push("<:colonisation:716821194891853826> **" + config.colonists[i] + "**: " +armies[army_exists[1]][config.colonists[i]]);
								empty_army = false;
							}
						}
						
						if (empty_army == true) {
							military_string.push("_No units found._\nDo `" + bot_prefix + "transfer <number> <unit> <army name>` to transfer some over from your reserves.");
						}
						
						const embed_army = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**' + armies[army_exists[1]].name + ', ' + main.users[arg0_user].name + ':\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(military_string.join("\n"))
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'army <army name>.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
						arg1_msg.channel.send(embed_army);
					} else {
						arg1_msg.channel.send("The army you have specified is nonexistent!");
					}
				} else {
					arg1_msg.channel.send("You don't even have a nation!");
				}
			}
				
			function printArmies (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var armies_string = [];
					
					armies_string.push("<:globe:716811246556545035> Country: " + main.users[arg0_user].name);
					armies_string.push("------------------ \n<:manpower:716817688705499177> **Armies:**");
					for (var i = 0; i < usr.armies.army_array.length; i++) {
						if (usr.armies[usr.armies.army_array[i]].name != "deleted-army") {
							var icon = "";
							//army, navy, air force
							if (usr.armies[usr.armies.army_array[i]].type == "army") {
								icon = "<:active_personnel:716820390474940426> ";
							} else if (usr.armies[usr.armies.army_array[i]].type == "navy") {
								icon = "<:naval_units:716821195277729832> ";
							} else if (usr.armies[usr.armies.army_array[i]].type == "air force") {
								icon = "<:aeroplanes:716821195407884358> ";
							}
							armies_string.push(" - " + icon + "**" + usr.armies[usr.armies.army_array[i]].name + "** (" + usr.armies[usr.armies.army_array[i]].state + ", Province #**" + usr.armies[usr.armies.army_array[i]].province + "**). `" + bot_prefix + "army " + usr.armies[usr.armies.army_array[i]].name + "`.");
						}
					}
					armies_string.push(" - Reserves");
					
					const embed_armies = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Army List:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(armies_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'army-list.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					arg1_msg.channel.send(embed_armies);
				} else {
					arg1_msg.channel.send("You're currently stateless!");
				}
			}
			
			function mobilise (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var user_id = main.users[arg0_user];
					
					if (user_id.mobilised_manpower[0] == 0) {
						if (user_id.enable_mobilisation || user_id.mobilise_unit == "none") {
							if (main.roundCount-main.users[arg0_user].last_mobilised > config.mobilisation_cooldown) {
								user_id.last_mobilised = main.roundCount;
								
								var manpower_mobilised = Math.ceil((user_id.workers-user_id.used_workers)*0.5);
								var mobilised_unit = user_id.mobilise_unit;
								
								user_id["military"][mobilised_unit] = user_id["military"][mobilised_unit] + manpower_mobilised;
								user_id.mobilised_manpower = [manpower_mobilised, mobilised_unit];
								user_id.used_workers = user_id.used_workers + manpower_mobilised;
								
								msg.channel.send("You mobilised **" + parseNumber(manpower_mobilised) + "** as **" + mobilised_unit + "**!");
								
							} else {
								msg.channel.send("Your people can't mobilise and demobilise instantly! Wait for **" + parseNumber(config.mobilisation_cooldown-(main.roundCount-main.users[arg0_user].last_mobilised)) + "** more turns.");
							}
						} else {
							msg.channel.send("Your people haven't even heard of such a concept yet! Research mobilisation first.");
						}
					} else {
						msg.channel.send("You're already mobilised!");
					}
				} else {
					msg.channel.send("You can't mobilise a country with zero people in it!");
				}
			}
			
			function demobilise (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var user_id = main.users[arg0_user];
					
					if (user_id.mobilised_manpower[0] > 0) {
						if (user_id.enable_mobilisation) {
							if (main.roundCount-main.users[arg0_user].last_mobilised > config.mobilisation_cooldown) {
								user_id.last_mobilised = main.roundCount;
								
								var manpower_mobilised = user_id.mobilised_manpower[0];
								var mobilised_unit = user_id.mobilised_manpower[1]
								
								user_id["military"][user_id.mobilised_manpower[1]] = user_id["military"][mobilised_unit] - user_id.mobilised_manpower[1];
								user_id.used_workers = user_id.used_workers - manpower_mobilised;
								
								if (arg1_msg != "none") {
									msg.channel.send("You demobilised **" + parseNumber(manpower_mobilised) + "** " + mobilised_unit + ".");
								}
								
								user_id.mobilised_manpower = [0, ""];
							} else {
								console.log("[Triumph & Tragedy]: Current Mobilisation Cooldown for " + user_id.name + ": " + config.mobilisation_cooldown-(main.roundCount-main.users[arg0_user].last_mobilised) + " turns.");
								if (arg1_msg != "none") {
									msg.channel.send("Your people can't mobilise and demobilise instantly! Wait for **" + parseNumber(config.mobilisation_cooldown-(main.roundCount-main.users[arg0_user].last_mobilised)) + "** more turns.");
								}
							}
						} else {
							if (arg1_msg != "none") {
								msg.channel.send("Your people haven't even heard of such a concept yet! Research mobilisation first.");
							}
						}
					} else {
						if (arg1_msg != "none") {
							msg.channel.send("You can't demobilise a country with zero people in it!");
						}
					}
				} else {
					if (arg1_msg != "none") {
						msg.channel.send("You're already mobilised!");
					}
				}
			}
			
			//WIP - Does it work?
			function airRaid (arg0_user, arg1_army, arg2_user, arg3_province, arg4_msg) {
				var msg = arg4_msg;
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					//Check if army exists
					var army_exists = false;
					for (var i = 0; i < usr.armies.army_array.length; i++) {
						if (usr.armies.army_array[i] == arg1_army) {
							army_exists = true;
						}
					}
					
					if (army_exists) {
						//Get AP/DP
						var air_fleet_ap = 0;
						var air_fleet_dp = 0;
						
						var main_unit_ap = 0;
						var largest_wing = 0;
						
						var squadron = usr.armies[arg1_army];
						
						for (var i = 0; i < config.aeroplanes.length; i++) {
							if (squadron[config.aeroplanes[i]] > 0) {
								if (squadron[config.aeroplanes[i]] > largest_wing) {
									largest_wing = squadron[config.aeroplanes[i]];
									main_unit_ap = config.unit_stats[config.aeroplanes[i]].ap;
								}
								if (config.unit_stats[config.aeroplanes[i]].can_bomb_cities != false) {
									air_fleet_ap = air_fleet_ap + squadron[config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].ap;
									air_fleet_dp = air_fleet_dp + squadron[config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].dp;
								}
							}
						}
						
						if (air_fleet_ap == 0 || air_fleet_dp == 0) {
							msg.channel.send("Your air fleet has no aeroplanes capable of bombing urban targets in it!");
						} else {
							var already_at_war = false;
								if (usr.at_war.length > 0) {
									for (var i = 0; i < usr.at_war.length; i++) {
										if (usr.at_war[i] == main.users[arg1_user].name) {
											already_at_war = true;
									}
								}
							}
							
							//Check if province is city
							var attacked_city = "";
							for (var i = 0; i < main.users[arg2_user].cities.city_array.length; i++) {
								if (main.users[arg2_user].cities[main.users[arg2_user].cities.city_array[i]].province == arg3_province) {
									attacked_city = main.users[arg2_user].cities.city_array[i];
								}
							}
							
							if (attacked_city != "") {
								if (already_at_war) {
									if (city_object.attacked_this_turn) {
										var city_object = main.users[arg2_user].cities[attacked_city];
										var city_buildings = [];
										
										//Check if city has buildings
										var has_buildings = false;
										for (var i = 0; i < config.buildings.length; i++) {
											if (city_object.buildings[config.buildings[i]] > 0) {
												has_buildings = true;
											}
										}
										
										if (has_buildings) {
											var destroyed_buildings = {};
											//Scramble buildings/Shuffle buildings
											for (var i = 0; i < config.buildings.length; i++) {
												if (city_object.buildings[config.buildings[i]] > 0) {
													for (var x = 0; x < city_object.buildings[config.buildings[i]]; x++) {
														city_buildings.push(config.buildings[i]);
													}
												}
											}
											var shuffled_buildings = city_buildings;
											var current_index = city_buildings.length, temporary_value, random_index;
											while (0 != current_index) {
												random_index = Math.floor(Math.random()*current_index);
												current_index -= 1;
												temporary_value = shuffled_buildings[current_index];
												shuffled_buildings[current_index] = shuffled_buildings[random_index];
												shuffled_buildings[random_index] = temporary_value;
											}
											
											//Each ack-ack gun is worth 10x the main_unit_ap
											var defender_ap = city_object.anti_aircraft*main_unit_ap*10;
											
											//Attacker rolls, each building has ((defender_ap/building_count)*100)+500 DP
											var defender_dp = ((defender_ap/city_object.building_count)*100)+500;
											var attacker_roll = randomNumber(0, air_fleet_ap); //Ouch
											
											//Deduct buildings, floored
											var deducted_buildings = Math.floor(attacker_roll/defender_dp);
											//40% destruction cap, population killed = percentage of deducted buildings
											if (city_object.building_count*0.4 <= deducted_buildings) {
												for (var i = 0; i < deducted_buildings; i++) {
													city_object.buildings[shuffled_buildings[i]]--;
													if (destroyed_buildings[shuffled_buildings[i]] != undefined) {
														destroyed_buildings[shuffled_buildings[i]]++;
													} else {
														destroyed_buildings[shuffled_buildings[i]] = 0;
													}
												}
												for (var i = 0; i < config.pops.pop_array.length; i++) {
													city_object[config.pops.pop_array[i]] = city_object[config.pops.pop_array[i]]*Math.ceil(deducted_buildings/city_object.building_count);
												}
											} else {
												//Subtract 40% of all buildings
												deducted_buildings = Math.ceil(city_object.building_count*0.4);
												for (var i = 0; i < deducted_buildings; i++) {
													city_object.buildings[shuffled_buildings[i]]--;
													if (destroyed_buildings[shuffled_buildings[i]] != undefined) {
														destroyed_buildings[shuffled_buildings[i]]++;
													} else {
														destroyed_buildings[shuffled_buildings[i]] = 0;
													}
												}
												for (var i = 0; i < config.pops.pop_array.length; i++) {
													city_object[config.pops.pop_array[i]] = city_object[config.pops.pop_array[i]]*Math.ceil(deducted_buildings/city_object.building_count);
												}
											}
											
											var output_string = [];
											var aeroplanes_lost = 0;
											for (var i = 0; i < config.buildings[i].length; i++) {
												if (destroyed_buildings[config.buildings[i]] > 0) {
													output_string.push(destroyed_buildings[config.buildings[i]] + config.buildings[i]);
												}
											}
											
											//Subtract attacker aeroplanes according to defender_ap
											for (var i = 0; i < config.aeroplanes.length; i++) {
												if (defender_ap > squadron[config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].dp) {
													aeroplanes_lost = aeroplanes_lost + squadron[config.aeroplanes[i]];
													usr.used_soldiers = usr.used_soldiers - squadron[config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].manpower_cost;
													removePops(arg0_user, squadron[config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].manpower_cost, "soldiers");
													defender_ap = defender_ap - squadron[config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].dp;
													squadron[config.aeroplanes[i]] = 0;
												} else {
													aeroplanes_lost = aeroplanes_lost - Math.floor(defender_ap/config.unit_stats[config.aeroplanes[i]].dp);
													usr.used_soldiers = usr.used_soldiers - Math.floor(defender_ap/config.unit_stats[config.aeroplanes[i]].dp)*config.unit_stats[config.aeroplanes[i]].manpower_cost;
													removePops(arg0_user, Math.floor(defender_ap/config.unit_stats[config.aeroplanes[i]].dp)*config.unit_stats[config.aeroplanes[i]].manpower_cost, "soldiers");
													defender_ap = 0;
													squadron[config.aeroplanes[i]] = squadron[config.aeroplanes[i]] - Math.floor(defender_ap/config.unit_stats[config.aeroplanes[i]].dp);
												}
											}
											
											city_object.attacked_this_turn = true;
											returnChannel(war_channel).send("<@" + arg0_user + "> raided the city of **" + city_object.name + ", " + main.users[arg2_user].name + "** with the " + squadron.name + " and destroyed " + output_string.join(", ") + " at a cost of **" + aeroplanes_lost + "** aeroplanes of their own.");
										} else {
											msg.channel.send("The city you are trying to bomb has no buildings!");
										}
									} else {
										msg.channel.send("You have already attacked this city this turn!");
									}
								} else {
									msg.channel.send("You must be in a state of hostilities with the target user in order to commence a bombing mission on them!");
								}
							} else {
								msg.channel.send("The city you have specified does not exist!");
							}
						}
					} else {
						msg.channel.send("The air fleet specified proved to be non-existent!");
					}
				} else {
					msg.channel.send("The user you have specified failed to exist!");
				}
			}
			
			function combat (arg0_user, arg1_army, arg2_user, arg3_army, arg4_province, arg5_msg) { //$combat [@def. user] [army name] [@att. user] [army name] [province]
				//Get army objects
				//returnChannel(war_channel).send("Test");
				var attacker_casualties = 0;
				var defender_casualties = 0;
				
				if (main.users[arg0_user] != undefined && main.users[arg2_user] != undefined) {
					var army1_exists = [false, 0];
					var army2_exists = [false, 0];
					
					var armies1 = main.users[arg0_user].armies;
					var armies2 = main.users[arg2_user].armies;
					
					//First Player Army
					{
						//Check if army exists - soft match
						for (var i = 0; i < armies1.army_array.length; i++) {
							if (armies1[armies1.army_array[i]].name.toLowerCase().indexOf(arg1_army.toLowerCase()) != -1) {
								army1_exists = [true, armies1.army_array[i]];
							}
						}
						
						//Check if army exists - hard match
						for (var i = 0; i < armies1.army_array.length; i++) {
							if (armies1[armies1.army_array[i]].name.toLowerCase() == arg1_army.toLowerCase()) {
								army1_exists = [true, armies1.army_array[i]];
							}
						}
					}
					
					//Second Player Army
					{
						//Check if army exists - soft match
						for (var i = 0; i < armies2.army_array.length; i++) {
							if (armies2[armies2.army_array[i]].name.toLowerCase().indexOf(arg3_army.toLowerCase()) != -1) {
								army2_exists = [true, armies2.army_array[i]];
							}
						}
						
						//Check if army exists - hard match
						for (var i = 0; i < armies2.army_array.length; i++) {
							if (armies2[armies2.army_array[i]].name.toLowerCase() == arg3_army.toLowerCase()) {
								army2_exists = [true, armies2.army_array[i]];
							}
						}
					}
					
					console.log("[Triumph & Tragedy]: Do the partcipants armies exist? [" + army1_exists + "] , [" + army2_exists + "]");
					if (army1_exists[0] && army2_exists[0]) {
						//config.units
						//config.unit_stats
						//config.combat_order
						
						if (arg4_province == "sea") {
							returnChannel(war_channel).send("**A naval battle has been initiated!");
						} else if (arg4_province == "air") {
							returnChannel(war_channel).send("**An air battle has been initiated!");
						} else {
							returnChannel(war_channel).send("**A battle for Province " + arg4_province + " has been initiated!**");
						}
						
						//Determine types of armies (land, sea, air, air_land, air_sea)
						var defender_has_air_unit = false;
						var defender_has_naval_unit = false;
						var defender_has_land_unit = false;
						
						var defender_army_type = "";
						
						var attacker_has_air_unit = false;
						var attacker_has_naval_unit = false;
						var attacker_has_land_unit = false;
						
						var attacker_army_type = "";
						
						var battle_type = "";
						
						//Defender
						for (var x = 0; x < config.units.length; x++) {
							for (var i = 0; i < config.ground_units.length; i++) {
								if (armies1[army1_exists[1]][config.ground_units[i]] > 0) {
									defender_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.ground_artillery.length; i++) {
								if (armies1[army1_exists[1]][config.ground_artillery[i]] > 0) {
									defender_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.ground_vehicles.length; i++) {
								if (armies1[army1_exists[1]][config.ground_vehicles[i]] > 0) {
									defender_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.colonists.length; i++) {
								if (armies1[army1_exists[1]][config.colonists[i]] > 0) {
									defender_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.aeroplanes.length; i++) {
								if (armies1[army1_exists[1]][config.aeroplanes[i]] > 0) {
									defender_has_air_unit = true;
								}
							}
							for (var i = 0; i < config.naval_units.length; i++) {
								if (armies1[army1_exists[1]][config.naval_units[i]] > 0) {
									defender_has_naval_unit = true;
								}
							}
						}
						
						if (defender_has_land_unit) {
							defender_army_type = "land";
						}
						if (defender_has_naval_unit) {
							defender_army_type = "sea";
						}
						if (defender_has_air_unit) {
							defender_army_type = "air";
						}
						if (defender_has_air_unit && defender_has_land_unit) {
							defender_army_type = "air_land";
						}
						if (defender_has_air_unit && defender_has_naval_unit) {
							defender_army_type = "air_sea";
						}
						
						//Attacker
						for (var x = 0; x < config.units.length; x++) {
							for (var i = 0; i < config.ground_units.length; i++) {
								if (armies2[army2_exists[1]][config.ground_units[i]] > 0) {
									attacker_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.ground_artillery.length; i++) {
								if (armies2[army2_exists[1]][config.ground_artillery[i]] > 0) {
									attacker_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.ground_vehicles.length; i++) {
								if (armies2[army2_exists[1]][config.ground_vehicles[i]] > 0) {
									attacker_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.colonists.length; i++) {
								if (armies2[army2_exists[1]][config.colonists[i]] > 0) {
									attacker_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.aeroplanes.length; i++) {
								if (armies2[army2_exists[1]][config.aeroplanes[i]] > 0) {
									attacker_has_air_unit = true;
								}
							}
							for (var i = 0; i < config.naval_units.length; i++) {
								if (armies2[army2_exists[1]][config.naval_units[i]] > 0) {
									attacker_has_naval_unit = true;
								}
							}
						}
						
						if (attacker_has_land_unit) {
							attacker_army_type = "land";
						}
						if (attacker_has_naval_unit) {
							attacker_army_type = "sea";
						}
						if (attacker_has_air_unit) {
							attacker_army_type = "air";
						}
						if (attacker_has_air_unit && attacker_has_land_unit) {
							attacker_army_type = "air_land";
						}
						if (attacker_has_air_unit && attacker_has_naval_unit) {
							attacker_army_type = "air_sea";
						}
						
						//Determine battle type: land, naval, air
						{
							if ((attacker_army_type == "land" || attacker_army_type == "air_land") && (defender_army_type == "land" || defender_army_type == "air_land")) {
								battle_type = "land";
							}
							if (attacker_army_type == "air" && (defender_army_type == "land" || defender_army_type == "air_land")) {
								battle_type = "land";
							}
							if ((attacker_army_type == "land" || attacker_army_type == "air_land") && defender_army_type == "land") {
								battle_type = "land";
							}
							
							if ((attacker_army_type == "sea" || attacker_army_type == "air_sea") && (defender_army_type == "sea" || defender_army_type == "air_sea")) {
								battle_type = "sea";
							}
							if (attacker_army_type == "air" && (defender_army_type == "sea" || defender_army_type == "air_sea")) {
								battle_type = "sea";
							}
							if ((attacker_army_type == "sea" || attacker_army_type == "air_sea") && defender_army_type == "air") {
								battle_type = "sea";
							}
							
							if (attacker_army_type == "air" && defender_army_type == "air") {
								battle_type = "air";
							}
						}
						
						setTimeout(function(){
							console.log("[Triumph & Tragedy]: A battle was initiated!");
							
							var army1_ap = 0; //Defender
							var army1_dp = 0; //Defender
							var army2_ap = 0; //Attacker
							var army2_dp = 0; //Attacker
							
							var attacker_dp = 0; //Attacker
							var defender_dp = 0; //Defender
							
							for (var i = 0; i < config.units.length; i++) {
								defender_dp = defender_dp + parseInt(armies1[army1_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp);
								attacker_dp = attacker_dp + parseInt(armies2[army2_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp);
							}
							
							var province_name = "";
							var city_exists = [false, ""];
							
							if (battle_type == "land") {
								for (var i = 0; i < main.users[arg0_user].cities.city_array.length; i++) {
									if (main.users[arg0_user]["cities"][main.users[arg0_user].cities.city_array[i]].province == arg4_province) {
										province_name = main.users[arg0_user]["cities"][main.users[arg0_user].cities.city_array[i]].name;
										city_exists = [true, main.users[arg0_user].cities.city_array[i]];
									}
								}
								
								if (city_exists[0] == false) {
									var province_prefixes = ["Hill", "Site", "Mountain", "Peak", "Valley", "Road", "Route"],
									province_name = randomElement(province_prefixes) + " " + arg4_province.toString();
								}
							} else if (battle_type == "sea") {
								var naval_names = ["Roder Bay", "Valour Strait", "Fortitude Bay", "Sedenal Sea", "Sedenal Islands", "Coast of Amsai", "Heunghoi Strait", "Gwokga Delta", "Gulf of Haerjo", "North Tereles Passage", "Tereles Ocean", "Ashima Straits", "Lampshaden Plateau", "Strait of Accalma", "Mid-Seperic Ridge", "Cape Circle", "Okoye Delta", "Sirenis Sea", "Sedes Strait", "Australic Strait", "Lines Strait", "Tetralic Gulf", "Novaenian Sea", "Noveinter Passage", "Rampan Sea", "Bercault Isthmus", "Gulf of Nocte", "Gren Isthmus", "Cape Discoir", "Seperic Ocean", "Cliffs of Runsend", "Sepention Island", "Aelfland", "Hesteric Pass", "Gulf of Hesteria", "Litlandic Shelf", "Collenham Delta", "Trommen Bay", "Intersectionalic Sea", "Karelekt", "Presteric Ocean", "Borealic Ocean", "Thoric Pillars", "Cacarra Coast", "Artisa Passage", "Gulf of Titania", "Torrentes Sea", "Australis Shelf", "Terrace Bridge", "Great Australic Sea", "Southern Ocean"];
								
								province_name = randomElement(naval_names);
							} else if (battle_type == "air") {
								province_name = main.users[arg0_user].name;
							}
							
							function calculateApDp () { //Calculate Battle Report
								var battle_display_string = [];
								
								army1_ap = 0;
								army1_dp = 0;
								army2_ap = 0;
								army2_dp = 0;
								
								//Calculate AP/DP
								
								for (var i = 0; i < config.units.length; i++) {
									army1_ap = army1_ap + parseInt(armies1[army1_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].ap);
									army1_dp = army1_dp + parseInt(armies1[army1_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp);
									army2_ap = army2_ap + parseInt(armies2[army2_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].ap);
									army2_dp = army2_dp + parseInt(armies2[army2_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp);
								}
								
								for (var i = 0; i < config.unit_categories.length; i++) {
									for (var x = 0; x < config[config.unit_categories[i]].length; x++) {
										army1_ap = army1_ap + parseInt(Math.round(armies1[army1_exists[1]][config[config.unit_categories[i]][x]]*config.unit_stats[config[config.unit_categories[i]][x]].ap*main.users[arg0_user].modifiers[config.unit_categories[i] + "_ap"]));
										army1_dp = army1_dp + parseInt(Math.round(armies1[army1_exists[1]][config[config.unit_categories[i]][x]]*config.unit_stats[config[config.unit_categories[i]][x]].dp*main.users[arg0_user].modifiers[config.unit_categories[i] + "_dp"]));
										army2_ap = army2_ap + parseInt(Math.round(armies2[army2_exists[1]][config[config.unit_categories[i]][x]]*config.unit_stats[config[config.unit_categories[i]][x]].ap*main.users[arg2_user].modifiers[config.unit_categories[i] + "_ap"]));
										army2_dp = army2_dp + parseInt(Math.round(armies2[army2_exists[1]][config[config.unit_categories[i]][x]]*config.unit_stats[config[config.unit_categories[i]][x]].dp*main.users[arg2_user].modifiers[config.unit_categories[i] + "_dp"]));
									}
								}									
								if (battle_type == "sea") {
									for (var i = 0; i < config.aeroplanes.length; i++) {
										army1_ap = army1_ap + Math.ceil(armies1[army1_exists[1]][config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].ap*0.5);
										army2_ap = army2_ap + Math.ceil(armies2[army2_exists[1]][config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].ap*0.5);
									}
								}
								
								army1_ap = Math.round(army1_ap*armies1[army1_exists[1]].ap);
								army1_dp = Math.round(army1_dp*armies1[army1_exists[1]].dp);
								army2_ap = Math.round(army2_ap*armies2[army2_exists[1]].ap);
								army2_dp = Math.round(army2_dp*armies2[army2_exists[1]].dp);
								
								//Generate Battle Text
								battle_display_string.push("**Battle of " + province_name + ":**");
								battle_display_string.push("----------------------------------------");
								battle_display_string.push("");
								//Attacker:
								battle_display_string.push("Attacker: **" + main.users[arg2_user].name + " (" + armies2[army2_exists[1]].name + "):**");
								battle_display_string.push("");
								for (var i = 0; i < config.units.length; i++) {
									if (armies2[army2_exists[1]][config.units[i]] > 0) {
										var unit_name = config.unit_stats[config.units[i]].name;
										battle_display_string.push(parseNumber(armies2[army2_exists[1]][config.units[i]]) + " " + unit_name);
									}
								}
								battle_display_string.push("");
								battle_display_string.push(parseNumber(army2_ap) + " AP  " + parseNumber(army2_dp) + " DP");
								battle_display_string.push("");
								battle_display_string.push("---");
								battle_display_string.push("");
								//Defender:
								battle_display_string.push("Defender: **" + main.users[arg0_user].name + " (" + armies1[army1_exists[1]].name + "):**");
								battle_display_string.push("");
								for (var i = 0; i < config.units.length; i++) {
									if (armies1[army1_exists[1]][config.units[i]] > 0) {
										var unit_name = config.unit_stats[config.units[i]].name;
										battle_display_string.push(parseNumber(armies1[army1_exists[1]][config.units[i]]) + " " + unit_name);
									}
								}
								battle_display_string.push("");
								battle_display_string.push(parseNumber(army1_ap) + " AP  " + parseNumber(army1_dp) + " DP");
								
								
								returnChannel(war_channel).send(battle_display_string.join("\n"));
							}
							
							function defenderAPRoll (ap_amount) {
								var current_roll = randomNumber(0, ap_amount);
								var lost_units = [];
								
								if (current_roll <= ap_amount*0.33) {
									returnChannel(war_channel).send("**" + main.users[arg0_user].name + " " + randomElement(flavour_text.light_attack) + "**");
								} else if (current_roll > ap_amount*0.33 && current_roll < ap_amount*0.66) {
									returnChannel(war_channel).send("**" + main.users[arg0_user].name + " " + randomElement(flavour_text.medium_attack) + "**");
								} else if (current_roll >= ap_amount*0.66) {
									returnChannel(war_channel).send("**" + main.users[arg0_user].name + " " + randomElement(flavour_text.heavy_attack) + "**");
								}
								
								returnChannel(war_channel).send(main.users[arg0_user].name + " rolled a **" + parseNumber(current_roll) + "**.");
								
								for (var i = 0; i < config.units.length; i++) {
									if (armies2[army2_exists[1]][config.units[i]] > 0) {
										var manoeuvre = randomNumber(0, 20);
										if (current_roll > armies2[army2_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp) {
											current_roll = current_roll - armies2[army2_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp;
											
											if (manoeuvre <= Math.round(config.unit_stats[config.units[i]].mp*armies2[army2_exists[1]].mp)) {
												//returnChannel(war_channel).send("The " + config.unit_stats[config.units[i]].name + " of the " + main.users[arg2_user].name + " " + armies2[army2_exists[1]].name + " " + randomElement(flavour_text.successful_manoeuvre));
											} else {
												var lost_population = Math.ceil(armies2[army2_exists[1]][config.units[i]]*0.5)*config.unit_stats[config.units[i]].manpower_cost;
												armies2[army2_exists[1]][config.units[i]] = Math.floor(armies2[army2_exists[1]][config.units[i]]*0.5);
												lost_units.push(parseNumber(Math.ceil(armies2[army2_exists[1]][config.units[i]]*0.5)) + " " + config.unit_stats[config.units[i]].name);
												removePops(arg2_user, lost_population, "soldiers");
												main.users[arg2_user].used_soldiers = main.users[arg2_user].used_soldiers - lost_population;
												attacker_casualties = attacker_casualties + lost_population;
											}
										} else {
											if (manoeuvre <= Math.round(config.unit_stats[config.units[i]].mp*armies2[army2_exists[1]].mp)) {
												//returnChannel(war_channel).send("The " + config.unit_stats[config.units[i]].name + " of the " + main.users[arg2_user].name + " " + armies2[army2_exists[1]].name + " " + randomElement(flavour_text.successful_manoeuvre));
											} else {
												var lost_population = Math.ceil(current_roll/config.unit_stats[config.units[i]].dp)*config.unit_stats[config.units[i]].manpower_cost;
												armies2[army2_exists[1]][config.units[i]] = armies2[army2_exists[1]][config.units[i]] - Math.ceil(current_roll/config.unit_stats[config.units[i]].dp);
												lost_units.push(parseNumber(Math.ceil(current_roll/config.unit_stats[config.units[i]].dp)) + " " + config.unit_stats[config.units[i]].name);
												removePops(arg2_user, lost_population, "soldiers");
												main.users[arg2_user].used_soldiers = main.users[arg2_user].used_soldiers - lost_population;
												attacker_casualties = attacker_casualties + lost_population;
											}
											current_roll = 0;
										}
									}
								}
								
								if (lost_units.length > 0) {
									returnChannel(war_channel).send(lost_units.join(", ") + " were lost on the attacking side.");
								}
							}
							
							function attackerAPRoll (ap_amount) {
								var current_roll = randomNumber(0, ap_amount);
								var lost_units = [];
								
								if (current_roll <= ap_amount*0.33) {
									//returnChannel(war_channel).send("**" + main.users[arg2_user].name + " " + randomElement(flavour_text.light_attack) + "**");
								} else if (current_roll > ap_amount*0.33 && current_roll < ap_amount*0.66) {
									//returnChannel(war_channel).send("**" + main.users[arg2_user].name + " " + randomElement(flavour_text.medium_attack) + "**");
								} else if (current_roll >= ap_amount*0.66) {
									//returnChannel(war_channel).send("**" + main.users[arg2_user].name + " " + randomElement(flavour_text.heavy_attack) + "**");
								}
								
								returnChannel(war_channel).send(main.users[arg2_user].name + " rolled a **" + parseNumber(current_roll) + "**.");
								
								for (var i = 0; i < config.units.length; i++) {
									if (armies1[army1_exists[1]][config.units[i]] > 0) {
										var manoeuvre = randomNumber(0, 20);
										if (current_roll > armies1[army1_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp) {
											if (manoeuvre <= Math.round(config.unit_stats[config.units[i]].mp*armies1[army1_exists[1]].mp)) {
												//returnChannel(war_channel).send("The " + config.unit_stats[config.units[i]].name + " of the " + main.users[arg0_user].name + " " + armies1[army1_exists[1]].name + " " + randomElement(flavour_text.successful_manoeuvre));
											} else {
												var lost_population = Math.ceil(armies1[army1_exists[1]][config.units[i]]*0.5)*config.unit_stats[config.units[i]].manpower_cost;
												armies1[army1_exists[1]][config.units[i]] = Math.floor(armies1[army1_exists[1]][config.units[i]]*0.5);
												lost_units.push(parseNumber(Math.ceil(armies1[army1_exists[1]][config.units[i]]*0.5)) + " " + config.unit_stats[config.units[i]].name);
												removePops(arg0_user, lost_population, "soldiers");
												main.users[arg0_user].used_soldiers = main.users[arg2_user].used_soldiers - lost_population;
												defender_casualties = defender_casualties + lost_population;
											}
											current_roll = current_roll - armies1[army1_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp;
										} else {
											if (manoeuvre <= Math.round(config.unit_stats[config.units[i]].mp*armies1[army1_exists[1]].mp)) {
												//returnChannel(war_channel).send("The " + config.unit_stats[config.units[i]].name + " of the " + main.users[arg0_user].name + " " + armies1[army1_exists[1]].name + " " + randomElement(flavour_text.successful_manoeuvre));
											} else {
												armies1[army1_exists[1]][config.units[i]] = armies1[army1_exists[1]][config.units[i]] - Math.ceil(current_roll/config.unit_stats[config.units[i]].dp);
												lost_units.push(parseNumber(Math.ceil(current_roll/config.unit_stats[config.units[i]].dp)) + " " + config.unit_stats[config.units[i]].name);
												removePops(arg0_user, lost_population, "soldiers");
												main.users[arg0_user].used_soldiers = main.users[arg2_user].used_soldiers - lost_population;
												defender_casualties = defender_casualties + lost_population;
											}
											current_roll = 0;
										}
									}
								}
								
								if (lost_units.length > 0) {
									returnChannel(war_channel).send(lost_units.join(", ") + " were lost on the defending side.");
								}
							}
							
							function attackerTurn () {
								var attacker_log = [];
								for (var i = 0; i < config.units.length; i++) {
									var initiative = randomNumber(0, 20);
									
									if (armies2[army2_exists[1]][config.units[i]] > 0) {
										console.log("[Triumph & Tragedy]: " + config.units[i] + " initiative: " + initiative);
										if (initiative <= Math.round(config.unit_stats[config.units[i]].mp*armies2[army2_exists[1]].ip)) {
											var units_ap = armies2[army2_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].ap;
											attackerAPRoll(units_ap);
										} else {
											//attacker_log.push("**The " + config.unit_stats[config.units[i]].name + " of the " + main.users[arg2_user].name + " " + armies2[army2_exists[1]].name + " " + randomElement(flavour_text.failed_initative) + "**");
										}
									}
								}
										
								returnChannel(war_channel).send(attacker_log.join("\n"));
							}
							
							function defenderTurn () {
								var defender_log = [];
								for (var i = 0; i < config.units.length; i++) {
									var initiative = randomNumber(0, 10);
									
									if (armies1[army1_exists[1]][config.units[i]] > 0) {
										console.log("[Triumph & Tragedy]: " + config.units[i] + " initiative: " + initiative);
										if (initiative <= Math.round(config.unit_stats[config.units[i]].mp*armies1[army1_exists[1]].ip)) {
											var units_ap = armies1[army1_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].ap;
											defenderAPRoll(units_ap);
										} else {
											//defender_log.push("**The " + config.unit_stats[config.units[i]].name + " of the " + main.users[arg0_user].name + " " + armies1[army1_exists[1]].name + " " + randomElement(flavour_text.failed_initative) + "**");
										}
									}
								}
										
								returnChannel(war_channel).send(defender_log.join("\n"));
							}
							
							var battleCount = 0;
							var battle_finished = false;
							var battleCount = 0;
							
							returnChannel(war_channel).startTyping();
							if (defender_dp == 0 || attacker_dp == 0) {
								returnChannel(war_channel).send("One of the armies you have specified has a combat strength of zero!");
							}
								
							calculateApDp();
							attackerTurn();
							defenderTurn();
								
							//arg0_user: defender
							//arg2_user: attacker
							main.users[arg0_user].war_exhaustion = main.users[arg0_user].war_exhaustion + (defender_casualties/main.users[arg0_user].used_soldiers).toFixed(3);
							main.users[arg1_user].war_exhaustion = main.users[arg1_user].war_exhaustion + (attacker_casualties/main.users[arg0_user].used_soldiers).toFixed(3);
							
							returnChannel(war_channel).send("The defending side gained **" + (defender_casualties/main.users[arg0_user].used_soldiers).toFixed(3) + "%** war exhaustion, whilst the attacking side gained **" + (attacker_casualties/main.users[arg0_user].used_soldiers).toFixed(3) + "% war exhaustion.");
								
							if (army1_dp < defender_dp*0.5) {
								returnChannel(war_channel).send("**" + main.users[arg0_user].name + " " + randomElement(config.defender_lost) + "**");
								//Start retreating
								if (battle_type == "land") {
									armies1[army1_exists[1]].moving_to = armies1[army1_exists[1]].moving_to + randomNumber(-1, 1);
								} else if (battle_type == "sea") {
									armies1[army1_exists[1]].blockade_recovery_turns = 4;
									var all_blockades = Object.keys(main.users.global.blockades);
									
									for (var i = 0; i < all_blockades.length; i++) {
										for (var x = 0; x < main.users.global.blockades[all_blockades[i]].length; x++) {
											if (main.users.global.blockades[all_blockades[i]][x] == army1_exists[1]) {
												main.users.global.blockades[all_blockades[i]].splice(x, 1);
												main.users.global.blockade_arrays[all_blockades[i]].splice(x, 1);
											}
										}
									}
								}
							} else if (army2_dp < attacker_dp*0.5) {
								returnChannel(war_channel).send("**" + main.users[arg0_user].name + " " + randomElement(config.attacker_lost) + "**");
								//Start retreating
								if (battle_type == "land") {
									armies2[army2_exists[1]].moving_to = armies2[army2_exists[1]].moving_to + randomNumber(-1, 1);
									main.users.global.occupations.push([arg4_province, city_exists[1], arg0_user, arg2_user]);
									transferProvince(arg0_user, city_exists[1], arg2_user, arg5_msg);
									displaySVG(returnChannel(map_channel));
								}
							}
						},5000);
					} else {
						if (arg5_msg != "none") {
							arg5_msg.channel.send("One of the players you have specified did not have an army of that name!");
						}
					}
				} else {
					if (arg5_msg != "none") {
						arg5_msg.channel.send("One of the users you have specified turned out to be stateless!");
					}
				}
			}
		}
		
		//City commands
		{
			function newCity (arg0_user, arg1_name, arg2_type, arg3_message, arg4_province) {
				//Initialisation variables
				var user = main.users[arg0_user];
				var cities = user["cities"];
				var city_name = arg1_name;
				var type = arg2_type;
				var msg = arg3_message;

				var city_exists = false;

				for (var i = 0; i < cities.city_array.length; i++) {
					if (cities.city_array[i] == city_name) {
						city_exists = true;
					}
				}

				if (city_exists) {
					msg.channel.send("This city already exists!");
				} else {
					if (user["inventory"].wood >= 10 && user["inventory"].stone >= 15 && user.money >= 25000) {
						var valid_province = false;
						if (arg4_province.match(/[a-zA-Z]/)) {
							msg.channel.send("The province ID you have specified is invalid!");
						} else {
							for (var i = 0; i < user.cities.province_array.length; i++) {
								if (arg4_province == user.cities.province_array[i]) {
									valid_province = true;
								}
							}
							for (var i = 0; i < user.cities.city_array.length; i++) {
								if (user.cities[user.cities.city_array[i]].province == arg4_province) {
									valid_province = false;
								}
							}
							if (valid_province) {
								if (user.city_count < user.city_cap) {
									if (type == "capital") {
										cities[city_name] = {};

										cities[city_name].name = city_name;
										cities[city_name].population = randomNumber(250000,1000000);
										cities[city_name].resource = randomElement(config.raw_resources);
										cities[city_name].type = "capital";
										msg.channel.send("Capital city founded as **" + city_name + "** in Province **" + arg4_province + "**! Over **" + parseNumber(cities[city_name].population) + "** people are now legally residents of the capital city of **" + user.name + "**.");

										cities.city_array.push(city_name);
									} else {
										cities[city_name] = {};

										cities[city_name].name = city_name;
										cities[city_name].type = "city";
										cities[city_name].population = randomNumber(250000,800000);
										msg.channel.send("A new city was founded as **" + city_name + "**! Over **" + parseNumber(cities[city_name].population) + "** are now legally residents of the city of **" + city_name + "** in Province **" + arg4_province + "**.");

										cities.city_array.push(city_name);
									}
									
									//Cities
									cities[city_name].resource = randomElement(config.raw_resources);
									cities[city_name].buildings = {};
									cities[city_name].building_cap = 5 + Math.ceil(cities[city_name].population/200000) + Math.ceil(10*(user.provinces/user.city_count));
									cities[city_name].building_count = 0;
									cities[city_name].province = arg4_province;
									
									//Air raid modifiers
									cities[city_name].attacked_this_turn = false;
									cities[city_name].anti_aircraft = 0;
									
									user.population = user.population + cities[city_name].population;
									
									//Set building variables
									for (var i = 0; i < config.buildings.length; i++) {
										cities[city_name]["buildings"][config.buildings[i]] = 0;
									}
									
									//Population
									var remaining_population = cities[city_name].population;
									user.pops.pop_array.push(arg4_province);
									user.pops[arg4_province] = {};
									
									for (var i = 0; i < config.pop_array.length; i++) {
										if (config.pops[config.pop_array[i]].specialised_pop) {
											console.log("[Triumph & Tragedy]: Generating " + config.pop_array[i] + " for " + city_name + "...");
											
											var randomPercentage = randomNumber((config.pops[config.pop_array[i]].chance*100)/2, (config.pops[config.pop_array[i]].chance*100)*2);
											console.log(randomPercentage + "% - " + Math.ceil(remaining_population*(randomPercentage/100)) + " Pops");
											
											user.pops[arg4_province][config.pop_array[i]] = Math.ceil(remaining_population*(randomPercentage/100));
											remaining_population = remaining_population - Math.ceil(remaining_population*(randomPercentage/100));
										}
									}
									user.pops[arg4_province]["workers"] = remaining_population;
									user.pops[arg4_province]["population"] = cities[city_name].population;
									
									//Culture and political concern
									user.pops[arg4_province]["culture"] = user.culture;
									user.pops[arg4_province]["political_concern"] = {};
									
									console.log("[Triumph & Tragedy]: The remaining population (" + remaining_population + "), were generated as workers.");
									
									console.log("[Triumph & Tragedy]: RGO Modifier: " + config.rgo_modifier);
									console.log("[Triumph & Tragedy]: City Resource generated as: " + cities[city_name].resource);
									user.modifiers[cities[city_name].resource] = user.modifiers[cities[city_name].resource] + config.rgo_modifier;
									
									user["inventory"].wood = user["inventory"].wood - 10;
									user["inventory"].stone = user["inventory"].stone - 15;
									user.money = user.money - 25000;
									
									//City modifiers act as a nerf
									if (user.city_count < user.random_drop) {
										user.deduction = user.deduction*randomNumber(1.35, 1.45);
									} else {
										user.deduction = user.deduction*randomNumber(0.7, 0.75);
									}
									
									user.modifiers.production_efficiency = user.modifiers.production_efficiency - user.city_production_modifier;
									user.modifiers.research_efficiency = user.modifiers.research_efficiency - user.city_research_modifier;
									user.stability = user.stability - user.city_stability_modifier;
									
									user.city_production_modifier = Math.round(100*(user.city_production_modifier - user.deduction))/100;
									user.city_research_modifier = Math.round(100*(user.city_research_modifier - user.deduction))/100;
									user.city_stability_modifier = Math.round(100*(user.city_stability_modifier - user.deduction))/100;
									
									user.city_production_modifier = Math.round(100*user.city_production_modifier)/100;
									user.city_research_modifier = Math.round(100*user.city_research_modifier)/100;
									user.city_stability_modifier = Math.round(100*user.city_stability_modifier)/100;
									
									user.modifiers.production_efficiency = user.modifiers.production_efficiency + user.city_production_modifier;
									user.modifiers.research_efficiency = user.modifiers.research_efficiency + user.city_research_modifier;
									user.stability = user.stability + user.city_stability_modifier;
									
									user.city_count++;
									
									if (cities[city_name].type == "capital") {
										nextTurn(arg0_user);
									}
								} else {
									msg.channel.send("You do not have any land available on which to found a city!");
								}
							} else {
								msg.channel.send("You have specified a province you do not own!");
							}
						}
					} else {
						msg.channel.send("You don't have enough resources to found a city! Gather the following resources first:\n - 10 Wood\n - 15 Stone\n - 25.000");
					}
				}
			}
			
			function renameCity (arg0_user, arg1_msg, arg2_old_name, arg3_new_name) {
				var msg = arg1_msg;
				
				if (arg3_new_name.length <= 100) {
					if (main.users[arg0_user] != undefined) {
						var city_exists = false;
						
						for (var i = 0; i < main.users[arg0_user].cities.city_array.length; i++) {
							if (main.users[arg0_user]["cities"][main.users[arg0_user].cities.city_array[i]].name.toLowerCase().indexOf(arg2_old_name.toLowerCase()) != -1) {
								var old_name = main.users[arg0_user]["cities"][main.users[arg0_user].cities.city_array[i]].name;
								main.users[arg0_user]["cities"][main.users[arg0_user].cities.city_array[i]].name = arg3_new_name;
								city_exists = true;
								msg.channel.send("You have renamed **" + old_name + "** to **" + arg3_new_name + "**!");
							}
						}

						if (city_exists == false) {
							msg.channel.send("The city that you have specified doesn't exist!");
						}
					} else {
						msg.channel.send("You don't even have a nation to begin with!");
					}
				} else {
					msg.channel.send("Your city name exceeded the maximum character limit of 100 characters!");
				}
			}
			
			function printCities (arg0_user, arg1_msg) {
				var cities_string = [];
				var cities = main.users[arg0_user].cities;

				cities_string.push(":map: Country: **" + main.users[arg0_user].name + "**");
				cities_string.push("------------------ \n**Cities:**\n");
				//Print Capital City
				for (var i = 0; i < cities.city_array.length; i++) {
					if (cities[cities.city_array[i]].type == "capital") {
						cities_string.push("**" + cities[cities.city_array[i]].name + "** - Capital City");
						cities_string.push(" - Province: " + cities[cities.city_array[i]].province);
						cities_string.push(" - Population: " + parseNumber(cities[cities.city_array[i]].population));
						cities_string.push(" - RGO: " + cities[cities.city_array[i]].resource);
						cities_string.push(" - Building Cap: (" + cities[cities.city_array[i]].building_count + "/" + cities[cities.city_array[i]].building_cap + ")");
					}
				}

				//Print Capital City
				for (var i = 0; i < cities.city_array.length; i++) {
					if (cities[cities.city_array[i]].type == "city") {
						cities_string.push("**" + cities[cities.city_array[i]].name + "**:");
						cities_string.push(" - Province: " + cities[cities.city_array[i]].province);
						cities_string.push(" - Population: " + parseNumber(cities[cities.city_array[i]].population));
						cities_string.push(" - RGO: " + cities[cities.city_array[i]].resource);
						cities_string.push(" - Building Cap: (" + cities[cities.city_array[i]].building_count + "/" + cities[cities.city_array[i]].building_cap + ")");
					}
				}
				
				const embed_cities = new Discord.MessageEmbed()
					.setColor('#a98ac7')
					.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
					.setTitle('**City Overview:\n------------------**')
					.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
					.setDescription(cities_string.join("\n"))
					.setTimestamp()
					.setFooter('To access this menu again, type ' + bot_prefix + 'city-list.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
				arg1_msg.channel.send(embed_cities);
			}
			
			function printCity (arg0_user, arg1_city, arg2_msg) {
				var cities_string = [];
				var cities = main.users[arg0_user].cities;

				console.log("[Triumph & Tragedy]: City fetch request generated for: " + arg1_city);

				var city_exists = false;
				var city_name = "";
				
				//Soft Match
				for (var i = 0; i < cities.city_array.length; i++) {
					if (cities[cities.city_array[i]].name.indexOf(arg1_city)) {
						city_exists = true;
						city_name = cities.city_array[i];
					}
				}
				//Hard match
				for (var i = 0; i < cities.city_array.length; i++) {
					if (cities[cities.city_array[i]].name == arg1_city) {
						city_exists = true;
						city_name = cities.city_array[i];
					}
				}

				if (city_exists) {
					cities_string.push(":map: Country: **" + main.users[arg0_user].name + "**");
					cities_string.push("------------------ \n**" + cities[city_name].name + ":**\n");
					cities_string.push("**Province: **" + parseNumber(cities[city_name].province));
					cities_string.push("**Population: **" + parseNumber(cities[city_name].population));
					cities_string.push("**RGO: **" + cities[city_name].resource);
					cities_string.push("**Buildings: **");
					for (var i = 0; i < config.buildings.length; i++) {
						if (cities[city_name]["buildings"][config.buildings[i]] > 0) {
							cities_string.push(" - " + config.buildings[i] + ": (" + cities[city_name]["buildings"][config.buildings[i]] + "/" + main.users[arg0_user].modifiers[config.buildings[i]] + ")");
						}
					}
					if (cities[city_name].building_count == 0) {
						cities_string.push(" - _No buildings in this city were found._");
					}
					cities_string.push("**Building Cap: **(" + cities[city_name].building_count + "/" + cities[city_name].building_cap + ")");
				} else {
					cities_string.push("This city does not exist!");
				}
				
				const embed_city = new Discord.MessageEmbed()
					.setColor('#a98ac7')
					.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
					.setTitle('**City Overview for ' + cities[city_name].name + ':\n------------------**')
					.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
					.setDescription(cities_string.join("\n"))
					.setTimestamp()
					.setFooter('To access this menu again, type ' + bot_prefix + 'city ' + cities[city_name].name + '.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
				arg2_msg.channel.send(embed_city);
			}
			
			function moveCapital (arg0_user, arg1_city, arg2_msg) {
				var cities_string = [];
				var cities = main.users[arg0_user].cities;

				console.log("[Triumph & Tragedy]: User is trying to move capital to: " + arg1_city + "!");

				var city_exists = false;
				var city_name = "";
				
				//Soft Match
				for (var i = 0; i < cities.city_array.length; i++) {
					if (cities[cities.city_array[i]].name.indexOf(arg1_city)) {
						city_exists = true;
						city_name = cities.city_array[i];
					}
				}
				
				//Hard match
				for (var i = 0; i < cities.city_array.length; i++) {
					if (cities[cities.city_array[i]].name == arg1_city) {
						city_exists = true;
						city_name = cities.city_array[i];
					}
				}

				if (city_exists) {
					if (cities[city_name].type == "capital") {
						arg2_msg.channel.send("The city you have specified is already your capital city!");
					} else {
						if (user_id.political_capital >= config.move_capital_cost) {
							//Get rid of old capital
							for (var i = 0; i < cities.city_array.length; i++) {
								if (cities[cities.city_array[i]].type == "capital") {
									cities[cities.city_array[i]].type = "city";
								}
							}
							//Set new capital
							cities[city_name].type = "capital";
							main.users[arg0_user].capital_id = parseInt(cities[city_name].province);
						} else {
							arg2_msg.channel.send("You don't have enough <:political_capital:716817688525275257> Political Capital to move your capital city! You need **" + (config.move_capital_cost-user_id.political_capital) + "** more.");
						}
					}
				} else {
					cities_string.push("This city does not exist!");
				}
				
				arg2_msg.channel.send("You have changed your capital city to **" + cities[city_name].name + "** for **150** <:political_capital:716817688525275257> Political Capital.");
			}
			
			function transferProvince (arg0_user, arg1_id, arg2_user, arg3_message) { //$transfer-province [@original user] [@user] <id> 
				var msg = arg3_message;
				
				if (main.users[arg0_user] != undefined && main.users[arg2_user] != undefined) {
					if (arg0_user != arg2_user) {
						var cities1 = main.users[arg0_user].cities;
						var cities2 = main.users[arg2_user].cities;
						
						var city_exists = [false, undefined];
						
						for (var i = 0; i < cities1.city_array.length; i++) {
							console.log("[Triumph & Tragedy]: City Array of " + arg0_user + ": " + cities1.city_array);
							console.log(cities1[cities1.city_array[i]].province);
							if (cities1[cities1.city_array[i]].province.toString() == arg1_id.toString()) {
								city_exists = [true, cities1.city_array[i]];
							}
						}
						
						console.log("[Triumph & Tragedy]: Province ID specified: " + arg1_id);
						
						if (city_exists[0]) {
							console.log("[Triumph & Tragedy]: City Debug Name: " + city_exists[1]);
							var city_name = cities1[city_exists[1]].name;
							var city_population = cities1[city_exists[1]].population;
							var city_resource = cities1[city_exists[1]].resource;
							
							main.users[arg0_user]["modifiers"][city_resource] = main.users[arg0_user]["modifiers"][city_resource] - config.rgo_modifier;
							main.users[arg2_user]["modifiers"][city_resource] = main.users[arg2_user]["modifiers"][city_resource] + config.rgo_modifier;
							
							main.users[arg0_user].population = main.users[arg0_user].population - city_population;
							main.users[arg2_user].population = main.users[arg2_user].population + city_population;
							
							main.users[arg2_user].city_count++;
							main.users[arg0_user].city_count--;
							
							main.users[arg2_user].provinces++;
							main.users[arg0_user].provinces--;
							
							main.users[arg2_user].pops[cities1[city_exists[1]].province] = main.users[arg0_user].pops[cities1[city_exists[1]].province];
							cities2[city_exists[1]] = cities1[city_exists[1]];
							cities2.city_array.push(city_exists[1]);
							
							for (var i = 0; i < main.users[arg0_user].cities.province_array.length; i++) {
								if (main.users[arg0_user].cities.province_array[i] == cities1[city_exists[1]].province) {
									main.users[arg0_user].cities.province_array.splice(i, 1);
								}
							}
							main.users[arg2_user].cities.province_array.push(cities1[city_exists[1]].province);
							main.users[arg2_user].pops.pop_array.push(cities1[city_exists[1]].province);
							
							delete main.users[arg0_user].pops[cities1[city_exists[1]].province];
							delete cities1[city_exists[1]];
							cities1.city_array.splice(city_exists[1], 1);
							console.log("[Triumph & Tragedy]: Original owner city_array: " + cities1.city_array);
							
							main.users[arg0_user].pops.pop_array = Object.keys(main.users[arg0_user].pops);
							console.log(Object.keys(main.users[arg0_user].pops));
							main.users[arg0_user].pops.pop_array.pop();
							
							if (arg3_message != "none") {
								msg.channel.send("The city of **" + city_name + "** fell into the hands of **" + main.users[arg2_user].name + "**!");
							}
						} else {
							main.users[arg2_user].provinces++;
							main.users[arg0_user].provinces--;
							
							for (var i = 0; i < main.users[arg0_user].pops.pop_array.length; i++) {
								if (main.users[arg0_user].pops.pop_array[i] == arg1_id) {
									main.users[arg0_user].pops.pop_array.splice(i, 1);
								}
							}
							
							main.users[arg2_user].pops.pop_array.push(arg1_id);
							main.users[arg2_user].pops[arg1_id] = main.users[arg0_user].pops[arg1_id];
							delete main.users[arg0_user].pops[arg1_id];
							
							if (arg3_message != "none") {
								msg.channel.send("Province **" + arg1_id + "** fell into the hands of **" + main.users[arg2_user].name + "**!");
							}
						}
					} else {
						if (arg3_message != "none") {
							msg.channel.send("You can't capture your own city!");
						}
					}
				} else {
					if (arg3_message != "none") {
						msg.channel.send("One of the users you have specified is stateless!");
					}
				}
			}
		}
		
		//Colonisation commands
		{
			function cancelColonisation (arg0_user, arg1_id, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					if (isNaN(parseInt(arg1_id)) == false) {
						if (usr.expeditions[parseInt(arg1_id)] != undefined) {
							msg.channel.send("You have removed Colonial Charter **#" + arg1_id + "** from your current colonisation efforts. Type `" + bot_prefix + "colonisation` for a more updated list of your current colonial ventures.");
							usr.expeditions.splice(parseInt(arg1_id), 1);
						} else {
							msg.channel.send("That slot was not a valid numeric ID! Type `" + bot_prefix + "colonisation` to check which colonial charters may be cancelled.");
						}
					} else {
						msg.channel.send("You must specify a valid numeric ID! Type `" + bot_prefix + "colonisation` to check which colonial charters can be cancelled.");
					}
				} else {
					msg.channel.send("You need to have a nation before you can even colonise in the first place!");
				}
			}
		}
		
		//Diplomacy commands
		{
			function ally (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (usr.political_capital >= config.form_alliance_cost) {
							//Check if ally is yourself, already an ally, or a rival
							var is_rival = false;
							for (var i = 0; i < usr.rivals.length; i++) {
								if (arg1_user == usr.rivals[i]) {
									is_rival = true;
								}
							}
							
							if (is_rival == false) {
								if (arg0_user == arg1_user) {
									msg.channel.send("You can't ally yourself!");
								} else {
									var is_pending = false;
									var already_is_ally = false;
									for (var i = 0; i < main.users[arg1_user].allies.length; i++) {
										if (main.users[arg1_user].allies[i][0] == arg0_user) {
											if (main.users[arg1_user].allies[i][1] == "accepted") {
												already_is_ally = true;
											} else if (main.users[arg1_user].allies[i][1] == "pending") {
												is_pending = true;
											}
										}
									}
									
									if (is_pending) {
										msg.channel.send("You already have an ally request pending!");
									} else {
										if (already_is_ally) {
											msg.channel.send("This country is already your ally!");
										} else {
											var relations_high_enough = false;
											
											for (var i = 0; i < usr.relations.length; i++) {
												if (usr.relations[i][1] == arg1_user) {
													if (usr.relations[i][0] >= 75) {
														relations_high_enough = true;
													}
												}
											}
											
											if (relations_high_enough) {
												if (usr.used_diplomatic_slots < usr.modifiers.starting_diplomatic_slots) {
													usr.used_diplomatic_slots++;
													usr.political_capital = usr.political_capital - config.form_alliance_cost;
													main.users.global.current_scope = arg0_user;
													main.users[arg1_user].allies.push([arg0_user, "pending"]);
													localisation.push(usr.name);
													printEvent(arg1_user, "alliance_proposal");
													msg.channel.send("<:checkmark:725550245051760671> We have sent **" + main.users[arg1_user].name + "** an alliance proposal.");
												} else {
													msg.channel.send("You do not have enough diplomatic slots to request an alliance!");
												}
											} else {
												msg.channel.send("You must at least have **+75** relations with " + main.users[arg1_user].name + " in order to propose an alliance!");
											}
										}
									}
								}
							} else {
								msg.channel.send("You can't ally a rival!");
							}
						} else {
							msg.channel.send("You don't have enough political capital to propose an alliance! You must have at least <:political_capital:716817688525275257> **" + config.form_alliance_cost + "** in order to form an alliance.");
						}
					} else {
						msg.channel.send("The person you are trying to conduct diplomatic relationships with does not exist!");
					}
				} else {
					msg.channel.send("You must have a nation in order to conduct diplomatic relations!");
				}
			}
			
			function breakAlly (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						//Check if nation is an ally
						var is_ally = false;
						for (var i = 0; i < usr.allies.length; i++) {
							if (usr.allies[i][0] == arg1_user) {
								is_ally = true;
							}
						}
						if (is_ally) {
							//Remove allied status
							for (var i = 0; i < usr.allies.length; i++) {
								if (usr.allies[i][0] == arg1_user) {
									usr.allies.splice(i, 1);
								}
							}
							for (var i = 0; i < main.users[arg1_user].length; i++) {
								if (main.users[arg1_user].allies[i][0] == arg0_user) {
									main.users[arg1_user].allies.splice(i, 1);
								}
							}
							localisation.push(usr.name);
							usr.used_diplomatic_slots--;
							main.users[arg1_user].used_diplomatic_slots--;
							printEvent(arg1_user, "alliance_broken");
							msg.channel.send("<:checkmark:725550245051760671> We have broken off our alliance with **" + main.users[arg1_user].name + "**.");
						} else {
							msg.channel.send("You already have no alliance with this person!");
						}
					} else {
						msg.channel.send("The person you are attempting to conduct diplomatic relations with does not have a country yet!");
					}
				} else {
					msg.channel.send("You must have a country in order to conduct diplomatic relations!");
				}
			}
			
			function callAlly (arg0_user, arg1_user, arg2_war, arg3_message) {
				var msg = arg3_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						var ot_user = main.users[arg1_user];
						
						var has_alliance = false;
						
						for (var i = 0; i < usr.allies.length; i++) {
							if (usr.allies[i][0] == arg1_user) {
								has_alliance = true;
							}
						}
						
						if (has_alliance) {
							var war_exists = [false, ""];
							var all_wars = Object.keys(main.users.global.wars);
							
							for (var i = 0; i < all_wars.length; i++) { //soft match first
								if (main.users.global.wars[all_wars[i]].name.toLowerCase().indexOf(arg2_war.toLowerCase()) != -1) {
									war_exists = [true, all_wars[i]];
								}
							}
							for (var i = 0; i < all_wars.length; i++) { //hard match second
								if (main.users.global.wars[all_wars[i]].name.toLowerCase() == arg2_war.toLowerCase()) {
									war_exists = [true, all_wars[i]];
								}
							}
							
							if (war_exists[0]) {
								var current_side = "";
								var current_selector = "";
								var opposing_side = "";
								var immediate_ally = false;
								
								for (var i = 0; i < all_wars[i].attackers.length; i++) {
									if (all_wars[i].attackers == arg0_user) {
										current_side = "attackers";
										opposing_side = "defenders";
										current_selector = "original_attacker";
									}
								}
								for (var i = 0; i < all_wars[i].defenders.length; i++) {
									if (all_wars[i].defenders == arg0_user) {
										current_side = "defenders";
										opposing_side = "attackers";
										current_selector = "original_target";
									}
								}
								
								var war_leader_obj = main.users[main.users.global.wars[war_exists[1]][current_selector]];
								
								if (war_leader_obj.allies.length > 0) {
									for (var i = 0; i < war_leader_obj.allies.length; i++) {
										if (war_leader_obj.allies[i][0] == ot_user.id && war_leader_obj.allies[i][1] == "accepted") {
											immediate_ally = true;
										}
									}
								}
								
								if (immediate_ally) {
									//printEvent
									localisation.push(main.users.global.wars[war_exists[1]].name);
									localisation.push(usr.name);
									main.users.global.current_scope = [war_exists[1], current_side, opposing_side, arg0_user];
									printEvent(arg1_user, "call_to_arms");
									msg.channel.send("<:checkmark:725550245051760671> You have decided to call in **" + usr.name + "** into the **" + main.users.global.wars[war_exists[1]].name + "**.");
								} else {
									msg.channel.send("You may only call in immediate allies of the war leader on your side!");
								}
							} else {
								msg.channel.send("The war you have specified does not exist! Have a USS Maine or Gulf of Tonkin incident first.");
							}
						} else {
							msg.channel.send("You do not have an active alliance with that country!");
						}
					} else {
						msg.channel.send("The user you are trying to call into your war does not have an existant nation!");
					}
				} else {
					msg.channel.send("You must found a nation first before calling in any allies into any potential wars!");
				}
			}
			
			function cancelMilitaryAccess (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (arg0_user != arg1_user) {
							var has_mil_access = false;
							var element_to_remove = 0;
							
							for (var i = 0; i < main.users[arg1_user].military_access.length; i++) {
								if (main.users[arg1_user].military_access[i] == arg0_user) {
									has_mil_access = true;
									element_to_remove = i;
								}
							}
							
							if (has_mil_access) {
								localisation.push(usr.name);
								printEvent(arg1_user, "access_cancelled");
								main.users[arg1_user].used_diplomatic_slots--;
								main.users[arg1_user].military_access.splice(element_to_remove, 1);
							} else {
								msg.channel.send("The person you have specified does not have military access through your territory!");
							}
						} else {
							msg.channel.send("You cannot cancel military access to yourself!");
						}
					} else {
						msg.channel.send("The person you are trying to cancel military access with is nonexistent!");
					}
				} else {
					msg.channel.send("You are undefined! Yes, you!");
				}
			}
			
			function cedeProvince (arg0_user, arg1_id, arg2_user, arg3_message) {
				var msg = arg3_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					if (usr.capital_id.toString() != arg1_id) {
						if (isNaN(parseInt(arg1_id)) == false) {
							var valid_province = false;
							
							for (var i = 0; i < usr.cities.province_array.length; i++) {
								if (usr.cities.province_array[i] == arg1_id) {
									valid_province = true;
								}
							}
							for (var i = 0; i < usr.pops.pop_array.length; i++) {
								if (usr.pops.pop_array[i] == arg1_id) {
									valid_province = true;
								}
							}
							
							if (valid_province) {
								if (main.users[arg2_user] != undefined) {
									transferProvince(arg0_user, arg1_id, arg2_user, "none");
									msg.channel.send("You have transferred Province **" + arg1_id + "** to <@" + arg2_user + ">.");
								} else {
									msg.channel.send("The user you are attempting to transfer your province to could not be found! Make sure that you've inputted their name correctly.");
								}
							} else {
								msg.channel.send("You must specify a province in your possession! **" + arg1_id + "** was not a valid province.");
							}
						} else {
							msg.channel.send("You must specify a valid numerical province ID! Type `" + bot_prefix + "display-map` for a map of valid provinces.");
						}
					} else {
						msg.channel.send("You can't cede your capital city!");
					}
				} else {
					msg.channel.send("You must have a nation in order to cede provinces!");
				}
			}
			
			function declareWar (arg0_user, arg1_user, arg2_cb, arg3_message) {
				var msg = arg3_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						var ot_user = main.users[arg1_user];
						var cb_exists = [false, ""];
						
						//Check if CB exists
						//Wargoal Array: [[casus_belli, nation]]
						
						//Check for soft match
						for (var i = 0; i < usr.wargoals.length; i++) {
							if (usr.wargoals[i][1] == arg1_user) {
								if (usr.wargoals[i][0].toLowerCase().indexOf(arg2_cb.toLowerCase()) != -1) {
									cb_exists = [true, usr.wargoals[i][0]];
								}
							}
						}
						
						//Check for hard match
						for (var i = 0; i < usr.wargoals.length; i++) {
							if (usr.wargoals[i][1] == arg1_user) {
								if (usr.wargoals[i][0].toLowerCase() == arg2_cb.toLowerCase()) {
									cb_exists = [true, usr.wargoals[i][0]];
								}
							}
						}
						
						if (cb_exists[0]) {
							//append to war object
							war_id = randomNumber(0, 100000000).toString();
							main.users.global.wars[war_id] = {};
							
							var suffix = "";
							if (config.casus_belli[cb_exists[1]].war_names != undefined) {
								suffix = randomElement(config.casus_belli[cb_exists[1]].war_names);
							}
							if (config.casus_belli[cb_exists[1]].war_prefix != undefined) {
								main.users.global.wars[war_id].name = config.casus_belli[cb_exists[1]].war_prefix + " " + suffix;
							} else {
								main.users.global.wars[war_id].name = usr.name + "-" + ot_user.name + " War " + suffix;
							}
							main.users.global.wars[war_id].attackers = [arg0_user];
							main.users.global.wars[war_id].defenders = [arg1_user];
							main.users.global.wars[war_id].original_attacker = arg0_user; //war leader
							main.users.global.wars[war_id].original_target = arg1_user; //war leader
							
							usr.at_war.push(ot_user.name); //Push to at war array
							ot_user.at_war.push(usr.name);
							
							main.users.global.wars[war_id].attacker_wargoals = config.casus_belli[cb_exists[1]].peace_demands;
							main.users.global.wars[war_id].defender_wargoals = ["status_quo"];
							
							main.users.global.wars[war_id].peace_offers = {}; //User peace proposals are stored here whilst being edited
							
							main.users.global.wars[war_id].attacker_warscore = 0; //100 is max warscore
							main.users.global.wars[war_id].defender_warscore = 0;
							
							main.users.global.wars[war_id].attacker_total_casualties = 0;
							main.users.global.wars[war_id].defender_total_casualties = 0;
							
							returnChannel(war_channel).send("<@" + arg0_user + "> has declared **war** on <@" + arg1_user + ">! (CB: **" + config.casus_belli[cb_exists[1]].name + "**).");
							
							//Append vassals to at war array, of both the defender and attacker - WIP
							var ending_string = "";
							if (usr.vassals.length != 0) {
								ending_string = "All of your vassals have automatically been called into the war.";
							}								
							for (var i = 0; i < usr.vassals.length; i++) { //Attacker vassals
								main.users.global.wars[war_id].attackers.push(usr.vassals[i]);
								ot_user.at_war.push(main.users[usr.vassals[i]].name);
							}
							for (var i = 0; i < ot_user.vassals.length; i++) { //Defender vassals
								main.users.global.wars[war_id].defenders.push(ot_user.vassals[i]);
								usr.at_war.push(main.users[ot_user.vassals[i]].name);
							}
							//Append new attackers/defenders to at war array for vassals
							for (var i = 0; i < usr.vassals.length; i++) {
								for (var x = 0; x < main.users.global.wars[war_id].defenders.length; x++) {
									main.users[usr.vassals[i]].at_war.push(main.users[main.users.global.wars[war_id].defenders[x]].name);
								}
							}
							for (var i = 0; i < ot_usr.vassals.length; i++) {
								for (var x = 0; x < main.users.global.wars[war_id].attackers.length; x++) {
									main.users[ot_usr.vassals[i]].at_war.push(main.users[main.users.global.wars[war_id].attackers[x]].name);
								}
							}
							
							//Check if defender has any guarantees
							for (var i = 0; i < main.user_array.length; i++) {
								for (var x = 0; x < main.users[main.user_array[i]].guarantees.length; x++) {
									if (main.users[main.user_array[i]].guarantees[x] == arg1_user) {
										localisation.push(main.users.global.wars[war_id].name);
										localisation.push(ot_user.name);
										printEvent(main.user_array[i], "the_promise_we_made");
									}
								}
							}
							
							msg.channel.send("You are now at war with **" + ot_user.name + "**. In order to call in your allies, type `" + bot_prefix + "call-ally <name>`. " + ending_string);
						} else {
							msg.channel.send("The CB you have specified was invalid!");
						}
					} else {
						msg.channel.send("The person you are trying to declare war on does not possess a country!");
					}
				} else {
					msg.channel.send("You must possess a nation in order to enter into diplomatic relations!");
				}
			}
			
			function decreaseRelations (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						//Check for political capital
						if (usr.political_capital >= config.decrease_relations_cost) {
							//[[value, player_id, [improving/decreasing/none, turns]]
							var index_array = 0;
							for (var i = 0; i < usr.relations.length; i++) {
								if (usr.relations[i][0] == arg1_user) {
									index_array = i;
								}
							}
							if (usr.relations[index_array][2][0] == "none") {
								if (usr.relations[index_array][0] <= -100) {
									msg.channel.send("You already have minimum relations with this country!");
								} else {
									usr.political_capital = usr.political_capital - config.decrease_relations_cost;
									usr.relations[index_array][2][0] = "decreasing";
									usr.relations[index_array][2][1] = 5;
								}
							} else {
								msg.channel.send("You are already " + usr.relations[index_array][2][0] + " your relations with this country!");
							}
						} else {
							msg.channel.send("You need <:political_capital:716817688525275257> **" + parseNumber(config.decrease_relations_cost-usr.political_capital) + "** more Political Capital to improve relations with " + main.users[arg1_user].name + "!");
						}
					} else {
						msg.channel.send("The person you are trying to communicate with is not a valid country!");
					}
				} else {
					msg.channel.send("You must first establish a country in order to conduct diplomatic relations!");
				}
			}
			
			function endRivalry (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						//Check if country is rival
						var is_rival = false;
						
						for (var i = 0; i < usr.rivals.length; i++) {
							if (usr.rivals[i] == arg1_user) {
								is_rival = true;
							}
						}
						
						if (is_rival) {
							//Fire remove rivalry event
							localisation.push(usr.name);
							main.users.global.current_scope = arg0_user;
							printEvent(arg1_user, "the_coming_thaw");
							msg.channel.send("<:checkmark:725550245051760671> We have begun a process of mutual reconciliation with **" + main.users[arg1_user].name + "**.");
						} else {
							msg.channel.send("Your country currently does not consider **" + main.users[arg1_user].name + "** to be a valid rival!"); 
						}
					} else {
						msg.channel.send("The person you are trying to unrival does not have a country!");
					}
				} else {
					msg.channel.send("You must have a country in order to conduct diplomatic relations!");
				}
			}
			
			function liberate (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (arg0_user != arg1_user) {
							var vassalised = false;
							
							for (var i = 0; i < usr.vassals.length; i++) {
								if (usr.vassals[i] == arg1_user) {
									vassalised = true;
								}
							}
							
							if (vassalised) {
								for (var i = 0; i < usr.vassals.length; i++) {
									if (usr.vassals[i] == arg1_user) {
										usr.vassals.splice(i, 1);
									}
								}
								usr.used_diplomatic_slots--;
								main.users[arg1_user].vassal_years = 0;
								localisation.push(usr.name);
								printEvent(arg1_user, "we_are_free");
								msg.channel.send("<:checkmark:725550245051760671> We have let our vassal, **" + main.users[arg1_user].name + "** go free.");
							} else {
								msg.channel.send("The user you have specified is not underneath your overlordship!");
							}
						} else {
							msg.channel.send("You cannot unvassalise yourself!");
						}
					} else {
						msg.channel.send("The user you have specified doesn't even exist as a nation!");
					}
				} else {
					msg.channel.send("You must have a country in order to conduct diplomatic relations!");
				}
			}
			
			function improveRelations (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						//Check for political capital
						if (usr.political_capital >= config.improve_relations_cost) {
							//[[value, player_id, [improving/decreasing/none, turns]]
							var index_array = 0;
							for (var i = 0; i < usr.relations.length; i++) {
								if (usr.relations[i][1] == arg1_user) {
									index_array = i;
								}
							}
							if (usr.relations[index_array][2][0] == "none") {
								if (usr.relations[index_array][0] >= 100) {
									msg.channel.send("You already have maximum relations with this country!");
								} else {
									usr.political_capital = usr.political_capital - config.improve_relations_cost;
									usr.relations[index_array][2][0] = "improving";
									usr.relations[index_array][2][1] = 5;
									
									msg.channel.send("You have begun to improve relations with **" + main.users[arg1_user].name + "** for <:political_capital:716817688525275257> **" + parseNumber(config.improve_relations_cost) + "** Political Capital.");
								}
							} else {
								msg.channel.send("You are already " + usr.relations[index_array][2][0] + " your relations with this country!");
							}
						} else {
							msg.channel.send("You need <:political_capital:716817688525275257> **" + parseNumber(config.improve_relations_cost-usr.political_capital) + "** more Political Capital to improve relations with " + main.users[arg1_user].name + "!");
						}
					} else {
						msg.channel.send("The person you are trying to communicate with is not a valid country!");
					}
				} else {
					msg.channel.send("You must first establish a country in order to conduct diplomatic relations!");
				}
			}
			
			function militaryAccess (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (usr.political_capital >= config.request_military_access_cost) {
							if (usr.used_diplomatic_slots < usr.modifiers.starting_diplomatic_slots) {
								if (arg0_user != arg1_user) {
									var already_has_mil_access = false;
									
									for (var i = 0; i < usr.military_access.length; i++) {
										if (usr.military_access[i] == arg1_user) {
											already_has_mil_access = true;
										}
									}
									
									if (already_has_mil_access == false) {
										usr.political_capital = usr.political_capital - config.request_military_access_cost;
										localisation.push(usr.name);
										main.users.global.current_scope = arg0_user;
										printEvent(arg1_user, "other_armies_our_soil");
										msg.channel.send("<:checkmark:725550245051760671> You have sent **" + main.users[arg1_user].name + "** a request for military access.");
									} else {
										msg.channel.send("You already have military access from **" + main.users[arg1_user].name + "**!");
									}
								} else {
									msg.channel.send("You cannot request military access from yourself!");
								}
							} else {
								msg.channel.send("You don't have enough diplomatic slots to ask for military access!");
							}
						} else {
							msg.channel.send("Not enough political capital! You need **" + parseNumber(config.request_military_access_cost-usr.political_capital) + "** more to request military access from **" + main.users[arg1_user].name + "**.");
						}
					} else {
						msg.channel.send("The user you are trying to request military access from doesn't even exist!");
					}
				} else {
					msg.channel.send("You must have a nation in order to ask for military access!");
				}
			}
			
			function nonAggressionPact (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (arg0_user != arg1_user) {
							var already_has_non_agg_pact = false;
							
							for (var i = 0; i < usr.non_aggression_pacts.length; i++) {
								if (usr.non_aggression_pacts[i][0] == arg1_user) {
									already_has_non_agg_pact = true;
								}
							}
							
							if (already_has_non_agg_pact == false) {
								if (usr.used_diplomatic_slots < usr.modifiers.starting_diplomatic_slots) {
									if (usr.political_capital >= config.sign_non_aggression_pact_cost) {
										usr.political_capital = usr.political_capital - config.sign_non_aggression_pact_cost;
										localisation.push(usr.name);
										main.users.global.current_scope = arg0_user;
										printEvent(arg1_user, "a_guaranteed_peace");
										msg.channel.send("<:checkmark:725550245051760671> You have successfully sent a request for a non-aggresison pact to **" + main.users[arg1_user].name + "**.");
									} else {
										msg.channel.send("You don't have enough Political Capital to carry out this request! You need **" + parseNumber(config.sign_non_aggression_pact_cost-usr.political_capital) + "** more Political Capital to send out a request for a non-aggression pact.");
									}
								} else {
									msg.channel.send("You don't have enough diplomatic slots available for another non-aggression pact!");
								}
							} else {
								msg.channel.send("You already have a non-aggression pact with **" + main.users[arg1_user].name + "**!");
							}
						} else {
							msg.channel.send("You can't conclude a non-aggression pact with yourself!");
						}
					} else {
						msg.channel.send("The country you are trying to conclude a non-aggression pact with does not exist!");
					}
				} else {
					msg.channel.send("You must have a nation in order to conclude non-aggression pacts with other countries!");
				}
			}
			
			function justifyWar (arg0_user, arg1_user, arg2_cb, arg3_message) {
				var msg = arg3_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (arg0_user != arg1_user) {
							if (usr.political_capital >= config.justify_wargoal_cost) {
								//Check if CB exists
								var cb_exists = false;
								var is_rival = false;
								var has_non_aggression_pact = false;
								
								for (var i = 0; i < usr.rivals.length; i++) {
									if (usr.rivals[i] == arg1_user) {
										is_rival = true;
									}
								}
								
								for (var i = 0; i < usr.non_aggression_pacts.length; i++) {
									if (usr.non_aggression_pacts[i][0] == arg1_user) {
										has_non_aggression_pact = true;
									}
								}
								
								if (config.casus_belli[arg2_cb] != undefined) {
									cb_exists = true;
								}
								
								if (cb_exists) {
									//Check if CB is valid [[CB, nation, turns]]
									//Wargoals: install_government, cut_down_to_size, liberation, puppet, retake_cores, annexation
									//Casus Belli Array: [[casus_belli, nation]]
									var valid_cb = false;
									
									for (var i = 0; i < usr.casus_belli.length; i++) {
										if (usr.casus_belli[i][0] == arg2_cb && usr.casus_belli[i][1] == arg1_user) {
											valid_cb = true;
										}
									}
									
									if (valid_cb) {
										//Begin justification process, [[CB, nation, turns]]
										if (has_non_aggression_pact) {
											msg.channel.send("You currently have a non-aggression pact with the person you're attempting to justify on!");
										} else {
											for (var i = 0; i < usr.casus_belli.length; i++) {
												if (usr.casus_belli[i] != undefined) {
													if (usr.casus_belli[i][0] == arg2_cb && usr.casus_belli[i][1] == arg1_user) {
														if (is_rival) {
															usr.justifications.push([arg2_cb, arg1_user, Math.round(config.justify_wargoal_time)/2]);
														} else {
															usr.justifications.push([arg2_cb, arg1_user, config.justify_wargoal_time]);
														}
														usr.infamy = usr.infamy + config.casus_belli[arg2_cb].infamy;
														returnChannel(war_channel).send("<@" + arg0_user + "> is justifying against <@" + arg1_user + ">! (CB: **" + config.casus_belli[usr.casus_belli[i][0]].name + "**).\nWar justification will complete in **" + config.justify_wargoal_time + "** turns.");
														usr.casus_belli.splice(i, 1);
													}
												}
											}
										}
									} else {
										msg.channel.send("The CB you have selected was either invalid or has already expired!");
									}
								} else {
									msg.channel.send("'**" + arg2_cb + "**' is not a valid CB! Please make sure you have spelled it correctly and that it is in all lowercase.");
								}
							} else {
								msg.channel.send("You don't have enough Political Capital to justify a wargoal on **" + main.users[arg1_user].name + "**! You need <:political_capital:716817688525275257> **" + parseNumber(config.justify_wargoal_cost-usr.political_capital) + "** more Political Capital in order to justify a wargoal on this nation!");
							}
						} else {
							msg.channel.send("You cannot justify a war on yourself!");
						}
					} else {
						msg.channel.send("You cannot justify a war on a nonexistent nation!");
					}
				} else {
					msg.channel.send("You must have a country in order to justify a war!");
				}
			}
			
			function parsePeace (arg0_peace_obj, arg1_war_obj) {
				var peace_obj = arg0_peace_obj;
				var war_obj = arg1_war_obj;
				var defeated_side = "";
				var winning_side = "";
				
				//Get war object from peace object
				var all_wars = Object.keys(main.users.global.wars);
				
				for (var i = 0; i < war_obj.attackers.length; i++) {
					var preserve_wars = [];
					var remove_occupations = [];
					
					for (var x = 0; x < main.users.global.occupations.length; x++) {
						var belongs_to_belligerent = false;
						//[prov_id, city, original_country, new_country]; ["0", true, "<user_id>", "<user_id>"];
						for (var y = 0; y < war_obj.attackers.length; y++) {
							if (main.users.global.occupations[x][2] == war_obj.attackers[y]) {
								transferProvince(main.users.global.occupations[x][3], main.users.global.occupations[x][0], main.users.global.occupations[x][2], "none");
								remove_occupations.push(main.users.global.occupations[x]);
							}
						}
						for (var y = 0; y < war_obj.defenders.length; y++) {
							if (main.users.global.occupations[x][2] == war_obj.defenders[y]) {
								transferProvince(main.users.global.occupations[x][3], main.users.global.occupations[x][0], main.users.global.occupations[x][2], "none");
								remove_occupations.push(main.users.global.occupations[x]);
							}
						}
					}
					
					for (var x = 0; x < remove_occupations.length; x++) {
						for (var y = 0; y < main.users.global.occupations.length; y++) {
							if (main.users.global.occupations[y] == remove_occupations[x]) {
								main.users.global.occupations.splice(y, 1);
							}
						}
					}
					
					for (var x = 0; x < main.users[war_obj.attackers[i]].at_war.length; x++) {
						for (var y = 0; y < all_wars.length; y++) {
							var in_war = [false, ""]; //[in_war, opposing_side]
							for (var z = 0; z < main.users.global.wars[all_wars[y]].attackers.length; z++) {
								if (main.users.global.wars[all_wars[y]].attackers[z] == war_obj.attackers[i]) {
									in_war = [true, "defenders"];
								}
							}
							for (var z = 0; z < main.users.global.wars[all_wars[y]].defenders.length; z++) {
								if (main.users.global.wars[all_wars[y]].defenders[z] == war_obj.attackers[i]) {
									in_war = [true, "attackers"];
								}
							}
							
							//Check if opposing side contains any co-belligerents
							if (in_war[0]) {
								for (var z = 0; z < main.users.global.wars[all_wars[y]][in_war[1]].length; z++) {
									if (main.users.global.wars[all_wars[y]][in_war[1]][z] == main.users[war_obj.attackers[i]].at_war[x]) {
										preserve_wars.push(main.users[war_obj.attackers[i]].at_war[x]);
									}
								}
							}
						}
					}
					
					for (var x = 0; x < preserve_wars.length; x++) {
						for (var y = 0; y < main.users[war_obj.attackers[i]].at_war.length; y++) {
							if (main.users[war_obj.attackers[i]].at_war[y] != preserve_wars[x]) {
								main.users[war_obj.attackers[i]].at_war.splice(y, 1);
							}
						}
					}
					
					if (war_obj.attackers[i] == peace_obj.country) {
						defeated_side = "defenders";
						winning_side = "attackers";
					}
				}
				
				//Clear at war array unless user is 
				for (var i = 0; i < war_obj.defenders.length; i++) {
					var preserve_wars = [];
					
					for (var x = 0; x < main.users[war_obj.defenders[i]].at_war.length; x++) {
						for (var y = 0; y < all_wars.length; y++) {
							var in_war = [false, ""]; //[in_war, opposing_side]
							for (var z = 0; z < main.users.global.wars[all_wars[y]].attackers.length; z++) {
								if (main.users.global.wars[all_wars[y]].attackers[z] == war_obj.defenders[i]) {
									in_war = [true, "defenders"];
								}
							}
							for (var z = 0; z < main.users.global.wars[all_wars[y]].defenders.length; z++) {
								if (main.users.global.wars[all_wars[y]].defenders[z] == war_obj.defenders[i]) {
									in_war = [true, "attackers"];
								}
							}
							
							//Check if opposing side contains any co-belligerents
							if (in_war[0]) {
								for (var z = 0; z < main.users.global.wars[all_wars[y]][in_war[1]].length; z++) {
									if (main.users.global.wars[all_wars[y]][in_war[1]][z] == main.users[war_obj.defenders[i]].at_war[x]) {
										preserve_wars.push(main.users[war_obj.defenders[i]].at_war[x]);
									}
								}
							}
						}
					}
					
					for (var x = 0; x < preserve_wars.length; x++) {
						for (var y = 0; y < main.users[war_obj.defenders[i]].at_war.length; y++) {
							if (main.users[war_obj.defenders[i]].at_war[y] == preserve_wars[x]) {
								main.users[war_obj.defenders[i]].at_war.splice(y, 1);
							}
						}
					}
					
					if (war_obj.defenders[i] == peace_obj.country) {
						defeated_side = "attackers";
						winning_side = "defenders";
					}
				}
				
				/*
					Peace Offer Data Structure
					---
					status_quo: true/false - Done
					install_government: [[nation, user_government]] - Done
					cut_down_to_size: [nation_a, nation_b, nation_c] - Done
					liberation: true/false - Done
					puppet: [[overlord, puppet]]
					retake_cores: [nation_a, nation_b, nation_c]
					annexation: [[nation, [prov1, prov2, prov3]]]
					
					transferProvince (arg0_user, arg1_id, arg2_user, arg3_msg)
				*/
				
				if (peace_obj.status_quo) {
					var all_money = 0;
					for (var i = 0; i < war_obj[defeated_side].length; i++) {
						//10% of their money to be taken as war reps to be equally distributed amongst the winning side
						all_money = all_money + main.users[war_obj[defeated_side][i]].money*0.1;
						main.users[war_obj[defeated_side][i]].money = main.users[war_obj[defeated_side][i]].money*0.9;
					}
					all_money = all_money/war_obj[winning_side].length;
					for (var i = 0; i < war_obj[winning_side].length; i++) {
						main.users[war_obj[winning_side][i]].money = main.users[war_obj[winning_side][i]].money + all_money;
					}
				}
				if (peace_obj.install_government != undefined) {
					if (peace_obj.install_government.length > 0) {
						for (var i = 0; i < peace_obj.install_government.length; i++) {
							main.users[peace_obj.install_government[i][0]].government = peace_obj.install_government[i][1];
						}
					}
				}
				if (peace_obj.cut_down_to_size != undefined) {
					if (peace_obj.cut_down_to_size.length > 0) {
						for (var i = 0; i < peace_obj[cut_down_to_size].length; i++) {
							var user_obj = main.users[peace_obj[cut_down_to_size][i]];
							
							//Demobilise first
							
							user_obj.last_mobilised = main.roundCount;
								
							var manpower_mobilised = user_obj.mobilised_manpower[0];
							var mobilised_unit = user_obj.mobilised_manpower[1];
								
							user_obj["military"][user_obj.mobilised_manpower[1]] = user_obj["military"][mobilised_unit] - user_obj.mobilised_manpower[1];
							user_obj.used_workers = user_obj.used_workers - manpower_mobilised;
								
							user_obj.mobilised_manpower = [0, ""];
							
							//Then subtract 90% of their military
							user_obj.used_soldiers = user_obj.used_soldiers - Math.ceil(user_id.used_soldiers*0.9);
					
							for (var x = 0; x < config.units.length; x++) {
								user_obj["military"][config.units[x]] = Math.ceil(user_obj["military"][config.units[x]]*0.1);
							}
							
							if (user_obj.armies.army_array.length > 0) {
								for (var x = 0; x < user_obj.armies.army_array.length; x++) {
									for (var y = 0; y < config.units.length; y++) {
										user_obj["armies"][user_obj.armies.army_array[x]][config.units[y]] = Math.ceil(user_obj.armies[user_obj.armies.army_array[x]][config.units[y]]*0.1);
									}
								}
							}
						}
					}
				}
				if (peace_obj.liberation) {
					//Search for the overlord
					for (var i = 0; i < main.user_array.length; i++) {
						for (var x = 0; x < main.users[main.user_array[i]].vassals.length; x++) {
							if (main.users[main.user_array[i]].vassals[x] == peace_obj.country) {
								main.users[main.user_array[i]].vassals.splice(x, 1);
							}
						}
					}
					main.users[peace_obj.country].vassal_years = 0;
				}
				//transferProvince (arg0_user, arg1_id, arg2_user, arg3_msg)
				if (peace_obj.retake_cores != undefined) {
					if (peace_obj.retake_cores.length > 0) { //.culture
						for (var i = 0; i < peace_obj.retake_cores.length; i++) {
							//Loop through all of the opposing side provinces in search of this culture
							for (var x = 0; x < war_obj[defeated_side].length; x++) {
								var all_pops = Object.keys(main.users[war_obj[defeated_side][x]].pops);
								
								for (var y = 0; y < all_pops.length; y++) {
									if (main.users[war_obj[defeated_side][x]].pops[all_pops[y]].culture == main.users[peace_obj.retake_cores[i]].culture) {
										transferProvince(peace_obj.retake_cores[i], all_pops[y], main.users[war_obj[defeated_side][x]], "none");
									}
								}
							}
						}
					}
				}
				if (peace_obj.annexation != undefined) {
					if (peace_obj.annexation.length > 0) {
						for (var i = 0; i < peace_obj.annexation.length; i++) {
							for (var x = 0; x < peace_obj.annexation[i][1].length; x++) {
								//Search all countries for province ID
								for (var y = 0; y < main.user_array.length; y++) {
									var all_pops = Object.keys(main.users[main.user_array[y]].pops);
									
									for (var z = 0; z < all_pops.length; z++) {
										if (all_pops[z] == peace_obj.annexation[i][1][x]) {
											transferProvince(peace_obj.annexation[i][0], all_pops[z], main.user_array[y], "none");
										}
									}
								}
							}
						}
					}
				}
				//Remove war object
				var capital_name = "";
				var all_cities = Object.keys(main.users[peace_obj.country].cities);
				for (var i = 0; i < all_cities.length; i++) {
					if (main.users[peace_obj.country].cities[all_cities[i]].province == main.users[peace_obj.country].capital_id) {
						capital_name = main.users[peace_obj.country].cities[all_cities[i]].name;
					}
				}
				if (capital_name == "") {
					capital_name = main.users[peace_obj.country].name;
				}
				for (var i = 0; i < all_wars.length; i++) {
					if (main.users.global.wars[all_wars[i]].name == war_obj.name) {
						returnChannel(war_channel).send("<:old_scroll:716828676880334881> The **Treaty of " + capital_name + "** was successfully ratified by all legal parties.");
						delete main.users.global.wars[all_wars[i]];
					}
				}
				displaySVG(returnChannel(map_channel));				
			}
			
			function peaceOffer (arg0_user, arg1_war, arg2_mode, arg3_message) {
				var msg = arg3_message;
				var mode = arg2_mode;
				//mode: [create], [delete], [edit]
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var war_exists = [false, ""];
					
					//Check if war exists - soft match
					var all_wars = Object.keys(main.users.global.wars);
					for (var i = 0; i < all_wars.length; i++) {
						if (main.users.global.wars[all_wars[i]].name.toLowerCase().indexOf(arg1_war.toLowerCase()) != -1) {
							war_exists = [true, all_wars[i]];
						}
					}
					//Check if war exists - hard match
					for (var i = 0; i < all_wars.length; i++) {
						if (main.users.global.wars[all_wars[i]].name.toLowerCase() == arg1_war.toLowerCase()) {
							war_exists = [true, all_wars[i]];
						}
					}
					
					if (war_exists[0]) {
						var war_leader_id = "";
						var war_side = "";
						//Check if user is on the defending or attacking side
						for (var i = 0; i < main.users.global.wars[war_exists[1]].defenders.length; i++) {
							if (main.users.global.wars[war_exists[1]].defenders[i] == arg0_user) {
								war_side = "defenders";
							}
						}
						for (var i = 0; i < main.users.global.wars[war_exists[1]].attackers.length; i++) {
							if (main.users.global.wars[war_exists[1]].attackers[i] == arg0_user) {
								war_side = "attackers";
							}
						}
						
						if (war_side == "defenders" || war_side == "attackers") {
							var war_obj = main.users.global.wars[war_exists[1]];
							var opp_side = "";
							if (war_side == "defenders") {
								opp_side = "attackers";
							} else if (war_side == "attackers") {
								opp_side = "defenders";
							}
							if (mode[0] == "create") {
								var peace_offer_id = randomNumber(0, 100000000).toString();
								war_obj.peace_offers[peace_offer_id] = {};
								war_obj.peace_offers[peace_offer_id].country = arg0_user; //The country that proposed the peace deal
								war_obj.peace_offers[peace_offer_id].peace_terms = {};
								
								msg.channel.send("<:checkmark:725550245051760671> You have successfully created a peace offer!\nTo edit the terms of this peace, type `" + bot_prefix + "add-wargoal " + '"' + war_obj.name + '"' + "<wargoal>` to add a wargoal, and `" + bot_prefix + "remove-wargoal " + '"' + war_obj.name + '"' + " <wargoal>` to remove one. Valid wargoals include " + war_obj[war_side + "_wargoals"] + ".\nTo clear this peace offer, and create a new one, type `" + bot_prefix + "clear-peace-treaty" + '"' + war_obj.name + '"`.');
							} else if (mode[0] == "delete") {
								var all_peace_offers = Object.keys(war_obj.peace_offers);
								var peace_offer_was_found = false;
								
								for (var i = 0; i < all_peace_offers.length; i++) {
									if (war_obj[all_peace_offers[i]].country == arg0_user) {
										peace_offer_was_found = true;
										delete war_obj[all_peace_offers[i]];
										msg.channel.send("<:checkmark:725550245051760671> You successfully cleared your peace offer for the **" + war_obj.name + "**. In order to create a new peace offer, type `" + bot_prefix + 'sign-peace-treaty "' + war_obj.name + '"`.');
									}
								}
								
								if (peace_offer_was_found == false) {
									msg.channel.send("You haven't created a peace offer for this war yet!");
								}
							} else if (mode[0] == "edit") { //[edit, add/delete, wargoal, [aims/boolean]]
								
								var all_peace_offers = Object.keys(war_obj.peace_offers);
								var peace_offer_exists = [false, ""];
								
								for (var i = 0; i < all_peace_offers.length; i++) {
									if (war_obj[all_peace_offers[i]].country == arg0_user) {
										peace_offer_exists = [true, all_peace_offers[i]];
									}
								}
								
								if (peace_offer_exists[0]) {
									var terms_obj = war_obj.peace_offers[peace_offer_exists[1]].peace_terms;
									if (mode[1] == "add") {
										var valid_wargoal = false;
										
										for (var i = 0; i < war_obj.attacker_wargoals.length; i++) {
											if (war_obj.attacker_wargoals[i] == mode[2]) {
												valid_wargoal = true;
											}
										}
										
										if (valid_wargoal) {
											if (mode[2] == "status_quo") {
												terms_obj.status_quo = true;
											} else if (mode[2] == "install_government") {
												//Check that the nation needing to install a new government is part of the opposing side
												var fatal_error = [false, ""];
												var nation_found = false;
												
												for (var i = 0; i < war_obj[opp_side].length; i++) {
													if (war_obj[opp_side][i] == returnMention(mode[3])) {
														nation_found = true;
													}
												}
												
												if (nation_found == false) {
													fatal_error = [true, "The nation you requested to change their government isn't even part of the opposing side of this conflict!"];
												}
												
												//Check if there is already a demand for this nation
												
												if (terms_obj.install_government != undefined) {
													for (var i = 0; i < terms_obj.install_government.length; i++) {
														if (terms_obj.install_government[i][0] == mode[3]) {
															fatal_error = [true, "You have already demanded that this nation change out their government as part of your peace deal!"];
														}
													}
												}
												
												if (fatal_error == false) {
													if (terms_obj.install_government == undefined) {
														terms_obj.install_government = [[mode[3], usr.government]];
													} else {
														terms_obj.install_government.push([mode[3], usr.government]); //[nation, user_government]
													}
													msg.channel.send("You requested that the country of **" + main.users[mode[3]].name + "** change its government type to " + config.governments[usr.government].name[0].toLowerCase() + ".");
												} else {
													msg.channel.send(fatal_error[1]);
												}
											} else if (mode[2] == "cut_down_to_size") {
												//Check that the nation to be contained is part of the opposing side
												var fatal_error = [false, ""];
												var nation_found = false;
												
												for (var i = 0; i < war_obj[opp_side].length; i++) {
													if (war_obj[opp_side] == returnMention(mode[3])) {
														nation_found = true;
													}
												}
												
												if (nation_found == false) {
													fatal_error = [true, "The nation you have specified was not part of the opposing side of this conflict!"];
												}
												
												//Check if this nation already needs to cut down their army size
												
												if (terms_obj.cut_down_to_size != undefined) {
													for (var i = 0; i < terms_obj.cut_down_to_size.length; i++) {
														if (terms_obj.cut_down_to_size[i] == mode[3]) {
															fatal_error = [true, "You have already demanded that this nation cut its army down to size!"];
														}
													}
												}
												
												if (fatal_error == false) {
													if (terms_obj.cut_down_to_size == undefined) {
														terms_obj.cut_down_to_size = [mode[3]];
													} else {
														terms_obj.cut_down_to_size.push(mode[3]); //[nation1, nation2, nation3]
													}
													msg.channel.send("You requested that the nations of **" + mode[3].join(", ") + "** cut their armies down to size.");
												} else {
													msg.channel.send(fatal_error[1]);
												}
											} else if (mode[2] == "liberation") {
												var is_vassal = false;
												
												//Check if user has an overlord
												for (var i = 0; i < main.user_array.length; i++) {
													for (var x = 0; x < main.users[main.user_array[i]].vassals.length; x++) {
														if (main.users[main.user_array[i]].vassals[x] == arg0_user) {
															is_vassal = true;
														}
													}
												}
												
												if (is_vassal) {
													terms_obj.liberation = true;
													msg.channel.send("You requested that you be liberated from the tyranny of your overlord.");
												} else {
													msg.channel.send("You aren't even a vassal, so why are you trying to demand your liberation?");
												}
											} else if (mode[2] == "puppet") {
												//Check that puppet is valid
												var fatal_error = [false, ""];
												
												for (var i = 0; i < war_obj[opp_side].length; i++) {
													if (war_obj[opp_side] != returnMention(mode[3][1])) {
														fatal_error = [true, "The nation you have specified was not part of the opposing side of this conflict!"];
													}
												}
												
												//Check if country already has a puppet demand on it
												if (terms_obj.puppet != undefined) {
													for (var i = 0; i < terms_obj.puppet.length; i++) {
														if (terms_obj.puppet[i][1] == mode[3][1]) {
															fatal_error = [true, "You have already demanded this nation to be made the puppet of another user or yourself!"];
														}
													}
												}
												
												if (fatal_error == false) {
													if (terms_obj.puppet == undefined) {
														terms_obj.puppet = [mode[3]]; //[overlord, puppet]
													} else {
														terms_obj.puppet.push(mode[3]);
													}
													msg.channel.send("You requested that the nation of **" + main.users[mode[3][1]].name + "** should become a protectorate of the country of " + main.users[mode[3][0]].name + ".");
												} else {
													msg.channel.send(fatal_error[1]);
												}
											} else if (mode[2] == "retake_cores") {
												terms_obj.retake_cores = mode[3]; //Array of all nations that regain all their core territory
												msg.channel.send("You requested that the nations of **" + mode[3].join(", ") + "** receive their core territories back from the defenders.");
											} else if (mode[2] == "annexation") {
												//Check that all provs are valid
												var fatal_error = [false, ""];											
												for (var i = 0; i < mode[3][1].length; i++) {
													var province_found = false;
													for (var x = 0; x < war_obj[opp_side].length; x++) {
														for (var y = 0; y < main.users[war_obj[opp_side][x]].pops.length; y++) {
															if (main.users[war_obj[opp_side][x]].pops[y] == mode[3][1][i]) {
																province_found = true;
															}
														}
													}
													if (province_found == false) {
														fatal_error = [true, "Province **" + mode[3][1][i] + "** is not a valid province as it does not belong to a nation of the opposing side!"];
													}
												}
												
												//If a peace demand already exists for this nation, simply override it
												for (var i = 0; i < mode[3][1].length; i++) {
													for (var x = 0; x < terms_obj.annexation.length; x++) {
														for (var y = 0; y < terms_obj.annexation[x][1].length; y++) {
															if (terms_obj.annexation[x][1][y] == mode[3][1][i]) {
																terms_obj.annexation[x][1] = mode[3][1];
															}
														}
													}
												}
												
												if (fatal_error == false) {
													if (terms_obj.annexation == undefined) {
														terms_obj.annexation = [mode[3]]; //[[nation, [prov_1, prov_2, prov_3]]
													} else {
														terms_obj.annexation.push(mode[3]);
													}
													msg.channel.send("You added an annexation request for the provinces of " + mode[3][1].join(", ") + " on behalf of the nation of **" + main.users[mode[3][0]].name + "**.");
												} else {
													msg.channel.send(fatal_error[1]);
												}
											} else {
												msg.channel.send("how.");
											}
										} else {
											msg.channel.send("You can't add invalid wargoals to a peace offer!");
										}
									} else if (mode[1] == "remove") {
										if (terms_obj[mode[2]] != undefined) {
											if (mode[2] == "status_quo") {
												delete terms_obj.status_quo;
											} else if (mode[2] == "install_government") { //removes entry for corresponding country only
												for (var i = 0; i < terms_obj.install_government.length; i++) {
													if (terms_obj.install_government[i][0] == mode[3]) {
														terms_obj.install_government.splice(i, 1);
													}
												}
												msg.channel.send("You removed the demand for **" + main.users[mode[3]].name + "** to change its government type.");
											} else if (mode[2] == "cut_down_to_size") { //removes entry for corresponding country only
												for (var i = 0; i < terms_obj.cut_down_to_size.length; i++) {
													if (terms_obj.cut_down_to_size[i] == mode[3]) {
														terms_obj.cut_down_to_size.splice(i, 1);
													}
												}
												msg.channel.send("You removed the demand for **" + main.users[mode[3]].name + "** to cut its army down to size.");
											} else if (mode[2] == "liberation") {
												delete terms_obj.liberation;
												msg.channel.send("You removed the demand for you to be liberated from your own overlord.");
											} else if (mode[2] == "puppet") { //removes entry for corresponding country only
												for (var i = 0; i < terms_obj.puppet.length; i++) {
													if (terms_obj.puppet[i][1] == mode[3]) {
														terms_obj.puppet.splice(i, 1);
													}
												}
												msg.channel.send("You removed the demand for **" + main.users[mode[3]].name + "** to become a puppet.");
											} else if (mode[2] == "retake_cores") { //removes all entries for demand
												delete terms_obj.retake_cores;
												msg.channel.send("You removed the demand for allied countries as well as yourself to regain any cores the opposing side holds.");
											} else if (mode[2] == "annexation") { //removes all entries for corresponding country
												var provinces_to_annex = 0;
												for (var i = 0; i < terms_obj.annexation.length; i++) {
													if (terms_obj.annexation[i][0] == mode[3]) {
														provinces_to_annex = terms_obj.annexation[i][1].length;
														terms_obj.annexation.splice(i, 1);
													}
												}
												msg.channel.send("You removed the demand for **" + main.users[mode[3]].name + "** to annex **" + provinces_to_annex + "** provinces.");
											} else {
												msg.channel.send("You have specified an invalid wargoal!");
											}
										} else {
											msg.channel.send("You have already cleared your wargoals in this category!");
										}
									}
								} else {
									msg.channel.send("You need to create a peace offer before you can edit anything on it!");
								}
							}
						} else {
							msg.channel.send("You need to be involved in this conflict in order to send a peace offer!");
						}
					} else {
						msg.channel.send("The war you have specified does not exist!");
					}
				} else {
					msg.channel.send("You must have a nation before creating any peace offers!");
				}
			}
			
			function printCBs (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				var casus_belli_string_array = [];
				
				if (main.users[arg0_user] != undefined) {
					if (main.users[arg1_user] != undefined) {
						var usr = main.users[arg0_user];
						if (usr.casus_belli.length > 0) {
							for (var i = 0; i < usr.casus_belli.length; i++) {
								if (usr.casus_belli[i][1] == arg1_user) {
									casus_belli_string_array.push("`" + usr.casus_belli[i][0] + "`.");
								}
							}
						}
						if (casus_belli_string_array.length == 0) {
							casus_belli_string_array.push("_You have no valid CBs as of yet on this nation._");
						}
						
						const embed_event = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Viewing Valid CB List for ' + main.users[arg1_user].name + '**\n------------------')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(casus_belli_string_array.join("\n"))
							.setTimestamp();
							
						msg.channel.send(embed_event);
					} else {
						msg.channel.send("You must specify a valid user in order to view your CBs for that person!");
					}
				} else {
					msg.channel.send("You must have a nation in order to attempt justifying wars on other people!");
				}
			}
			
			function proclaimGuarantee (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (usr.used_diplomatic_slots < usr.modifiers.starting_diplomatic_slots) {
							if (arg0_user != arg1_user) {
								if (usr.political_capital >= config.guarantee_independence_cost) {
									var already_guaranteed = false;
									var is_rival = false;
									
									for (var i = 0; i < usr.guarantees.length; i++) {
										if (usr.guarantees[i] == arg1_user) {
											already_guaranteed = true;
										}
									}
									
									for (var i = 0; i < usr.rivals.length; i++) {
										if (usr.rivals[i] == arg1_user) {
											is_rival = true;
										}
									}
									
									if (already_guaranteed) {
										msg.channel.send("**" + main.users[arg1_user].name + "** is already guaranteed by you.");
									} else if (is_rival) {
										msg.channel.send("You can't guarantee the independence of a rival country! Unrival them first.");
									} else {
										usr.political_capital = usr.political_capital - config.guarantee_independence_cost;
										localisation.push(usr.name);
										usr.guarantees.push(arg1_user);
										main.users.global.current_scope = arg0_user;
										usr.used_diplomatic_slots++;
										printEvent(arg1_user, "a_guarantee_for_our_nation");
										msg.channel.send("<:checkmark:725550245051760671> We have guaranteed the independence of **" + main.users[arg1_user].name + "**! Only good can result from this ...");
									}
								} else {
									msg.channel.send("You don't have enough political power remaining to guarantee the independence of **" + main.users[arg1_user].name + "**! You need <:political_capital:716817688525275257> **" + parseNumber(config.guarantee_independence_cost-usr.political_capital) + "** more Political Capital to carry out this action.");
								}
							} else {
								msg.channel.send("You can't guarantee yourself!");
							}
						} else {
							msg.channel.send("You don't have enough diplomatic slots remaining to guarantee a nation!");
						}
					} else {
						msg.channel.send("The user you are trying to guarantee is nonexistent!");
					}
				} else {
					msg.channel.send("You must possess a nation in order to conduct diplomatic affairs!");
				}
			}
			
			function revokeGuarantee (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						var guarantee_exists = false;
						for (var i = 0; i < usr.guarantees.length; i++) {
							if (usr.guarantees[i] == arg1_user) {
								guarantee_exists = true;
							}
						}
						
						if (guarantee_exists) {
							for (var i = 0; i < usr.guarantees.length; i++) {
								if (usr.guarantees[i] == arg1_user) {
									usr.guarantees.splice(i, 1);
								}
							}
							usr.used_diplomatic_slots--;
							printEvent(arg1_user, "guarantee_broken");
							localisation.push(usr.name);
							msg.channel.send("<:checkmark:725550245051760671> We have broken off our guarantee with **" + main.users[arg1_user].name + "**.");
						} else {
							if (arg0_user == arg1_user) {
								msg.channel.send("We already guarantee our own independence!");
							} else {
								msg.channel.send("We do not have an existing guarantee **" + main.users[arg1_user].name + "**!");
							}
						}
					} else {
						msg.channel.send("The person you are attempting to break off relations with does not have a nation!");
					}
				} else {
					msg.channel.send("You must have a nation in order to conduct diplomatic relations!");
				}
			}
			
			function rival (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						var is_ally = false;
						var is_rival = false;
						
						for (var i = 0; i < usr.rivals.length; i++) {
							if (usr.rivals[i] == arg1_user) {
								is_rival = true;
							}
						}
						for (var i = 0; i < main.users[arg1_user].allies.length; i++) {
							if (main.users[arg1_user].allies[i][0] == arg0_user) {
								is_ally = true;
							}
						}
						
						if (is_rival) {
							msg.channel.send("You have already rivaled this nation!");
						} else {
							if (is_ally) {
								msg.channel.send("You are currently allies with this country!");
							} else {
								var relations_too_high = false;
								for (var i = 0; i < usr.relations.length; i++) {
									if (usr.relations[i][1] == arg1_user) {
										if (usr.relations[i][0] >= 50) {
											relations_too_high = true;
										}
									}
								}
								if (relations_too_high) {
									msg.channel.send("Current relations are too high! Relations must be at least below **+50** in order to rival a nation.");
								} else {
									if (usr.political_capital >= config.declare_rival_cost) {
										//Check for rival slots
											if (usr.rivals.length < usr.rival_slots) {
											usr.political_capital = usr.political_capital - config.declare_rival_cost;
											//Add as rivals for both countries
											usr.rivals.push(arg1_user);
											main.users[arg1_user].rivals.push(arg0_user);
											localisation.push(usr.name);
											main.users.global.current_scope = arg0_user;
											printEvent(arg1_user, "rival_declared");
										} else {
											msg.channel.send("You don't have any rival slots remaining to rival this user!");
										}
									} else {
										msg.channel.send("You don't have enough Political Capital remaining! You need at least <:political_capital:716817688525275257> **" + config.declare_rival_cost + "** to declare a rivalry!");
									}
								}
							}
						}
					} else {
						msg.channel.send("The person you are trying to conduct diplomatic relations with does not exist!");
					}
				} else {
					msg.channel.send("You must exist as a nation in order to hold diplomatic relations!");
				}
			}
			
			function sendPeaceOffer (arg0_user, arg1_war, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					//Check if user is involved in a war and has a peace deal active - WIP
					var war_exists = [false, ""];
					var all_wars = Object.keys(main.users.global.wars);
					
					//Soft match
					for (var i = 0; i < all_wars.length; i++) {
						if (main.users.global.wars[all_wars[i]].name.toLowerCase().indexOf(arg1_war.toLowerCase()) != -1) {
							war_exists = [true, all_wars[i]];
						}
					}
					
					//Hard match
					for (var i = 0; i < all_wars.length; i++) {
						if (main.users.global.wars[all_wars[i]].name.toLowerCase() == arg1_war.toLowerCase()) {
							war_exists = [true, all_wars[i]];
						}
					}
					
					if (war_exists[0]) {
						var user_involved = false;
						var user_side = "";
						var war_obj = main.users.global.wars[war_exists[1]];
						
						for (var i = 0; i < war_obj.defenders.length; i++) {
							if (war_obj.defenders[i] == arg0_user) {
								user_involved = true;
								user_side = "defenders";
							}
						}
						for (var i = 0; i < war_obj.attackers.length; i++) {
							if (war_obj.attackers[i] == arg0_user) {
								user_involved = true;
								user_side = "attackers";
							}
						}
						
						if (user_involved) {
							var peace_offer_exists = [false, ""];
							var all_peace_offers = Object.keys(war_obj.peace_offers);
							
							for (var i = 0; i < all_peace_offers.length; i++) {
								if (war_obj.peace_offers[all_peace_offers[i]].country == arg0_user) {
									peace_offer_exists = [true, all_peace_offers[i]];
								}
							}
							
							if (peace_offer_exists[0]) {
								var peace_obj = war_obj.peace_offers[peace_offer_exists[1]];
								var opposing_side = "";
								var opposing_war_leader = "";
								if (user_side == "defenders") {
									opposing_side = "attackers";
									opposing_war_leader = peace_obj.original_attacker;
								} else if (user_side == "attackers") {
									opposing_side = "defenders";
									opposing_war_leader = peace_obj.original_target;
								}
								
								//Send peace offers to war leader
								if (war_obj[opposing_side + "_warscore"] >= 100) {
									//send forced acceptance event
									main.users.global.current_scope = [war_obj.peace_offers[peace_offer_exists[1]], main.users.global.wars[war_exists[1]]];
									printEvent(opposing_war_leader, "the_national_disaster");
									msg.channel.send("<:checkmark:725550245051760671> You have successfully sent a peace offer to the enemy war leader, **" + main.users[opposing_war_leader].name + "**. They will be forced to accept its terms.");
								} else {
									//send conditional acceptance event
									localisation.push(main.users[peace_obj.country].name);
									main.users.global.current_scope = [war_obj.peace_offers[peace_offer_exists[1]], main.users.global.wars[war_exists[1]]];
									printEvent(opposing_war_leader, "an_offer_to_lay_down_arms");
									msg.channel.send("<:checkmark:725550245051760671> You have successfully sent a peace offer to the enemy war leader, **" + main.users[opposing_war_leader].name + "**.");
								}
							} else {
								msg.channel.send("You do not currently have an active peace offer available to be sent!");
							}
						} else {
							msg.channel.send("You are not currently in a conflict by this name!");
						}
					} else {
						msg.channel.send("The war you have specified is not currently active!");
					}
				} else {
					msg.channel.send("You must have a registered nation in order to send peace offers to other players!");
				}
			}
			
			function vassalise (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					if (main.users[arg1_user] != undefined) {
						if (arg0_user != arg1_user) {
							var already_vassalised = false;
							
							for (var i = 0; i < usr.vassals.length; i++) {
								if (usr.vassals[i] == arg1_user) {
									already_vassalised = true;
								}
							}
							
							if (already_vassalised == false) {
								if (usr.political_capital >= config.vassalise_cost) {
									usr.political_capital = usr.political_capital - config.vassalise_cost;
									localisation.push(usr.name);
									main.users.global.current_scope = arg0_user;
									printEvent(arg1_user, "the_option_to_submit");
									msg.channel.send("<:checkmark:725550245051760671> We have sent **" + main.users[arg1_user].name + "** a request for them to become our vassal.");
								} else {
									msg.channel.send("You don't have enough political capital to request the vassalisation of another country! You need **" + parseNumber(config.vassalise_cost-usr.political_capital) + "** more <:political_capital:716817688525275257> Political Capital in order to send this request.");
								}
							} else {
								msg.channel.send("You have already vassalised the nation of **" + main.users[arg1_user].name + "**!");
							}
						} else {
							msg.channel.send("You can't vassalise yourself!");
						}
					} else {
						msg.channel.send("The person you are trying to vassalise doesn't even have a country!");
					}
				} else {
					msg.channel.end("You must have a nation in order to attempt to vassalise anyone!");
				}
			}
			
			function viewDiplomacy (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						var ot_user = main.users[arg1_user];
						var diplomacy_view_array = [];
						
						//Push statistics
						diplomacy_view_array.push("**" + ot_user.name + "**  <@" + arg1_user + ">");
						diplomacy_view_array.push("<:political_capital:716817688525275257> Government: **" + config.governments[ot_user.government].name[0] + "**");
						diplomacy_view_array.push("<:provinces:716809229603700737> Provinces: **" + ot_user.provinces + "**");
						diplomacy_view_array.push("<:population:716817688810356826> Population: **" + parseNumber(ot_user.population) + "**");
						diplomacy_view_array.push("<:soldiers:732730754592669702> Active Personnel: **" + parseNumber(ot_user.used_soldiers) + "**");
						diplomacy_view_array.push("<:technology:716812861514711040> Techs Researched: **" + ot_user.techs_researched + "**");
						diplomacy_view_array.push("");
						
						//Push relations
						diplomacy_view_array.push("<:faculty:732730754911436830> Diplomatic Slots: (**"  + ot_user.used_diplomatic_slots + "**/**" + ot_user.modifiers.starting_diplomatic_slots + "**)");
						diplomacy_view_array.push("<:infamy:716817688453709905> Infamy: **" + parseNumber(ot_user.infamy) + "**");
						diplomacy_view_array.push("");
						
						//[value, player_id, [improving/decreasing/none, turns]]
						
						var ot_player_relations = 0;
						var actual_player_relations = 0;
						var ot_player_relations_suffix = "";
						var actual_player_relations_suffix = "";
						for (var i = 0; i < ot_user.relations.length; i++) {
							if (ot_user.relations[i][1] == arg0_user) {
								ot_player_relations = ot_user.relations[i][0];
							}
						}
						for (var i = 0; i < usr.relations.length; i++) {
							if (usr.relations[i][1] == arg1_user) {
								actual_player_relations = usr.relations[i][0];
							}
						}
						if (ot_player_relations >= 0) {
							ot_player_relations_suffix = "+";
						}
						if (actual_player_relations_suffix >= 0) {
							actual_player_relations_suffix = "+";
						}
						
						diplomacy_view_array.push("Our relations with them: **" + actual_player_relations_suffix + actual_player_relations + "**");
						diplomacy_view_array.push("Their relations with us: **" + ot_player_relations_suffix + ot_player_relations + "**");
						
						var allies_array = [];
						var rivals_array = [];
						var guaranteed_array = [];
						var military_access_array = [];
						var non_aggression_pact_array = [];
						var vassal_string = "";
						
						var user_is_ally = false;
						var user_is_rival = false;
						var user_is_vassal = false;
						var user_is_guaranteed = false;
						var user_grants_mil_access = false;
						var user_has_non_agg_pact = false;
						
						diplomacy_view_array.push("");
						
						for (var i = 0; i < ot_user.allies.length; i++) {
							allies_array.push(main.users[ot_user.allies[i][0]].name);
							if (ot_user.allies[i][0] == arg0_user) {
								user_is_ally = true;
							}
						}
						for (var i = 0; i < ot_user.rivals.length; i++) {
							rivals_array.push(main.users[ot_user.rivals[i]].name);
							if (ot_user.rivals[i] == arg0_user) {
								user_is_rival = true;
							}
						}
						for (var i = 0; i < main.user_array.length; i++) {
							for (var x = 0; x < main.users[main.user_array[i]].guarantees.length; x++) {
								if (main.users[main.user_array[i]].guarantees[x] == arg1_user) {
									guaranteed_array.push(main.users[main.user_array[i]].name);
								}
							}
						}
						for (var i = 0; i < usr.guarantees.length; i++) {
							if (usr.guarantees[i] == arg1_user) {
								user_is_guaranteed = true;
							}
						}
						for (var i = 0; i < main.user_array.length; i++) {
							for (var x = 0; x < main.users[main.user_array[i]].military_access.length; x++) {
								if (main.users[main.user_array[i]].military_access[x] == arg1_user) {
									military_access_array.push(main.users[main.user_array[i]].name);
								}
							}
						}
						for (var i = 0; i < usr.military_access.length; i++) {
							if (usr.military_access[i] == arg1_user) {
								user_grants_mil_access = true;
							}
						}
						for (var i = 0; i < ot_user.non_aggression_pacts.length; i++) {
							non_aggression_pact_array.push(main.users[ot_user.non_aggression_pacts[i][0]].name);
							if (ot_user.non_aggression_pacts[i][0] == arg0_user) {
								user_has_non_agg_pact = true;
							}
						}
						for (var i = 0; i < main.user_array.length; i++) {
							for (var x = 0; x < main.users[main.user_array[i]].vassals.length; x++) {
								if (main.users[main.user_array[i]].vassals[x] == arg1_user) {
									vassal_string = "**" + ot_user.name + "** is a vassal of **" + main.users[main.user_array[i]].name + "**.";
								}
							}
						}
						
						if (allies_array.length > 0) {
							diplomacy_view_array.push("The following nations are allied to **" + ot_user.name + "**: " + allies_array.join(", ") + ".");
						}
						if (rivals_array.length > 0) {
							diplomacy_view_array.push("The following nations are rivals of **" + ot_user.name + "**: " + rivals_array.join(", ") + ".");
						}
						if (guaranteed_array.length > 0) {
							diplomacy_view_array.push("The following nations are currently guaranteeing the independence of **" + ot_user.name + "**: " + guaranteed_array.join(", ") + ".");
						}
						if (military_access_array.length > 0) {
							diplomacy_view_array.push("The following nations have military access through **" + ot_user.name + "**: " + military_access_array.join(", ") + ".");
						}
						if (non_aggression_pact_array.length > 0) {
							diplomacy_view_array.push("The following nations have a non-aggression pact with **" + ot_user.name + "**: " + non_aggression_pact_array.join(", ") + ".");
						}
						
						if (vassal_string != "") {
							diplomacy_view_array.push(vassal_string);
						}
						
						diplomacy_view_array.push("------------------");
						diplomacy_view_array.push("**Diplomatic Actions:**");
						diplomacy_view_array.push("");
						diplomacy_view_array.push("**Justify Wargoal** - " + config.justify_wargoal_cost + " PC");
						diplomacy_view_array.push("- `" + bot_prefix + "justify-wargoal " + '"' + ot_user.name + '"' + " <wargoal>`");
						diplomacy_view_array.push("Type `" + bot_prefix + "view-cb " + '"' + ot_user.name + '"' + "` to view a list of valid CBs.");
						diplomacy_view_array.push("**Improve Relations** - " + config.improve_relations_cost + " PC");
						diplomacy_view_array.push("- `" + bot_prefix + "improve-relations " + '"' + ot_user.name + '"' + "`");
						diplomacy_view_array.push("**Decrease Relations** - " + config.decrease_relations_cost + " PC");
						diplomacy_view_array.push("- `" + bot_prefix + "decrease-relations " + '"' + ot_user.name + '"' + "`");
						diplomacy_view_array.push("");
						
						if (user_is_ally) {
							diplomacy_view_array.push("**Break Alliance** - " + config.break_alliance_cost + " PC");
							diplomacy_view_array.push("- `" + bot_prefix + "break-alliance " + '"' + ot_user.name + '"' + "`");
						} else {
							diplomacy_view_array.push("**Request Alliance** - " + config.vassalise_cost + " PC");
							diplomacy_view_array.push("- `" + bot_prefix + "ally " + '"' + ot_user.name + '"' + "`");
						}
						if (user_is_rival) {
							diplomacy_view_array.push("**End Rivalry**");
							diplomacy_view_array.push("- `" + bot_prefix + "end-rivalry " + '"' + ot_user.name + '"' + "`");
						} else {
							diplomacy_view_array.push("**Declare Rivalry** - " + config.declare_rival_cost + " PC");
							diplomacy_view_array.push("- `" + bot_prefix + "rival " + '"' + ot_user.name + '"' + "`");
						}
						if (user_is_guaranteed) {
							diplomacy_view_array.push("**Revoke Guarantee**");
							diplomacy_view_array.push("- `" + bot_prefix + "revoke-guarantee " + '"' + ot_user.name + '"' + "`");
						} else {
							diplomacy_view_array.push("**Guarantee Independence** - " + config.guarantee_independence_cost + " PC");
							diplomacy_view_array.push("- `" + bot_prefix + "proclaim-guarantee " + '"' + ot_user.name + '"' + "`");
						}
						if (user_grants_mil_access == false) {
							diplomacy_view_array.push("**Request Military Access** - " + config.request_military_access_cost + " PC");
							diplomacy_view_array.push("- `" + bot_prefix + "request-military-access " + '"' + ot_user.name + '"' + "`");
						}
						if (user_has_non_agg_pact == false) {
							diplomacy_view_array.push("**Sign Non-Aggression Pact** - " + config.sign_non_aggression_pact_cost + " PC");
							diplomacy_view_array.push("- `" + bot_prefix + "sign-non-aggression-pact " + '"' + ot_user.name + '"' + "`");
						}
						if (user_is_vassal) {
							diplomacy_view_array.push("**Liberate**");
							diplomacy_view_array.push("- `" + bot_prefix + "liberate " + '"' + ot_user.name + '"' + "`");
						} else {
							diplomacy_view_array.push("**Demand Vassalisation** - " + config.vassalise_cost + " PC");
							diplomacy_view_array.push("- `" + bot_prefix + "vassalise " + '"' + ot_user.name + '"' + "`");
						}
						
						const embed_diplomatic_actions = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Viewing Diplomacy for ' + ot_user.name + ':\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(diplomacy_view_array.join("\n"))
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'view-diplomacy ' + ot_user.name + '.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
							
						msg.channel.send(embed_diplomatic_actions);
					} else {
						msg.channel.send("The country you wish to look at does not exist!");
					}
				} else {
					msg.channel.send("You must have a country in order to conduct diplomatic relations!");
				}
			}
		
			function viewPeaceOffer (arg0_user, arg1_war, arg2_message) {
				var msg = arg2_message;
				var peace_string_array = [];
				
				if (main.users[arg0_user] != undefined) {
					//Check if war exists
					var all_wars = Object.keys(main.users.global.wars);
					var war_exists = [false, ""];
					
					//Soft match first
					for (var i = 0; i < all_wars.length; i++) {
						if (main.users.global.wars[all_wars[i]].name.toLowerCase().indexOf(arg1_war.toLowerCase()) != -1) {
							war_exists = [true, all_wars[i]];
						}
					}
					//Hard match next
					for (var i = 0; i < all_wars.length; i++) {
						if (main.users.global.wars[all_wars[i]].name.toLowerCase() == arg1_war.toLowerCase()) {
							war_exists = [true, all_wars[i]];
						}
					}
					
					if (war_exists[0]) {
						//Check if country is involved in war
						var involved_in_war = false;
						var war_obj = main.users.global.wars[war_exists[1]];
						
						for (var i = 0; i < war_obj.defenders.length; i++) {
							if (war_obj.defenders[i] == arg0_user) {
								involved_in_war = true;
							}
						}
						for (var i = 0; i < war_obj.attackers.length; i++) {
							if (war_obj.attackers[i] == arg0_user) {
								involved_in_war = true;
							}
						}
						
						if (involved_in_war) {
							//Check that peace offer exists
							var all_offers = Object.keys(war_obj.peace_offers);
							var has_peace_offer = [false, ""];
							for (var i = 0; i < all_offers.length; i++) {
								if (war_obj.peace_offers[all_offers[i]].country == arg0_user) {
									has_peace_offer = [true, all_offers[i]];
								}
							}
							
							if (has_peace_offer[0]) {
								var peace_obj = war_obj.peace_offers[has_peace_offer[1]];
								var no_terms = true;
								//Parse peace offer and output to message
								var wargoals = ["status_quo", "install_government", "cut_down_to_size", "liberation", "puppet", "retake_cores", "annexation"];
								for (var i = 0; i < wargoals.length; i++) {
									if (peace_obj[wargoals[i]] != undefined) {
										no_terms = false;
									}
								}
								
								peace_string_array.push("<@" + arg0_user + ">'s Peace Offer for the **" + war_obj.name + "**:");
								peace_string_array.push("------------------");
								peace_string_array.push("");
								
								if (no_terms) {
									peace_string_array.push(" White Peace");
								} else {
									for (var i = 0; i < wargoals.length; i++) {
										if (wargoals[i] == "status_quo") {
											if (peace_obj[wargoals[i]] != undefined) {
												peace_string_array.push(" The opposing side will be forced to pay **10%** of their cash reserves as war reparations.");
											}
										} else if (wargoals[i] == "install_government") {
											if (peace_obj[wargoals[i]] != undefined) {
												if (peace_obj[wargoals[i]].length > 0) {
													for (var x = 0; x < peace_obj[wargoals[i]].length; x++) {
														peace_string_array.push(" The nation of **" + main.users[peace_obj[wargoals[i]][x][0]].name + "** will be forced to change their government to " + config.governments[peace_obj[wargoals[i]][x][1]][0].toLowerCase() + ".");
													}
												}
											}
										} else if (wargoals[i] == "cut_down_to_size") {
											if (peace_obj[wargoals[i]] != undefined) {
												if (peace_obj[wargoals[i]].length > 0) {
													for (var x = 0; x < peace_obj[wargoals[i]].length; x++) {
														peace_string_array.push(" " + main.users[peace_obj[wargoals[i]][x]].name + " will be required to demobilise and disband 90% of its active forces in all divisions and armies.");
													}
												}
											}
										} else if (wargoals[i] == "liberation") {
											if (peace_obj[wargoals[i]] != undefined) {
												peace_string_array.push("The country of **" + main.users[peace_obj.country].name + "** has demanded her liberation from its overlord.");
											}
										} else if (wargoals[i] == "puppet") {
											if (peace_obj[wargoals[i]] != undefined) {
												if (peace_obj[wargoals[i]].length > 0) {
													for (var x = 0; x < peace_obj[wargoals[i]].length; x++) {
														peace_string_array.push(" **" + main.users[peace_obj[wargoals[i]][x][0]] + "** will gain overlordship over the nation of **" + main.users[peace_obj[wargoals[i]][x][1]] + "**.");
													}
												}
											}
										} else if (wargoals[i] == "retake_cores") {
											if (peace_obj[wargoals[i]] != undefined) {
												if (peace_obj[wargoals[i]].length > 0) {
													for (var x = 0; x < peace_obj[wargoals[i]].length; x++) {
														peace_string_array.push(" **" + main.users[peace_obj[wargoals[i]][x]].name + "** will be returned all of its core provinces from the opposing side.");
													}
												}
											}
										} else if (wargoals[i] == "annexation") {
											if (peace_obj[wargoals[i]] != undefined) {
												if (peace_obj[wargoals[i]].length > 0) {
													for (var x = 0; x < peace_obj[wargoals[i]].length; x++) {
														peace_string_array.push(" **" + main.users[peace_obj[wargoals[i]][x][0]].name + "** gains the provinces of **" + peace_obj[wargoals[i]][x][1].join(", ") + "** from the opposing side.");
													}
												}
											}
										}
									}
								}
								
								longMessage(msg, peace_string_array, 20);
							} else {
								msg.channel.send("You must have a peace offer active in order to view it! Create a peace offer by typing `" + bot_prefix + 'sign-peace-treaty "' + war_obj.name + '"`.');
							}
						} else {
							msg.channel.send("You need to be an active participant of the war in order to have a peace offer to view!");
						}
					} else {
						msg.channel.send("The war you have specified does not exist!");
					}
				} else {
					msg.channel.send("You must have a nation in order to send and edit peace offers!");
				}
			}
		}
		
		//Events commands
		{
			function updateString (arg0_string) {
				var current_string = arg0_string;
				
				current_string = current_string.replace(/\{0}/gm, getLoc());
				current_string = current_string.replace(/\{1}/gm, getLoc(1));
				current_string = current_string.replace(/\{2}/gm, getLoc(2));
				current_string = current_string.replace(/\{3}/gm, getLoc(3));
				current_string = current_string.replace(/\{4}/gm, getLoc(4));
				current_string = current_string.replace(/\{5}/gm, getLoc(5));
				current_string = current_string.replace(/\{6}/gm, getLoc(6));
				current_string = current_string.replace(/\{7}/gm, getLoc(7));
				current_string = current_string.replace(/\{8}/gm, getLoc(8));
				
				return current_string;
			}
			
			function printEvent (arg0_user, arg1_event) {
				let user = client.users.cache.find(user => user.id.toString() == arg0_user);
				
				var usr = main.users[arg0_user];
				//Get all keys in config.events
				var events = Object.keys(config.events);
				var called_event = arg1_event;
				var event_exists = false;
				
				var event_string = [];
				
				for (var i = 0; i < events.length; i++) {
					if (events[i] == called_event) {
						event_exists = true;
					}
				}
				
				if (event_exists) {
					var ev = config.events[called_event];
					
					event_string.push("------------------");
					event_string.push("");
					if (ev.description != undefined) {
						event_string.push(updateString(ev.description));
					}
					var alphabet = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
					var random_option = [];
					var has_image = false;
					
					for (var i = 0; i < alphabet.length; i++) {
						var has_limits = false;
						
						if (ev["option_" + alphabet[i] + "_limits"] != undefined) {
							has_limits = true;
						}
						
						if (has_limits) {
							if (ev["option_" + alphabet[i] + "_limits"]()) {
								if (ev["option_" + alphabet[i] + "_ai_chance"] != undefined) {
									random_option.push("");
									random_option.push(ev["option_" + alphabet[i] + "_ai_chance"](usr));
								} else {
									if (ev["option_" + alphabet[i]] != undefined) {
										random_option.push(0);
									}
								}
							} else {
								random_option.push(0);
							}
						} else {
							if (ev["option_" + alphabet[i] + "_ai_chance"] != undefined) {
								random_option.push("");
								random_option.push(ev["option_" + alphabet[i] + "_ai_chance"](usr));
							} else {
								if (ev["option_" + alphabet[i]] != undefined) {
									random_option.push(0);
								}
							}
						}
					}
					
					if (ev.event_image != undefined) {
						has_image = true;
					}
					
					var total_sum = 0;
					var id_array = [];
					var all_ids = usr.previous_option_id;
					for (var i = 0; i < random_option.length; i++) {
						total_sum = total_sum + random_option[i];
						id_array.push(all_ids+i);
					}
					
					if (total_sum == 0) {
						//random pick for 100
						var random_pick = randomNumber(0, random_option.length-1);
						random_option[random_pick] = 100;
					}
					
					for (var i = 0; i < alphabet.length; i++) {
						if (ev["option_" + alphabet[i] + "_limits"] != undefined) {
							has_limits = true;
						}
						
						var fulfills_conditions = false;
						
						if (has_limits) {
							if (ev["option_" + alphabet[i] + "_limits"]()) {
								fulfills_conditions = true;
							}
						} else {
							fulfills_conditions = true;
						}
						
						if (fulfills_conditions) {
							if (ev["option_" + alphabet[i] + "_title"] != undefined) {
								event_string.push("");
								event_string.push("**[" + ev["option_" + alphabet[i] + "_title"] + "]** `" + bot_prefix + "resolve " + id_array[i] + "`");
								event_string.push(updateString(ev["option_" + alphabet[i] + "_description"]));
							}
						}
					}
					event_string.push("");
					event_string.push("_If you do not respond to this event within 5 turns, a random choice will be automatically chosen for you._");
					
					var save_scope = main.users.global.current_scope;
					
					usr.events.push([[arg1_event, 5], id_array, random_option, save_scope]);
					usr.previous_option_id = usr.previous_option_id + id_array.length;
					
					if (has_image == false) {
						const embed_event = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**' + ev.name + '**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(event_string.join("\n"))
							.setTimestamp();
						
						if (user != undefined) {
							user.send(embed_event);
						}
					} else {
						const embed_event = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**' + ev.name + '**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(event_string.join("\n"))
							.setImage(ev.event_image)
							.setTimestamp();
						
						if (user != undefined) {
							user.send(embed_event);
						}
					}
				}
			}
		
			function resolveEvent (arg0_user, arg1_id, arg2_msg) {
				var option_id = arg1_id;
				var msg = arg2_msg;
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					var alphabet = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
					var event_name = "";
					var option_name = "";
					var event_index_position = 0;
					//[[["comet_sighted",5],[0]],[["comet_sighted",5],[1]],[["comet_sighted",5],[2]]]
					for (var i = 0; i < usr.events.length; i++) {
						for (var x = 0; x < usr.events[i][1].length; x++) {
							if (usr.events[i][1][x].toString() == arg1_id.toString()) {
								event_name = usr.events[i][0][0];
								option_name = alphabet[x];
								event_index_position = i;
							}
						}
					}
					
					main.users.global.current_scope = usr.events[event_index_position][3];
					
					if (event_name != "" || option_name != "") {
						config.events[event_name]["option_" + option_name](usr);
						usr.events.splice(event_index_position, 1);
						msg.channel.send("<:checkmark:725550245051760671> **" + config.events[event_name].name + "** resolved.");
					} else {
						msg.channel.send("You failed to specify a correct ID. Please check the resolve command provided.");
					}
				}
			}
		}
		
		//Map (Experimental) commands
		{
			function componentToHex(c) {
				var hex = c.toString(16);
				return hex.length == 1 ? "0" + hex : hex;
			}

			function rgbToHex(r, g, b) {
				return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
			}
			
			function displaySVG (arg0_channel) {
				var msg = arg0_channel;
				var label_placement = [7, 8, 8, 9, 10000]; //Last column is overflow
				var labels = []; //[[label1, label2, label3], [label4, label5]]
				
				{
					var current_element = 0;
					var counter = 0;
					for (var i = 0; i < main.user_array.length; i++) {
						if (label_placement[current_element] != undefined) {
							if (counter == label_placement[current_element]) {
								counter = 0;
								current_element++;
							}
							if (counter < label_placement[current_element]) {
								counter++;
								if (labels[current_element] == undefined) {
									labels[current_element] = [main.user_array[i]];
								} else {
									labels[current_element].push(main.user_array[i]);
								}
							}
						}
						if (main.users[main.user_array[i]].provinces > 0) {
							for (var x = 0; x < main.users[main.user_array[i]].pops.pop_array.length; x++) {
								processSVG([main.users[main.user_array[i]].colour, main.users[main.user_array[i]].pops.pop_array[x]]);
							}
							for (var x = 0; x < main.users[main.user_array[i]].cities.province_array.length; x++) {
								processSVG([main.users[main.user_array[i]].colour, main.users[main.user_array[i]].cities.province_array[x]]);
							}
						}
					}
					
					function truncateString (str, num) {
						if (str.length <= num) {
							return str;
						}
						return str.slice(0, num) + '...'
					}
					
					console.log(labels);
					
					setTimeout(function(){
						const canvas = Canvas.createCanvas(4000, 2000);
						const ctx = canvas.getContext("2d");
						
						//Load map
						const background = new Canvas.Image();
						const prov_ids = new Canvas.Image();
						const img = new Canvas.Image();
						
						background.onload = () => ctx.drawImage(background, 0, 0);
						background.onerror = err => { throw err; }
						background.src = "./maps/background.png";
						img.onload = () => ctx.drawImage(img, 0, 0);
						img.onerror = err => { throw err; }
						img.src = "./maps/processed_test.svg";
						prov_ids.onload = () => ctx.drawImage(prov_ids, 0, 0);
						prov_ids.onerror = err => { throw err; }
						prov_ids.src = "./maps/province_ids.png";
						
						//Generate Key
						ctx.font = "36px Quicksand SemiBold";
						ctx.fillStyle = "#ffffff";
						ctx.fillText("Nations of the World: ", 2498, 45);
						
						ctx.font = "36px Raleway Light";
						ctx.strokeStyle = "#ffffff";
						for (var i = 0; i < labels.length; i++) {
							for (var x = 0; x < labels[i].length; x++) {
								ctx.fillStyle = rgbToHex(parseInt(main.users[labels[i][x]].colour[0]), parseInt(main.users[labels[i][x]].colour[1]), parseInt(main.users[labels[i][x]].colour[2]));
								ctx.fillRect(2500+(i*350), 60+(x*40), 36, 36);
								ctx.beginPath();
								ctx.rect(2500+(i*350), 60+(x*40), 36, 36);
								ctx.stroke();
								
								ctx.fillStyle = "#ffffff";
								ctx.fillText(truncateString(main.users[labels[i][x]].name, 20), 2550+(i*350), 92+(x*40));
							}
						}
						
						const attachment = new Discord.MessageAttachment(canvas.toBuffer(), "map.png");
						msg.send("__**Map of the World in the year of our Lord, " + (1500+main.roundCount) + ":**__", attachment);
					}, 1000);
				}
			}
			
			function processSVG (arg0_options) {
				var output_array = [];
				
				{
					//Process SVG
					var svg_array = original_svg.split("");
					var in_path = false;
					var in_id_string = false;
					var in_fill = false;
					var fill_counter = 0;
					
					var current_path = [];
					var id = [];
					var starting_element = 0;
					var original_colour = ("fill:" + rgbToHex(parseInt(arg0_options[0][0]), parseInt(arg0_options[0][1]), parseInt(arg0_options[0][2]))).split("");
					
					var i = 0;
					if (parseInt(arg0_options[1]) > 20) {
						var match = original_svg.indexOf('id="' + arg0_options[1] + '"');
						i = match-3000;
					}
					while (i++ < svg_array.length) {
						if (svg_array[i-5] == "<" && svg_array[i-4] == "p") {
							in_path = true;
							starting_element = i;
						}
						if (in_path && svg_array[i-4] == "i" && svg_array[i-3] == "d" && svg_array[i-2] == "=" && svg_array[i-1] == '"') {
							in_id_string = true;
						}
						
						//Get ID here
						if (in_id_string && svg_array[i] == '"') {
							in_id_string = false;
							
							if (id.join("") == arg0_options[1]) {
								for (var x = 0; x < current_path.length; x++) {
									if (current_path[x] == "f" && current_path[x+1] == "i" && current_path[x+2] == "l" && current_path[x+3] == 'l' && current_path[x+4] == ':') {
										in_fill = true;
									}
									
									if (current_path[x] == ";") {
										if (in_fill) {
											in_fill = false;
											fill_counter = 0;
										}
									}
									
									if (in_fill) {
										svg_array[starting_element+x] = original_colour[fill_counter];
										fill_counter++;
									}
								}
								break;
							}
							
							id = [];
						}
						
						if (in_path && svg_array[i] == "/" && svg_array[i+1] == ">") {
							in_path = false;
							current_path = [];
						}
						
						if (in_path) {
							current_path.push(svg_array[i]);
						}
						
						if (in_id_string) {
							id.push(svg_array[i]);
						}
					}
					original_svg = svg_array.join("");
				}
			}
		}
		
		//Politics commands
		{
			function coup (arg0_user, arg1_ideology, arg2_msg) {
				var msg = arg2_msg;
				
				if (main.users[arg0_user] != undefined) {
					if (main.users[arg0_user].political_capital >= config.coup_cost) {
						var ideology_exists = false;
						var idelogy_valid = false;
						
						for (var i = 0; i < config.government_list.length; i++) {
							if (arg1_ideology.toLowerCase() == config.government_list[i]) {
								ideology_exists = true;
							}
						}
						
						if (ideology_exists) {
							for (var i = 0; i < main.users[arg0_user].available_governments.length; i++) {
								if (arg1_ideology.toLowerCase() == main.users[arg0_user].available_governments[i]) {
									ideology_valid = true;
								}
							}
							if (ideology_valid) {
								main.users[arg0_user].overthrow_this_turn = arg1_ideology.toLowerCase();
								msg.channel.send("You have initiated a coup! Your country will begin embracing **" + arg1_ideology.toLowerCase() + "** next turn.");
							} else {
								msg.channel.send("Your people haven't heard of such an ideology yet!");
							}
						} else {
							msg.channel.send("The ideology you have specified is non-existent! Try `" + bot_prefix + "government list` for a valid list of government types.");
						}
					} else {
						msg.channel.send("You don't have enough political capital to afford a coup!");
					}
				} else {
					msg.channel.send("You don't even have a country!");
				}
			}
			
			function enactReform (arg0_user, arg1_reform, arg2_msg) {
				var msg = arg2_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (usr.government != "absolute_monarchy") {
						if (usr.at_war.length == 0) {
							if (usr.political_capital >= config.reform_cost) {
								var can_enact_reform = false;
								var reform_category_exists = [false, ""];
								var reform_name = "";
								var reform_index = 0;
								
								var all_reform_categories = Object.keys(config.reforms);
								for (var i = 0; i < all_reform_categories.length; i++) {
									var all_reforms_in_category = Object.keys(config.reforms[all_reform_categories[i]]);
									
									for (var x = 0; x < all_reforms_in_category.length; x++) {
										if (all_reforms_in_category[x] == "name") {
											all_reforms_in_category.splice(x, 1);
										}
									}
									
									for (var x = 0; x < all_reforms_in_category.length; x++) {
										if (config.reforms[all_reform_categories[i]][all_reforms_in_category[x]].name.toLowerCase().indexOf(arg1_reform.toLowerCase()) != -1) {
											reform_category_exists = [true, all_reform_categories[i]];
											reform_name = all_reforms_in_category[x];
											reform_index = x;
										}
										if (config.reforms[all_reform_categories[i]][all_reforms_in_category[x]].name.toLowerCase() == arg1_reform.toLowerCase()) {
											reform_category_exists = [true, all_reform_categories[i]];
											reform_name = all_reforms_in_category[x];
											reform_index = x;
										}
									}
								}
								
								if (reform_category_exists[0]) {
									var current_reform_index = 0;
									var current_reforms = Object.keys(config.reforms[reform_category_exists[1]]);
									for (var i = 0; i < current_reforms.length; i++) {
										if (current_reforms[i] == "name") {
											current_reforms.splice(i, 1);
										}
									}
									for (var i = 0; i < current_reforms.length; i++) {
										if (current_reforms[i] == usr[reform_category_exists[1]]) {
											current_reform_index = i;
										}
									}
									
									console.log("[Triumph & Tragedy]: CURRENT REFORMS: " + current_reforms);
									console.log("[Triumph & Tragedy]: REFORM INDEX: " + reform_index + ", CURRENT REFORM INDEX: " + current_reform_index);
									
									if (reform_index == current_reform_index-1 || reform_index == current_reform_index+1) {
										var can_enact_reform = false;
										
										for (var i = 0; i < usr.available_reforms.length; i++) {
											if (usr.available_reforms[i] == reform_category_exists[1]) {
												can_enact_reform = true;
											}
										}
										
										if (can_enact_reform) {
											var old_reform_obj = config.reforms[reform_category_exists[1]][usr[reform_category_exists[1]]];
											var reform_obj = config.reforms[reform_category_exists[1]][reform_name]
											
											//Remove old reform modifiers
											if (old_reform_obj.political_appeasement != undefined) {
												for (var i = 0; i < config.government_list.length; i++) {
													if (old_reform_obj.political_appeasement[config.government_list[i] + "_discontent"] != undefined) {
														usr.modifiers[config.government_list[i] + "_discontent"] = usr.modifiers[config.government_list[i] + "_discontent"] + old_reform_obj.political_appeasement[config.government_list[i] + "_discontent"]*-1;
													}
												}
											}
											if (old_reform_obj.effects != undefined) {
												for (var i = 0; i < old_reform_obj.effects.length; i++) {
													if (old_reform_obj.effects[i][0] == "stability" || old_reform_obj.effects[i][0] == "max_tax" || old_reform_obj.effects[i][0] == "manpower_percentage" || old_reform_obj.effects[i][0] == "pop_growth_modifier") {
														usr[old_reform_obj.effects[i][0]] = usr[old_reform_obj.effects[i][0]] + old_reform_obj.effects[i][1]*-1;
													} else {
														usr.modifiers[old_reform_obj.effects[i][0]] = usr.modifiers[old_reform_obj.effects[i][0]] + old_reform_obj.effects[i][1]*-1;
													}
												}
											}
											
											//Add new reform modifiers
											if (reform_obj.political_appeasement != undefined) {
												for (var i = 0; i < config.government_list.length; i++) {
													if (reform_obj.political_appeasement[config.government_list[i] + "_discontent"] != undefined) {
														usr.modifiers[config.government_list[i] + "_discontent"] = usr.modifiers[config.government_list[i] + "_discontent"] + reform_obj.political_appeasement[config.government_list[i] + "_discontent"]*-1;
													}
												}
											}
											if (reform_obj.effects != undefined) {
												for (var i = 0; i < reform_obj.effects.length; i++) {
													if (reform_obj.effects[i][0] == "stability" || reform_obj.effects[i][0] == "max_tax" || reform_obj.effects[i][0] == "manpower_percentage" || reform_obj.effects[i][0] == "pop_growth_modifier") {
														usr[reform_obj.effects[i][0]] = usr[reform_obj.effects[i][0]] + reform_obj.effects[i][1];
													} else {
														usr.modifiers[reform_obj.effects[i][0]] = usr.modifiers[reform_obj.effects[i][0]] + reform_obj.effects[i][1];
													}
												}
											}
											
											//Subtract political capital
											usr.political_capital = usr.political_capital - config.reform_cost;
											
											//Random voting by which parties would be in favour of such a bill if democracy
											
											var voting_passed = true;
											var ayes = 0;
											var nays = 0;
											var abstentions = 0;
											
											if (usr.government == "constitutional_monarchy" || usr.government == "democracy" || usr.government == "socialism") {
												var parliament_report = [];
												parliament_report.push("**__" + reform_obj.name + " Act__**");
												parliament_report.push("------------------");
												parliament_report.push("");
												for (var i = 0; i < config.government_list.length; i++) {
													var stance = ""; //in support, in opposition, neutral
													
													console.log("[Triumph & Tragedy]: Reform Object in Parliament: " + reform_obj);
													if (reform_obj.political_appeasement[config.government_list[i] + "_discontent"] != undefined) {
														if (reform_obj.political_appeasement[config.government_list[i] + "_discontent"] == old_reform_obj.political_appeasement[config.government_list[i] + "_discontent"]) {
															stance = "neutral";
														} else if (reform_obj.political_appeasement[config.government_list[i] + "_discontent"] > old_reform_obj.political_appeasement[config.government_list[i] + "_discontent"]) {
															stance = "in opposition";
														} else if (reform_obj.political_appeasement[config.government_list[i] + "_discontent"] < old_reform_obj.political_appeasement[config.government_list[i] + "_discontent"]) {
															stance = "in support";
														}
													} else {
														stance = "neutral";
													}
													
													if (usr.politics[config.government_list[i]] > 0) {
														if (stance == "in support") {
															var party_ayes = randomNumber(0, usr.politics[config.government_list[i]]);
															var party_abstentions = usr.politics[config.government_list[i]] - party_ayes;
															ayes = ayes + party_ayes;
															abstentions = abstentions + party_abstentions;
															parliament_report.push("The **" + config.governments[config.government_list[i]].name[1] + "** were **supportive** of the motion, with **" + ayes + "** voting in favour, and **" + party_abstentions + "** abstaining.");
														} else if (stance == "in opposition") {
															var party_nays = randomNumber(0, usr.politics[config.government_list[i]]);
															var party_abstentions = usr.politics[config.government_list[i]] - party_nays;
															nays = nays + party_nays;
															abstentions = abstentions + party_abstentions;
															parliament_report.push("The **" + config.governments[config.government_list[i]].name[1] + "** were **opposed** to the motion, with **" + nays + "** voting in opposition, and **" + party_abstentions + "** abstaining.");
														} else if (stance == "neutral") {
															abstentions = abstentions + usr.politics[config.government_list[i]];
															parliament_report.push("The **" + config.governments[config.government_list[i]].name[1] + "** were neither **in favour** nor **in opposition** to the motion, with their entire party of **" + usr.politics[config.government_list[i]] + "** representatives abstaining.");
														}
													}
												}
													
												parliament_report.push("");
												parliament_report.push("The Ayes to the right, **" + ayes + "**, the Noes to the left, **" + nays + "**.\n**" + abstentions + "** MPs refrained from voting on the issue. Unlock.");
											}
											
											msg.channel.send(parliament_report.join("\n"));
											
											if (usr.government == "constitutional_monarchy" || usr.government == "democracy" || usr.government == "socialism") {
												
												if (usr.modifiers.reform_desire >= 0.5) {
													usr.modifiers.reform_desire = usr.modifiers.reform_desire - 0.5;
												} else {
													usr.modifiers.reform_desire = 0;
												}
												
												if (ayes > nays) {
													msg.channel.send("<:checkmark:725550245051760671> You have changed your policy on **" + config.reforms[reform_category_exists[1]].name + "** from **" + old_reform_obj.name + "** to **" + reform_obj.name + "**.");
													usr[reform_category_exists[1]] = reform_name;
												} else {
													msg.channel.send("The reform unfortunately failed to pass Parliament.");
												}
											} else {
												if (usr.modifiers.reform_desire >= 0.5) {
													usr.modifiers.reform_desire = usr.modifiers.reform_desire - 0.5;
												} else {
													usr.modifiers.reform_desire = 0;
												}
												usr[reform_category_exists[1]] = reform_name;
												msg.channel.send("<:checkmark:725550245051760671> You have changed your policy on **" + config.reforms[reform_category_exists[1]].name + "** from **" + old_reform_obj.name + "** to **" + reform_obj.name + ".");
											}
										} else {
											msg.channel.send("You were unable to enact this reform. Try researching additional technologies first.");
										}
									} else if (reform_index == current_reform_index) {
										msg.channel.send("You have already enacted this reform!");
									} else {
										msg.channel.send("You cannot proceed to that reform yet!");
									}
								} else {
									msg.channel.send("The reform you have specified does not exist!");
								}
							} else {
								msg.channel.send("You don't have enough Political Capital to attempt to enact that reform yet! You need **" + (config.reform_cost-usr.political_capital) + "** <:political_capital:716817688525275257> more Political Capital.");
							}
						} else {
							msg.channel.send("You can't enact reforms whilst you're at war! Focus on the war effort first.");
						}
					} else {
						msg.channel.send("Absolute monarchies cannot enact reforms!");
					}
				} else {
					msg.channel.send("You must have a country before you can begin enacting reforms!");
				}
			}
			
			function printCultures (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var culture_string_array = [];
					
					var all_cultures = [];
					var all_culture_provinces = [];
					var all_culture_populations = [];
					
					//Get names of all cultures, and how many provinces and population each culture has.
					//Get names
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						var culture_already_exists = false;
						if (all_cultures.length > 0) {
							for (var x = 0; x < all_cultures.length; x++) {
								if (usr.pops[usr.pops.pop_array[i]].culture == all_cultures[x]) {
									culture_already_exists = true;
								}
							}
							
							if (culture_already_exists == false) {
								all_cultures.push(usr.pops[usr.pops.pop_array[i]].culture);
							}
						} else {
							all_cultures.push(usr.pops[usr.pops.pop_array[i]].culture);
						}
					}
					
					//Get provinces and population
					for (var i = 0; i < all_cultures.length; i++) {
						var local_provinces = 0;
						var local_population = 0;
						for (var x = 0; x < usr.pops.pop_array.length; x++) {
							if (usr.pops[usr.pops.pop_array[x]].culture == all_cultures[i]) {
								local_provinces++;
								local_population = local_population + usr.pops[usr.pops.pop_array[x]].population;
							}
						}
						
						all_culture_provinces.push(local_provinces);
						all_culture_populations.push(local_population);
					}
					
					var sorted_population_array = all_culture_populations.sort((a,b) => b-a);
					
					culture_string_array.push("<:culture:758424912049864784> Primary Culture: **" + usr.culture + "**.");
					culture_string_array.push("<:consciousness:758424911852470293> Accepted Cultures: " + usr.accepted_cultures.join(", "));
					culture_string_array.push("");
					culture_string_array.push("<:political_capital:716817688525275257> Political Capital: **" + usr.political_capital + "**");
					var has_non_accepted_cultures = false;
					var total_non_accepted_provs = 0;
					var total_non_accepted_pops = 0;
					
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						var is_accepted = false;
						
						for (var x = 0; x < usr.accepted_cultures.length; x++) {
							if (usr.pops[usr.pops.pop_array[i]].culture == usr.accepted_cultures[x]) {
								is_accepted = true;
							}
						}
						
						if (is_accepted == false) {
							has_non_accepted_cultures = true;
							total_non_accepted_provs++;
							var pop_obj = usr.pops[usr.pops.pop_array[i]];
							total_non_accepted_pops = total_non_accepted_pops + pop_obj.population;
						}
					}
					
					if (has_non_accepted_cultures) {
						culture_string_array.push("<:population:716817688810356826> We have **" + total_non_accepted_pops + "** non-accepted provinces with a total population of **" + parseNumber(total_non_accepted_pops) + "**, of which we are receiving just **" + (Math.round(usr.modifiers.non_core_manpower*100*100)/100) + "%** of.");
					}
					
					culture_string_array.push("---");
					culture_string_array.push("");
					
					for (var i = 0; i < sorted_population_array.length; i++) {
						var actual_index = 0;
						for (var x = 0; x < all_culture_populations.length; x++) {
							if (all_culture_populations[x] == sorted_population_array[i]) {
								actual_index = x;
							}
						}
						
						var culture_description = "";
						
						var primary_culture = false;
						var accepted_culture = false;
						for (var x = 0; x < usr.accepted_cultures.length; x++) {
							if (usr.accepted_cultures[x] == all_cultures[actual_index]) {
								accepted_culture = true;
							}
						}
						if (usr.culture == all_cultures[actual_index]) {
							primary_culture = true;
						}
						
						if (primary_culture) {
							culture_description = "our primary culture.";
						} else if (accepted_culture && primary_culture == false) {
							culture_description = "an accepted culture.";
						} else {
							culture_description = "an unaccepted culture. Either assimilate their provinces in `" + bot_prefix + "pops view`, or add them as an accepted culture for **" + config.accepted_culture_cost + "** <:political_capital:716817688525275257> Political Capital."
						}
						
						culture_string_array.push("**" + ((sorted_population_array[i]/usr.population)*100) + "%** of our population, or **" + all_culture_provinces[actual_index] + "** of our provinces identify as **" + all_cultures[actual_index] + "**, " + culture_description);
					}
					
					culture_string_array.push("");
					culture_string_array.push("---");
					
					if (usr.cultural_integrations.length > 0) {
						//[turns, culture]
						for (var i = 0; i < usr.cultural_integrations.length; i++) {
							culture_string_array.push("We are currently integrating the **" + usr.cultural_integrations[i][1] + "** culture into our society. Our advisors estimate that it will take **" + usr.cultural_integrations[i][0] + "** more turns before they are fully integrated.");
						}
					} else {
						culture_string_array.push("_We are currently not integrating any cultures into our societal fabric._\n\nType `" + bot_prefix + "add-accepted-culture` to begin the integration process for <:political_capital:716817688525275257> **" + config.accepted_culture_cost + "** Political Capital.");
					}
						
					const embed_cultures = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Cultures:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(culture_string_array.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'culture.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					msg.channel.send(embed_cultures);
				} else {
					msg.channel.send("You must have a nation in order to view your culture screen!");
				}
			}
			
			function printReforms (arg0_user, arg1_page, arg2_msg) {
				var msg = arg2_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var all_reform_categories = usr.available_reforms;
					var reform_embeds = [];
					var local_reforms_string = [];
					var prefix_string = [];
					
					prefix_string.push("Reforms are governmental policies that you can choose to attempt to enact at a cost of **" + config.reform_cost + "** <:political_capital:716817688525275257> Political Capital. Successfully enacting reforms will also lower your people's <:consciousness:758424911852470293> Reform Desire.");
					prefix_string.push("<:political_capital:716817688525275257> Political Capital: **" + usr.political_capital + "**");
					prefix_string.push("<:consciousness:758424911852470293> Reform Desire: **" + (Math.round(usr.modifiers.reform_desire*100)/100)*100 + "%**");
					prefix_string.push("");
					
					if (all_reform_categories.length > 0) {
						for (var i = 0; i < all_reform_categories.length; i++) {
							local_reforms_string.push("**__" + config.reforms[all_reform_categories[i]].name + ":__**");
							local_reforms_string.push("---");
							local_reforms_string.push("");
							
							var all_reforms_in_category = Object.keys(config.reforms[all_reform_categories[i]]);
							for (var x = 0; x < all_reforms_in_category.length; x++) {
								if (all_reforms_in_category[x] == "name") {
									all_reforms_in_category.splice(x, 1);
								}
							}
							
							for (var x = 0; x < all_reforms_in_category.length; x++) {
								var reform_obj = config.reforms[all_reform_categories[i]][all_reforms_in_category[x]];
								var ending_string = "";
								
								var reform_position = 0;
								for (var y = 0; y < all_reforms_in_category.length; y++) {
									if (all_reforms_in_category[y] == usr[all_reform_categories[i]]) {
										reform_position = y;
									}
								}
								
								if (x == (reform_position-1) || x == (reform_position+1)) {
									ending_string = " - `" + bot_prefix + "enact " + '"' + config.reforms[all_reform_categories[i]][all_reforms_in_category[x]].name + '"' + "`";
								} else if (x == reform_position) {
									ending_string = " - We currently have this reform set to our policy on this matter.";
								} else {
									ending_string = " - This reform is not yet available.";
								}
								
								if (reform_obj.description != undefined) {
									local_reforms_string.push("**[" + reform_obj.name + "](http://tooltip/ '" + reform_obj.description + "')**" + ending_string);
								} else {
									local_reforms_string.push("**[" + reform_obj.name + "](http://tooltip/ '" + reform_obj.description + "')**" + ending_string);
								}
							}
							//Append embed to reform_embeds every 3 reform categories
							const embed_reform_page = new Discord.MessageEmbed()
								.setColor('#a98ac7')
								.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setTitle('**Political Reforms: (Page ' + i + '/' + (usr.available_reforms.length-1) + ')\n------------------**')
								.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setDescription(prefix_string.join("\n") + local_reforms_string.join("\n"))
								.setTimestamp()
								.setFooter('To access this menu again, type ' + bot_prefix + 'reforms <page>.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
								
								reform_embeds.push(embed_reform_page);
								local_reforms_string = [];
						}
					} else {
						local_reforms_string.push("---");
						local_reforms_string.push("");
						local_reforms_string.push("_You currently have have no available reforms that you can pursue._");
						local_reforms_string.push("Research additional <:technology:716812861514711040> **Technologies** in order to unlock more reforms.");
						const embed_reform_page = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Political Reforms:\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(prefix_string.join("\n") + local_reforms_string.join("\n"))
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'reforms <page>.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
							
							reform_embeds.push(embed_reform_page);
					}
					
					if (isNaN(arg1_page) == false) {
						if (arg1_page <= Math.ceil(all_reform_categories.length)) {
							scrollMessage(msg, reform_embeds, arg1_page);
						} else {
							msg.channel.send("You have specified an invalid page.");
						}
					} else {
						msg.channel.send("You must specify a valid page in numerical form.");
					}
				} else {
					msg.channel.send("You must have an independent nation in order to enact reforms!");
				}
			}
			
			function raiseStability (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var user_id = main.users[arg0_user];
					
					if (user_id.political_capital >= config.stability_cost) {
						msg.channel.send("<:stability:716817688722407424> You have raised your stability by **10%**! (-1% per turn).");
						
						user_id.political_capital = user_id.political_capital - config.stability_cost;
						user_id.stability = user_id.stability + 10;
						
						if (user_id.stability > 100) {
							user_id.stability = 100;
						}
						
						user_id.stability_decay = user_id.stability_decay + 10;
					} else {
						msg.channel.send("You don't have enough capital to raise stability yet! You need **" + config.stability_cost-user_id.political_capital + "** more Political Capital to raise your stability by **10%**.");
					}
				} else {
					msg.channel.send("You don't even have a country yet!");
				}
			}
			
			function supportParty (arg0_user, arg1_party, arg2_msg) {
				var msg = arg2_msg;
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var valid_party = false;
					for (var i = 0; i < usr.available_governments.length; i++) {
						if (usr.available_governments[i] == arg1_party) {
							valid_party = true;
						}
					}
					
					if (valid_party) {
						if (usr.political_capital >= 50) {
							if (usr.politics[arg1_party] == 100) {
								msg.channel.send("**" + arg1_party + "** already has maximum support!");
							} else {
								usr.political_capital = usr.political_capital - 50;
								usr.politics[arg1_party] = usr.politics[arg1_party] + 10;
								
								var total_percentage = 0;
								for (var i = 0; i < config.government_list.length; i++) {
									total_percentage = total_percentage + usr.politics[config.government_list[i]];
									console.log("[Triumph & Tragedy]: Political Party Adjustment Needed: " + (total_percentage-100));
								}
								
								if (total_percentage > 100) {
									var decrease_needed = total_percentage-100;
									for (var i = 0; i < config.government_list.length; i++) {
										if (config.government_list[i] != arg1_party) {
											if (decrease_needed > 0) {
												if (usr.politics[config.government_list[i]] >= decrease_needed) {
													usr.politics[config.government_list[i]] = usr.politics[config.government_list[i]] - decrease_needed;
													decrease_needed = 0;
												} else {
													decrease_needed = decrease_needed - usr.politics[config.government_list[i]];
													usr.politics[config.government_list[i]] = 0;
												}
											}
										}
									}
									if (decrease_needed > 0) {
										for (var i = 0; i < config.government_list.length; i++) {
											if (config.government_list[i] != arg1_party) {
												usr.politics[config.government_list[i]] = 0;
											} else {
												usr.politics[config.government_list[i]] = 100;
											}
										}
										decrease_needed = 0;
									}
								}
								
								msg.channel.send("You boosted **" + arg1_party + "** by **10%** for <:political_capital:716817688525275257> 50 Political Capital.");
							}
						} else {
							msg.channel.send("You need at least <:political_capital:716817688525275257> " + (50-usr.political_capital) + " Political Capital to be able to promote **" + arg1_party + "**!");
						}
					} else {
						msg.channel.send("The party you have specified does not exist! Try using " + usr.available_governments.join(", ") + " instead.");
					}
				} else {
					msg.channel.send("You can't support a nonexistent party in a nonexistent country!");
				}
			}
		}
		
		//Population commands
		{
			function addAcceptedCulture (arg0_user, arg1_culture, arg2_msg) {
				var msg = arg2_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var all_cultures = [];
					
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						var culture_already_exists = false;
						
						if (all_cultures.length > 0) {
							for (var x = 0; x < all_cultures.length; x++) {
								if (all_cultures[x] == usr.pops[usr.pops.pop_array[i]].culture) {
									culture_already_exists = true;
								}
							}
						}
						
						if (culture_already_exists == false) {
							all_cultures.push(usr.pops[usr.pops.pop_array[i]].culture);
						}
					}
					
					var culture_exists = [false, ""];
					
					//Soft match first
					for (var i = 0; i < all_cultures.length; i++) {
						if (all_cultures[i].toLowerCase().indexOf(arg1_culture.toLowerCase()) != -1) {
							culture_exists = [true, all_cultures[i]];
						}
					}
					//Hard match second
					for (var i = 0; i < all_cultures.length; i++) {
						if (all_cultures[i].toLowerCase() == arg1_culture.toLowerCase()) {
							culture_exists = [true, all_cultures[i]];
						}
					}
					
					if (culture_exists[0]) {
						var culture_is_already_accepted = false;
						
						for (var i = 0; i < usr.accepted_cultures.length; i++) {
							if (usr.accepted_cultures[i] == culture_exists[1]) {
								culture_is_already_accepted = true;
							}
						}
						
						if (culture_is_already_accepted == false) {
							//Check for Political Capital costs
							
							if (usr.political_capital >= config.accepted_culture_cost) {
								usr.political_capital = usr.political_capital - config.accepted_culture_cost;
								
								//[turns, culture]
								usr.cultural_integrations.push([config.integration_turns, culture_exists[1]]);
								msg.channel.send("You have begun to integrate the **" + culture_exists[1] + "** culture into your nation's societal fabric. Your analysts estimate that this will take up to **" + config.integration_turns + "** turns.");
							} else {
								msg.channel.send("You need <:political_capital:716817688525275257> **" + (config.accepted_culture_cost-usr.political_capital) + "** more Political Capital to begin integrating an entire culture into your country.");
							}
						} else {
							msg.channel.send("The culture you have specified is already accepted in your country!");
						}
					} else {
						msg.channel.send("The culture you have specified could not be found in your nation! Type `" + bot_prefix + "culture` for a list of valid cultures that comprise the social fabric of your country.");
					}
				} else {
					msg.channel.send("You need a country before you can start assimilating other cultures into it!");
				}
			}
			
			function assimilate (arg0_user, arg1_province, arg2_culture, arg3_msg) {
				var msg = arg3_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var province_exists = [false, ""];
					
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						if (usr.pops.pop_array[i] == arg1_province) {
							province_exists = [true, usr.pops.pop_array[i]];
						}
					}
					
					if (province_exists[0]) {
						var is_accepted_culture = [false, ""];
						
						//Soft match
						for (var i = 0; i < usr.accepted_cultures.length; i++) {
							if (usr.accepted_cultures[i].toLowerCase().indexOf(arg2_culture.toLowerCase()) != -1) {
								is_accepted_culture = [true, usr.accepted_cultures[i]];
							}
						}
						//Hard match
						for (var i = 0; i < usr.accepted_cultures.length; i++) {
							if (usr.accepted_cultures[i].toLowerCase() == arg2_culture.toLowerCase()) {
								is_accepted_culture = [true, usr.accepted_cultures[i]];
							}
						}
						
						if (is_accepted_culture[0]) {
							//Check for assimilate_cost and assimilate_fiscal_cost
							if (usr.political_capital >= config.assimilate_cost) {
								if (usr.money >= config.assimilate_fiscal_cost) {
									//[turns, culture, province]
									usr.assimilations.push([config.assimilation_turns, is_accepted_culture[1], arg1_province]);
									usr.political_capital = usr.political_capital - config.assimilate_cost;
									usr.money = usr.money - config.assimilate_fiscal_cost;
									msg.channel.send("We have begun assimilating the province of **" + arg1_province + "** into our cultural fabric. Your advisor estimates that it will take up to **" + config.assimilation_turns + "** turns before the locals learn to embrace our culture.");
								} else {
									msg.channel.send("You don't have enough money to assimilate this province! You need **" + (config.assimilate_fiscal_cost-usr.money) + "** more to carry out this action.");
								}
							} else {
								msg.channel.send("You don't have enough Political Capital to assimilate this province! You need **" + (config.assimilate_cost-usr.political_capital) + "** more <:political_capital:716817688525275257> Political Capital to carry out this action.");
							}
						} else {
							msg.channel.send("You must choose a valid accepted culture to assimilate to! Try using your nation's primary culture. If you're not sure what that is, type `" + bot_prefix + "culture`.");
						}
					} else {
						msg.channel.send("You must type in a valid province ID within your nation's control!");
					}
				} else {
					msg.channel.send("You must have a country first before you can start assimilating others to your nation's culture!");
				}
			}
			
			function removeAcceptedCulture (arg0_user, arg1_culture, arg2_msg) {
				var msg = arg2_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var culture_exists = [false, ""];
					var all_cultures = [];
					
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						var culture_already_exists = false;
						
						if (all_cultures.length > 0) {
							for (var x = 0; x < all_cultures.length; x++) {
								if (all_cultures[x] == usr.pops[usr.pops.pop_array[i]].culture) {
									culture_already_exists = true;
								}
							}
						}
						
						if (culture_already_exists == false) {
							all_cultures.push(usr.pops[usr.pops.pop_array[i]].culture);
						}
					}
					
					//Soft match first
					for (var i = 0; i < all_cultures.length; i++) {
						if (all_cultures[i].toLowerCase().indexOf(arg1_culture.toLowerCase()) != -1) {
							culture_exists = [true, all_cultures[i]];
						}
					}
					//Hard match second
					for (var i = 0; i < all_cultures.length; i++) {
						if (all_cultures[i].toLowerCase() == arg1_culture.toLowerCase()) {
							culture_exists = [true, all_cultures[i]];
						}
					}
					
					if (culture_exists[0]) {
						var is_accepted_culture = false;
						
						for (var i = 0; i < usr.accepted_cultures.length; i++) {
							if (accepted_cultures[i] == culture_exists[1]) {
								is_accepted_culture = true;
							}
						}
						
						if (is_accepted_culture) {
							if (usr.culture == culture_exists[1]) {
								msg.channel.send("You cannot oppress your primary culture!");
							} else {
								for (var i = 0; i < usr.accepted_cultures.length; i++) {
									if (usr.accepted_cultures[i] == culture_exists[1]) {
										usr.accepted_cultures.splice(i, 1);
									}
								}
								
								msg.channel.send("We have begun oppressing the **" + culture_exists[1] + "** minority in our country, and as such they have been removed from the list of accepted cultures.");
							}
						} else {
							msg.channel.send("The culture you have specified is already not an accepted culture! Check `" + bot_prefix + "culture` for a list of accepted cultures.");
						}
					} else {
						msg.channel.send("The culture you have specified doesn't even exist in your country!");
					}
				} else {
					msg.channel.send("You must have a nation in order to begin oppressing minorities!");
				}
			}
			
			function renameCulture (arg0_user, arg1_name, arg2_msg) {
				var msg = arg2_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (arg1_name.indexOf("@everyone") == -1 && arg1_name.indexOf("@here") == -1) {
						if (arg1_name.length <= 25) {
							for (var i = 0; i < main.user_array.length; i++) {
								for (var x = 0; x < main.users[main.user_array[i]].pops.pop_array.length; x++) {
									if (main.users[main.user_array[i]].pops[main.users[main.user_array[i]].pops.pop_array[x]].culture == usr.culture) {
										main.users[main.user_array[i]].pops[main.users[main.user_array[i]].pops.pop_array[x]].culture = arg1_name;
									}
								}
								for (var x = 0; x < main.users[main.user_array[i]].accepted_cultures.length; x++) {
									if (main.users[main.user_array[i]].accepted_cultures[x] == usr.culture) {
										main.users[main.user_array[i]].accepted_cultures[x] = arg1_name;
									}
								}
							}
							usr.culture = arg1_name;
							
							msg.channel.send("You have successfully changed your culture name to **" + arg1_name + "**.");
						} else {
							msg.channel.send("Your culture name exceeded the maximum of 25 characters!");
						}
					} else {
						msg.channel.send("Stop trying to ping everyone! This is a warnable offence.");
					}
				} else {
					msg.channel.send("You must have a nation before being able to rename your culture!");
				}
			}
			
			function viewPops (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				var embed_pop_array = [];
				var local_arrays = [];
				
				//Check if user exists
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var total_array = [];
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						total_array.push(usr.pops.pop_array[i]);
					}
					
					if (usr.pops.pop_array.length > 0) {
						//Sort out cities first
						if (usr.cities.city_array.length > 0) {
							var city_array = [];
							var city_name_array = [];
							for (var i = 0; i < usr.cities.city_array.length; i++) {
								city_array.push(usr.cities[usr.cities.city_array[i]].province);
								city_name_array.push(usr.cities[usr.cities.city_array[i]].name);
							}
							for (var i = 0; i < city_array.length; i++) {
								var current_demographics = [];
								current_demographics.push("**" + city_name_array[i] + "**:");
								current_demographics.push(" - population: **" + parseNumber(usr.pops[city_array[i]].population) + "**");
								for (var x = 0; x < config.pop_array.length; x++) {
									current_demographics.push(" - " + config.pop_array[x] + ": " + parseNumber(usr.pops[city_array[i]][config.pop_array[x]]));
								}
								current_demographics.push(" - culture: " + usr.pops[city_array[i]].culture);
								//Check if culture is accepted. If not, add assimilate command.
								var culture_accepted = false;
								for (var x = 0; x < usr.accepted_cultures.length; x++) {
									if (usr.accepted_cultures[x] == usr.pops[city_array[i]].culture) {
										culture_accepted = true;
									}
								}
								//assimilations: [turns, culture, province]
								var is_assimilating = [false, 0, ""];
								if (usr.assimilations.length > 0) {
									for (var x = 0; x < usr.assimilations.length; x++) {
										if (usr.assimilations[x][2] == city_array[i]) {
											is_assimilating = [true, usr.assimilations[x][0], usr.assimilations[x][1]];
										}
									}
								}
								
								if (culture_accepted == false) {
									if (is_assimilating[0]) {
										current_demographics.push(" - This province is currently assimilating to the **" + is_assimilating[2] + "** culture. We expect assimilation to be complete in **" + is_assimilating[1] + "** more turns.");
									} else {
										current_demographics.push(" - `" + bot_prefix + "assimilate " + city_array[i] + "`");
									}
								}
								local_arrays.push(current_demographics);
								total_array.remove(city_array[i]);
							}
						}
						//Sort out the rest of the provinces
						for (var i = 0; i < total_array.length; i++) {
							var current_demographics = [];
							current_demographics.push("**Province " + total_array[i] + "**:");
							current_demographics.push(" - population: " + parseNumber(usr.pops[total_array[i]].population));
							for (var x = 0; x < config.pop_array.length; x++) {
								current_demographics.push(" - " + config.pop_array[x] + ": " + parseNumber(usr.pops[total_array[i]][config.pop_array[x]]));
							}
							current_demographics.push(" - culture: " + usr.pops[total_array[i]].culture);
							//Check if culture is accepted. If not, add assimilate command.
							var culture_accepted = false;
							for (var x = 0; x < usr.accepted_cultures.length; x++) {
								if (usr.accepted_cultures[x] == usr.pops[total_array[i]].culture) {
									culture_accepted = true;
								}
							}
							//assimilations: [turns, culture, province]
							var is_assimilating = [false, 0, ""];
							if (usr.assimilations.length > 0) {
								for (var x = 0; x < usr.assimilations.length; x++) {
									if (usr.assimilations[x][2] == city_array[i]) {
										is_assimilating = [true, usr.assimilations[x][0], usr.assimilations[x][1]];
									}
								}
							}
							
							if (culture_accepted == false) {
								if (is_assimilating[0]) {
									current_demographics.push(" - This province is currently assimilating to the **" + is_assimilating[2] + "** culture. We expect assimilation to be complete in **" + is_assimilating[1] + "** more turns.");
								} else {
									current_demographics.push(" - `" + bot_prefix + "assimilate " + total_array[i] + "`");
								}
							}
							local_arrays.push(current_demographics);
							total_array.remove(city_array[i]);
						}
						//Add provinces to array
						if (local_arrays.length > 5) {
							var temp_array_string = [];
							for (var i = 0; i < local_arrays.length; i++) {
								if (temp_array_string.length < 5) {
									temp_array_string.push(local_arrays[i].join("\n"));
								} else {
									const embed_pop = new Discord.MessageEmbed()
										.setColor('#a98ac7')
										.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setTitle('**Population Overview:\n------------------**\nPage ' + embed_pop_array.length + ' of ' + Math.ceil((local_arrays.length/5)-1) + '\n')
										.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setDescription(temp_array_string.join("\n"))
										.setTimestamp()
										.setFooter('To access this menu again, type ' + bot_prefix + 'pops.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
									embed_pop_array.push(embed_pop);
									temp_array_string = [];
									temp_array_string.push(local_arrays[i].join("\n"));
								}
											
								if (local_arrays.length > 5) {
									if (i == local_arrays.length-1) {
										const embed_pop = new Discord.MessageEmbed()
											.setColor('#a98ac7')
											.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
											.setTitle('**Population Overview:\n------------------**\nPage ' + embed_pop_array.length + ' of ' + Math.ceil((local_arrays.length/5)-1) + '\n')
											.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
											.setDescription(temp_array_string.join("\n"))
											.setTimestamp()
											.setFooter('To access this menu again, type ' + bot_prefix + 'pops view.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
										embed_pop_array.push(embed_pop);
										temp_array_string = [];
									}
								}
							}
							scrollMessage(msg, embed_pop_array);
						} else {
							var break_arrays = [];
							for (var i = 0; i < local_arrays.length; i++) {
								break_arrays.push(local_arrays[i].join("\n"));
							}
							const embed_pop = new Discord.MessageEmbed()
								.setColor('#a98ac7')
								.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setTitle('**Population Overview:\n------------------**\nPage ' + 1 + ' of ' + Math.ceil(local_arrays.length/10) + '\n')
								.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setDescription(break_arrays.join("\n"))
								.setTimestamp()
								.setFooter('To access this menu again, type ' + bot_prefix + 'pops view.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
							msg.channel.send(embed_pop);
						}
					} else {
						msg.channel.send("The user you have specified has a population of ... zero.");
					}
				} else {
					msg.channel.send("The user you have specified does not have a country!");
				}
			}
		}
		
		//Print commands
		{
			function printAllModifiers (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					//printNumber, parses numbers and rounds them
					function printNumber (arg0_number, arg1_mode) {
						if (arg1_mode == "inverse") {
							if (arg0_number < 1 || arg0_number == 1) {
								return "-" + Math.abs(Math.round((1-arg0_number)*100)) + "%";
							} else {
								return "+" + Math.abs(Math.round((1-arg0_number)*100)) + "%";
							}
						}
						if (arg1_mode != undefined) {
							if (arg1_mode.indexOf("percentile") != -1) {
								//Round to the nearest hundred
								var minus = 0;
								if (arg1_mode.indexOf("regular") != -1) {
									minus = 100;
								}
								var rounded_number = Math.round(arg0_number*100)-minus;
								
								if (rounded_number >= 0) {
									return "+" + rounded_number + "%";
								} else if (rounded_number < 0) {
									return rounded_number + "%";
								}
							}
						} else {
							if (arg0_number > 0) {
								return "+" + Math.round(arg0_number*100)/100;
							} else {
								return Math.round(arg0_number*100)/100;
							}
						}
					}
					
					var usr = main.users[arg0_user];
					
					var political_modifiers_array = [];
					var economic_modifiers_array = [];
					var military_modifiers_array = [];
					
					//Political
					political_modifiers_array.push("Administrative Efficiency: **" + printNumber(usr.modifiers.administrative_efficiency, "percentile") + "**");
					political_modifiers_array.push("Advisor Cost: **" + printNumber(usr.modifiers.advisor_cost, "inverse") + "**");
					political_modifiers_array.push("CB Generation Speed: **" + printNumber(usr.modifiers.cb_generation_speed, "percentile") + "**");
					political_modifiers_array.push("Centralisation: **" + printNumber(usr.modifiers.centralisation, "percentile") + "**");
					political_modifiers_array.push("Diplomatic Slots: **" + printNumber(usr.modifiers.starting_diplomatic_slots) + "**");
					political_modifiers_array.push("Infamy Loss: **" + printNumber(usr.modifiers.infamy_loss) + "**");
					political_modifiers_array.push("Influence Gain: **" + printNumber(usr.modifiers.influence_gain) + "**");
					political_modifiers_array.push("Jingoism: **" + printNumber(usr.modifiers.jingoism, "percentile") + "**");
					political_modifiers_array.push("Opinion Modifier: **" + printNumber(usr.modifiers.opinion_modifier) + "**");
					political_modifiers_array.push("Overextension: **" + printNumber(usr.modifiers.overextension, "percentile") + "**");
					political_modifiers_array.push("Stability: **" + printNumber(Math.round(usr.stability+usr.modifiers.stability_modifier*100)) + "%**");
					political_modifiers_array.push("Republicanism: **" + printNumber(usr.modifiers.republicanism, "percentile") + "**");
					political_modifiers_array.push("Ruling Party Support Gain: **" + printNumber(usr.modifiers.ruling_party_support/100, "percentile") + "**");
					political_modifiers_array.push("Political Capital Gain: **" + printNumber(usr.modifiers.political_capital_gain) + "**");
					political_modifiers_array.push("Prestige Gain: **" + printNumber(usr.modifiers.prestige_gain) + "**");
					
					//Economy
					economic_modifiers_array.push("Building Cost: **" + printNumber(usr.modifiers.building_cost, "inverse") + "**");
					economic_modifiers_array.push("Construction Speed: **" + printNumber(usr.modifiers.construction_speed, "inverse") + "**");
					economic_modifiers_array.push("Extra Building Slots: **" + printNumber(usr.modifiers.extra_building_slots) + "**");
					economic_modifiers_array.push("Isolation: **" + printNumber(usr.modifiers.isolation, "percentile") + "**");
					economic_modifiers_array.push("Production Efficiency: **" + printNumber(usr.modifiers.production_efficiency, "percentile regular") + "**");
					economic_modifiers_array.push("Research Efficiency: **" + printNumber(usr.modifiers.research_efficiency, "percentile") + "**");
					economic_modifiers_array.push("Research Slots: **" + printNumber(usr.modifiers.research_slots) + "**");
					economic_modifiers_array.push("RGO Throughput: **" + printNumber(usr.modifiers.rgo_throughput, "percentile") + "**");
					economic_modifiers_array.push("Shipment Capacity: **" + printNumber(usr.modifiers.shipment_capacity) + "**");
					economic_modifiers_array.push("Shipment Time: **" + printNumber(usr.modifiers.shipment_time, "inverse") + "**");
					economic_modifiers_array.push("Tax Efficiency: **" + printNumber(usr.modifiers.tax_efficiency, "percentile") + "**");
					economic_modifiers_array.push("---");
					economic_modifiers_array.push("");
					for (var i = 0; i < config.building_categories.length; i++) {
						economic_modifiers_array.push(config.building_categories[i].split("_").join(" ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + " Building Slots: **" + printNumber(usr.modifiers[config.building_categories[i] + "_building_slots"], "percentile regular") + "**");
					}
					for (var i = 0; i < config.materials.length; i++) {
						economic_modifiers_array.push(config.materials[i].split("_").join(" ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + " Gain: **" + printNumber(usr.modifiers[config.materials[i] + "_gain"], "percentile regular") + "**");
					}
					for (var i = 0; i < config.pop_array.length; i++) {
						economic_modifiers_array.push(config.pops[config.pop_array[i]].name + " Growth Rate: **" + printNumber(usr.modifiers[config.pop_array[i] + "_growth_modifier"], "percentile regular") + "**");
					}
					
					//Military
					military_modifiers_array.push("Attrition Rate: **" + printNumber(usr.modifiers.attrition_rate, "inverse") + "**");
					military_modifiers_array.push("Army Professionalism: **" + printNumber(usr.modifiers.army_professionalism, "percentile regular") + "**");
					military_modifiers_array.push("Army Travel Speed: **" + printNumber(usr.modifiers.army_travel_speed, "inverse") + "**");
					military_modifiers_array.push("Army Upkeep: **" + printNumber(usr.modifiers.army_upkeep, "percentile regular") + "**");
					military_modifiers_array.push("Blockade Efficiency: **" + printNumber(usr.modifiers.blockade_efficiency, "percentile regular") + "**");
					military_modifiers_array.push("Casualty Reduction: **" + printNumber(usr.modifiers.casualty_reduction, "inverse") + "**");
					military_modifiers_array.push("Colonial Immigration Rate: **" + printNumber(usr.modifiers.colonial_immigration_rate, "percentile regular") + "**");
					military_modifiers_array.push("Colonial Maintenance: **" + printNumber(usr.modifiers.colonial_immigration_rate, "inverse") + "**");
					military_modifiers_array.push("Colonial Power Gain: **" + printNumber(usr.modifiers.colonial_power_gain, "percentile regular") + "**");
					military_modifiers_array.push("Colonial Power Cap: **" + printNumber(usr.modifiers.colonial_power_cap) + "**");
					military_modifiers_array.push("Colonist Travel Speed: **" + printNumber(usr.modifiers.colonist_travel_speed, "inverse") + "**");
					military_modifiers_array.push("Command Power Gain: **" + printNumber(usr.modifiers.command_power_gain) + "**");
					military_modifiers_array.push("National Manpower: **" + printNumber(usr.modifiers.national_manpower, "percentile regular") + "**");
					military_modifiers_array.push("Naval Professionalism: **" + printNumber(usr.modifiers.navy_professionalism, "percentile regular") + "**");
					military_modifiers_array.push("Non-Core Manpower: **" + printNumber(usr.modifiers.non_core_manpower, "percentile") + "**");
					military_modifiers_array.push("Maximum Expeditions: **" + printNumber(usr.modifiers.maximum_expeditions) + "**");
					military_modifiers_array.push("Mobilisation Size: **" + printNumber(usr.modifiers.mobilisation_size, "percentile regular") + "**");
					military_modifiers_array.push("Supply Consumption: **" + printNumber(usr.modifiers.supply_consumption, "inverse") + "**");
					military_modifiers_array.push("Training Cost: **" + printNumber(usr.modifiers.training_cost, "inverse") + "**");
					military_modifiers_array.push("War Exhaustion Rate: **" + printNumber(usr.modifiers.war_exhaustion_rate, "percentile regular") + "**");
					military_modifiers_array.push("---");
					military_modifiers_array.push("");
					military_modifiers_array.push("Air AP: **" + printNumber(usr.modifiers.aeroplanes_ap, "percentile regular") + "**");
					military_modifiers_array.push("Air DP: **" + printNumber(usr.modifiers.aeroplanes_dp, "percentile regular") + "**");
					military_modifiers_array.push("Armour AP: **" + printNumber(usr.modifiers.ground_vehicles_ap, "percentile regular") + "**");
					military_modifiers_array.push("Armour DP: **" + printNumber(usr.modifiers.ground_vehicles_dp, "percentile regular") + "**");
					military_modifiers_array.push("Artillery AP: **" + printNumber(usr.modifiers.ground_artillery_ap, "percentile regular") + "**");
					military_modifiers_array.push("Artillery DP: **" + printNumber(usr.modifiers.ground_artillery_dp, "percentile regular") + "**");
					military_modifiers_array.push("Infantry AP: **" + printNumber(usr.modifiers.ground_units_ap, "percentile regular") + "**");
					military_modifiers_array.push("Infantry DP: **" + printNumber(usr.modifiers.ground_units_dp, "percentile regular") + "**");
					military_modifiers_array.push("Naval AP: **" + printNumber(usr.modifiers.naval_units_ap, "percentile regular") + "**");
					military_modifiers_array.push("Naval DP: **" + printNumber(usr.modifiers.naval_units_dp, "percentile regular") + "**");
					
					const embed_political_modifiers = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Political Modifiers:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(political_modifiers_array.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'modifiers.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					const embed_economic_modifiers = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Economic Modifiers:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(economic_modifiers_array.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'modifiers.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					const embed_military_modifiers = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Military Modifiers:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(military_modifiers_array.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'modifiers.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					scrollMessage(msg, [embed_political_modifiers, embed_economic_modifiers, embed_military_modifiers], 0);
				} else {
					msg.channel.send("You need to have a nation first before being able to view your active modifiers!");
				}
			}
			
			function printBudget (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var budget_string = [];
					var minimum = 0;
					var maximum = 0;
					
					for (var i = 0; i < main.users[arg0_user].cities.city_array.length; i++) {
						var local_city = usr.cities[usr.cities.city_array[i]];
						for (var x = 0; x < config.buildings.length; x++) {
							if (config.building_stats[config.buildings[x]].produces != undefined) {
								for (var y = 0; y < config.building_stats[config.buildings[x]].produces.length; y++) {
									if (config.building_stats[config.buildings[x]].produces[y][1] == "actions") {
										if (Array.isArray(config.building_stats[config.buildings[x]].produces[y][0])) {
											minimum = minimum + config.building_stats[config.buildings[x]].produces[y][0][0]*local_city.buildings[config.buildings[x]];
											maximum = maximum + config.building_stats[config.buildings[x]].produces[y][0][1]*local_city.buildings[config.buildings[x]];
										} else {
											minimum = minimum + config.building_stats[config.buildings[x]].produces[y][0]*local_city.buildings[config.buildings[x]];
											maximum = maximum + config.building_stats[config.buildings[x]].produces[y][0]*local_city.buildings[config.buildings[x]];
										}
									}
								}
							}
						}
					}
					//user_id.money = user_id.money + Math.ceil((user_id.actions*config.money_per_action)*user_id.tax_rate*user_id.modifiers.tax_efficiency);
					
					var minimum_income = parseNumber(Math.ceil(((usr.actions+minimum)*config.money_per_action)*usr.tax_rate*usr.modifiers.tax_efficiency));
					var maximum_income = parseNumber(Math.ceil(((usr.actions+maximum)*config.money_per_action)*usr.tax_rate*usr.modifiers.tax_efficiency));
					
					budget_string.push("**Economic Statistics:**\n");
					budget_string.push("<:government:716817688693047306> Tax Efficiency: **" + Math.ceil(usr.modifiers.tax_efficiency*100) + "%**");
					budget_string.push("- <:aristocrats:732730754643132457> Aristocracy Modifier: **+" + Math.ceil((usr.aristocrats/100000)*config.pops.aristocrats.tax_efficiency_per_100k) + "%**");
					
					var tax_eff_from_temporary_modifiers = 0;
					for (var i = 0; i < usr.temporary_modifiers.length; i++) {
						if (usr.temporary_modifiers[i][0] == "tax_efficiency") {
							tax_eff_from_temporary_modifiers = tax_eff_from_temporary_modifiers + usr.temporary_modifiers[i][1];
						}
					}
					
					if (tax_eff_from_temporary_modifiers > 0) {
						budget_string.push("- <:building:716827579650408538> Tax Efficiency from temporary modifiers: **+" + tax_eff_from_temporary_modifiers + "%**");
					} else if (tax_eff_from_temporary_modifiers < 0) {
						budget_string.push("- <:cb:716828676855169107> Tax Efficiency from temporary modifiers: **-" + tax_eff_from_temporary_modifiers + "%**");
					}
					var city_production_prefix = "";
					var city_research_prefix = "";
					var city_stability_prefix = "";
					if (usr.city_production_modifier > 0) {
						city_production_prefix = "+";
					}
					if (usr.city_research_modifier > 0) {
						city_research_prefix = "+";
					}
					if (usr.city_stability_modifier > 0) {
						city_stability_prefix = "+";
					}
					budget_string.push("");
					budget_string.push("- **" + city_production_prefix + parseNumber(Math.round((usr.city_production_modifier)*100)) + "%** production efficiency from current territorial expansion.");
					budget_string.push("- **" + city_research_prefix + parseNumber(Math.round((usr.city_research_modifier)*100)) + "%** research efficiency from current territorial expansion.");
					budget_string.push("- **" + city_stability_prefix + parseNumber(Math.round((usr.city_stability_modifier)*100)) + "%** stability from current territorial expansion.");
					
					budget_string.push("");
					budget_string.push("<:actions:716817688244256770> **" + parseNumber(usr.actions) + "** Actions (**+" + parseNumber(minimum) + "**-**" + parseNumber(maximum) + "** per turn)");
					budget_string.push("**" + usr.civilian_actions_percentage*100 + "%** of your actions will be used up as <:trade:716828677115084812> **Civilian Goods** next turn.");
					budget_string.push("Your economic advisor estimates that you will gain <:money:716817688718213192> **" + minimum_income + "**-**" + maximum_income + "** next turn.");
					
					budget_string.push("------------------ \n**Economic Policy:**\n");
					budget_string.push("Current tax rate: (**" + Math.round(usr.tax_rate*100) + "%**/**" + usr.max_tax*100 + "%**) - Type `" + bot_prefix + "set-tax [number]` to adjust your tax rate.");
					if (usr.blockaded == false) {
						budget_string.push("");
						budget_string.push("<:blockade:716817688592252979> Blockade status: you are currently not blockaded.");
					} else {
						budget_string.push("<:blockade:716817688592252979> Blockade status: **You are currently under a blockade!**");
					}
					
					const embed_budget = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Budget:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(budget_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'budget.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					return embed_budget;
				} else {
					msg.channel.send("The user you have specified did not have a nation!");
				}
			}
			
			function printBuildings (arg0_user, arg1_username, arg2_msg) {
				var building_string = [];
				
				if (main.users[arg0_user] == undefined) {
					arg2_msg.channel.send("The person you are looking for is stateless!");
				} else {
					var usr = main.users[arg0_user];
					building_string.push("<:globe:716811246556545035> **Country:** " + main.users[arg0_user].name);
					building_string.push("------------------ \n <:development:716811992421367869> **Industry:**\n");
					building_string.push("The stats below do not include negative/positive modifiers related to production, only the base amount. Check `$economy` for a more accurate total assessment.");
					
					var building_count = 0;
					var building_cap = 0;
					var building_counts = {
					};
					
					for (var i = 0; i < main.users[arg0_user].cities.city_array.length; i++) {
						for (var x = 0; x < config.buildings.length; x++) {
							building_count = building_count + main.users[arg0_user]["cities"][main.users[arg0_user].cities.city_array[i]]["buildings"][config.buildings[x]];
							if (building_counts[config.buildings[x]] != undefined) {
								building_counts[config.buildings[x]] = building_counts[config.buildings[x]] + main.users[arg0_user]["cities"][main.users[arg0_user].cities.city_array[i]]["buildings"][config.buildings[x]];
							} else {
								building_counts[config.buildings[x]] = main.users[arg0_user]["cities"][main.users[arg0_user].cities.city_array[i]]["buildings"][config.buildings[x]];
							}
						}
						building_cap = building_cap + main.users[arg0_user]["cities"][main.users[arg0_user].cities.city_array[i]].building_cap;
					}
					
					var minimum = config.starting_actions;
					var maximum = config.starting_actions;
					
					for (var i = 0; i < config.buildings.length; i++) {
						if (building_counts[config.buildings[i]] != undefined && building_counts[config.buildings[i]] > 0) {
							var building_localisation_string = "";
							if (config.building_stats[config.buildings[i]].produces != undefined) {
								building_localisation_string = building_localisation_string + ", providing you with ";
								building_production_array = [];
								for (var x = 0; x < config.building_stats[config.buildings[i]].produces.length; x++) {
									var multiplier = 1;
									if (usr.modifiers[config.building_stats[config.buildings[i]].produces[x][1]] != undefined) {
										multiplier = usr.modifiers[config.building_stats[config.buildings[i]].produces[x][1]];
									}
									
									if (Array.isArray(config.building_stats[config.buildings[i]].produces[x][0])) {
										building_production_array.push(parseNumber(building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].produces[x][0][0]) + " - " + parseNumber(building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].produces[x][0][1]) + " " + config.building_stats[config.buildings[i]].produces[x][1]);
										
										if (config.building_stats[config.buildings[i]].produces[x][1] == "actions") {
											minimum = minimum + building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].produces[x][0][0]*multiplier;
											maximum = maximum + building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].produces[x][0][1]*multiplier;
										}
									} else {
										building_production_array.push(parseNumber(building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].produces[x][0]*multiplier) + " " + config.building_stats[config.buildings[i]].produces[x][1]);
										
										if (config.building_stats[config.buildings[i]].produces[x][1] == "actions") {
											minimum = minimum + building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].produces[x][0];
											maximum = maximum + building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].produces[x][0];
										}
									}
								}
								building_localisation_string = building_localisation_string + building_production_array.join(", ") + " every round.";
							} else if (config.building_stats[config.buildings[i]].cost_per_turn != undefined) {
								building_localisation_string = building_localisation_string + " These buildings also cost ";
								building_maintenance_array = [];
								for (var x = 0; x < config.building_stats[config.buildings[i]].cost_per_turn.length; x++) {
									var multiplier = 1;
									if (usr.modifiers[config.building_stats[config.buildings[i]].cost_per_turn[x][1]] != undefined) {
										multiplier = usr.modifiers[config.building_stats[config.buildings[i]].cost_per_turn[x][1]];
									}
									
									if (Array.isArray(config.building_stats[config.buildings[i]].cost_per_turn[x][0])) {
										building_maintenance_array.push(parseNumber(building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].cost_per_turn[x][0] + " - " + parseNumber(building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].cost_per_turn[x][1]) + " " + config.building_stats[config.buildings[i]].cost_per_turn[x][1]));
									} else {
										building_maintenance_array.push(parseNumber(building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].cost_per_turn[x][0] + " " + config.building_stats[config.buildings[i]].cost_per_turn[x][1]));
									}
								}
								building_localisation_string = building_localisation_string + " " + building_maintenance_array.join(", ") + " each turn.";
							}
							if (building_localisation_string != "") {
								building_string.push("You have **" + building_counts[config.buildings[i]] + "** " + config.buildings[i] + building_localisation_string);
							} else {
								building_string.push("You have **" + building_counts[config.buildings[i]] + "** " + config.buildings[i] + ".");
							}
						}
					}
					
					if (building_count == 0) {
						building_string.push("_You don't have any buildings in your cities._");
					}
					
					building_string.push("\n<:actions:716817688244256770> **Total Actions** per turn: " + minimum + "-" + maximum + " actions per round.");
					building_string.push("<:development:716811992421367869> **Building Cap:** (**" + building_count + "**/" + building_cap + ")\nThe building cap can be expanded by expanding your territory.");
					
					var temp_building_string = [];
					for (var i = 0; i < building_string.length; i++) {
						if (temp_building_string.length < 22) {
							temp_building_string.push(building_string[i]);
						} else {
							const embed_industry = new Discord.MessageEmbed()
								.setColor('#a98ac7')
								.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setTitle('**Economic Overview:\n------------------**')
								.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setDescription(temp_building_string.join("\n"))
								.setTimestamp()
								.setFooter('To access this menu again, type ' + bot_prefix + 'industry.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
							arg2_msg.channel.send(embed_industry);
							temp_building_string = [];
						}
						
						if (i == building_string.length-1) {
							const embed_industry = new Discord.MessageEmbed()
								.setColor('#a98ac7')
								.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setTitle('**Economic Overview:\n------------------**')
								.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setDescription(temp_building_string.join("\n"))
								.setTimestamp()
								.setFooter('To access this menu again, type ' + bot_prefix + 'industry.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
							arg2_msg.channel.send(embed_industry);
							temp_building_string = [];
						}
					}
				}
			}
			
			function printColonisation (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				var colonisation_string = [];
				
				//["conquistadors", turn_amount, [province_ids]]
				
				if (main.users[arg0_user] != undefined) {
					var user_id = main.users[arg0_user];
					
					colonisation_string.push("<:provinces:716809229603700737> **Capital Province:** " + main.users[arg0_user].capital_id);
					colonisation_string.push("<:colonisation:716821194891853826> **Maximum Expedition Limit:** " + user_id.modifiers.maximum_expeditions);
					colonisation_string.push("<:taxes:716817688781127810> **Colonisation Speed:** Your colonists can move at a rate of **" + parseNumber(config.colonisation_speed*user_id.modifiers.colonist_travel_speed) + "** provinces per turn.");
					colonisation_string.push("------------------\n**Available Colonial Units**:\n");
					var colonising_units = [];
					var total_units = 0;
					var provinces_can_colonise = 0;
					for (var i = 0; i < config.units.length; i++) {
						if (config.unit_stats[config.units[i]].colonise_provinces != undefined) {
							colonising_units.push(config.units[i]);
						}
					}
					
					for (var i = 0; i < colonising_units.length; i++) {
						total_units = total_units + user_id.military[colonising_units[i]];
						provinces_can_colonise = provinces_can_colonise + user_id.military[colonising_units[i]]*config.unit_stats[colonising_units[i]].colonise_provinces;
					}
					if (provinces_can_colonise == 0) {
						colonisation_string.push("_You don't have any units capable of colonising!_");
					} else {
						colonisation_string.push("You have **" + total_units + "** total units capable of colonising **" + provinces_can_colonise + "** province(s).");
						colonisation_string.push("Type `" + bot_prefix + "settle <prov 1> <prov 2> <...>` to use your colonisation units.");
						colonisation_string.push("");
						colonisation_string.push("Type `" + bot_prefix + "reserves` to view these units.");
					}
					
					colonisation_string.push("------------------\n**Expeditions**:\n");
					if (user_id.expeditions.length == 0) {
						colonisation_string.push("_You have no ongoing expeditions._");
					} else {
						var extra_expeditions = 0;
						for (var i = 0; i < user_id.expeditions.length; i++) {
							if (i < 8) {
								colonisation_string.push("<:old_map:716821884867444746> Charter #" + i + " - **" + user_id.expeditions[i][0] + "**:");
								//[["conquistadors",6,["194"]]]
								if (user_id.expeditions[i][1] >= 3) {
									colonisation_string.push(" - The **" + user_id.expeditions[i][0] + "** will arrive in **" + (user_id.expeditions[i][1]-2) + "** turns. `" + bot_prefix + "cancel-charter " + i + "`");
								} else {
									colonisation_string.push(" - The **" + user_id.expeditions[i][0] + "** have arrived! They have begun setting up a colony in the region, and your advisor estimates that it will take them **" + user_id.expeditions[i][1] + "** more turn(s).");
								}
								colonisation_string.push(" - They hope to colonise the province(s) of **" + user_id.expeditions[i][2].join(", ") + "**.");
							} else {
								extra_expeditions++;
							}
						}
						if (extra_expeditions > 0) {
							colonisation_string.push("+" + extra_expeditions + " more ...");
						}
					}
					
					const colonisation_embed = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Colonisation:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(colonisation_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'expeditions or ' + bot_prefix + 'colonisation.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					return colonisation_embed;
				} else {
					msg.channel.send("You don't even have a country yet!");
				}
			}
			
			function printDiplomacy (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var diplomacy_string = [];
					
					diplomacy_string.push("<:political_capital:716817688525275257> Political Capital: **" + parseNumber(usr.political_capital) + "**");
					var infamy_prefix = "";
					if (usr.modifiers.infamy_loss > 0) {
						infamy_prefix = "+";
					}
					diplomacy_string.push("<:infamy:716817688453709905> Infamy: **" + parseNumber(usr.infamy) + "** (" + infamy_prefix + Math.round(usr.modifiers.infamy_loss*100)/100 + " per turn)");
					
					//Check if user is at war
					if (usr.at_war.length > 0) {
						diplomacy_string.push("<:land_vehicles:716821195215077406> You are currently **at war** with " + usr.at_war.join(", ") + ".");
					} else {
						diplomacy_string.push("<:diplomacy:716827579323121666> _You are currently at peace._");
					}
					
					//Print ledger
					diplomacy_string.push("------------------\n**Diplomatic Overview:** For a full list, type `" + bot_prefix + "ledger`.");
					diplomacy_string.push("Type `" + bot_prefix + "diplomacy-view` to conduct diplomacy with another nation.");
					diplomacy_string.push("Type `" + bot_prefix + "cede-province` to cede one of your provinces to another nation.");
					diplomacy_string.push("");
					diplomacy_string.push("`Name  User ID  Provinces  Population`");
					diplomacy_string.push("");
					
					for (var i = 0; i < main.user_array.length; i++) { //Max. 20 list
						if (i < 20) {
							diplomacy_string.push("**" + main.users[main.user_array[i]].name + "**  " + main.user_array[i] + "  " + main.users[main.user_array[i]].provinces + "  " + parseNumber(main.users[main.user_array[i]].population));
						}
					}
					
					const embed_diplomacy = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Diplomatic Overview:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(diplomacy_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'diplomacy.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					return embed_diplomacy;
				} else {
					msg.channel.send("The user you have specified did not have a country!");
				}
			}
			
			function printEconomy (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var economy_string = [];
					
					economy_string.push("**Population:**\n");
					economy_string.push("<:workers:732730754735276124> Available Workers: **" + parseNumber(usr.workers-usr.used_workers) + "**");
					economy_string.push("- <:population:716817688810356826> Population Growth Rate: **" + parseNumber((usr.pop_growth_modifier-1)*100) + "%**");
					economy_string.push("**City List:** Type `" + bot_prefix + "city-list` to view all your cities.\nType `" + bot_prefix + "city <name>` to view a specific city.");
					
					var local_city_list = [];
					if (usr.cities.city_array.length > 0) {
						for (var i = 0; i < usr.cities.city_array.length; i++) {
							local_city_list.push("- " + usr.cities[usr.cities.city_array[i]].name + " - (<:development:716811992421367869> **" + usr.cities[usr.cities.city_array[i]].building_count + "**/" + usr.cities[usr.cities.city_array[i]].building_cap + ").");
						}
					}
					
					if (local_city_list.length > 0) {
						economy_string.push(local_city_list.join("\n"));
					} else {
						economy_string.push("_Your country has no cities._");
					}
					
					economy_string.push("------------------ \n**Production Modifiers:**\n");
					var local_resource_modifiers = {};
					var building_cost_prefix = "";
					if (usr.modifiers.building_cost > 1) {
						building_cost_prefix = "+";
					}
					for (var i = 0; i < config.materials.length; i++) {
						local_resource_modifiers[config.materials[i]] = (usr.modifiers[config.materials[i]]-1)*100;
					}
					for (var i = 0; i < usr.temporary_modifiers.length; i++) {
						for (var x = 0; x < config.materials.length; x++) {
							if (usr.temporary_modifiers[i][0] == config.materials[x]) {
								local_resource_modifiers[config.materials[x]] = local_resource_modifiers[config.materials[x]] + usr.temporary_modifiers[i][1];
							}
						}
					}
					if ((usr.modifiers.building_cost-1)*100 != 0) {
						economy_string.push("<:building:716827579650408538> Building Cost Modifier: **" + building_cost_prefix + parseNumber(((usr.modifiers.building_cost-1)*100)) + "%**");
					} else {
						economy_string.push("<:building:716827579650408538> No building cost modifiers active.");
					}
					for (var i = 0; i < config.materials.length; i++) {
						var processed_resource_name = config.materials[i].charAt(0).toUpperCase() + config.materials[i].slice(1);
						var resource_modifier_prefix = "";
						if (local_resource_modifiers[config.materials[i]] > 1) {
							resource_modifier_prefix = "+";
						}
						if (local_resource_modifiers[config.materials[i]] != 0) {
							economy_string.push(config.resource_icons[i] + " " + processed_resource_name + " Production Modifier: **" + resource_modifier_prefix + parseNumber(local_resource_modifiers[config.materials[i]]) + "%**");
						}
					}
					economy_string.push("------------------ \n**Resource Production:**\n");
					economy_string.push("Type `" + bot_prefix + "build list` in order to access a full list of buildings available for construction.");
					economy_string.push("Type `" + bot_prefix + "build [amount] <name> <city>` in order to construct buildings.");
					economy_string.push("");
					
					//Get production values per turn
					var local_production_array = {};
					for (var i = 0; i < config.materials.length; i++) {
						local_production_array[config.materials[i] + "_minimum"] = 0;
						local_production_array[config.materials[i] + "_maximum"] = 0;
					}
					for (var i = 0; i < usr.cities.city_array.length; i++) {
						for (var x = 0; x < config.buildings.length; x++) {
							var building_amount = usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
							if (config.building_stats[config.buildings[x]].produces != undefined) {
								for (var y = 0; y < config.building_stats[config.buildings[x]].produces.length; y++) {
									var is_material = false;
									var current_material = "";
									for (var z = 0; z < config.materials.length; z++) {
										if (config.building_stats[config.buildings[x]].produces[y][1] == config.materials[z]) {
											is_material = true;
											current_material = config.building_stats[config.buildings[x]].produces[y][1];
										}
									}
									if (is_material) {
										if (current_material == "knowledge") {
											if (Array.isArray(config.building_stats[config.buildings[x]].produces[y][0])) {
												local_production_array[current_material + "_minimum"] = Math.round(local_production_array[current_material + "_minimum"] + config.building_stats[config.buildings[x]].produces[y][0][0]*building_amount*usr.modifiers.research_efficiency);
												local_production_array[current_material + "_maximum"] = Math.round(local_production_array[current_material + "_maximum"] + config.building_stats[config.buildings[x]].produces[y][0][1]*building_amount*usr.modifiers.research_efficiency);
											} else {
												local_production_array[current_material + "_minimum"] = local_production_array[current_material + "_minimum"] + config.building_stats[config.buildings[x]].produces[y][0]*building_amount;
												local_production_array[current_material + "_maximum"] = local_production_array[current_material + "_maximum"] + config.building_stats[config.buildings[x]].produces[y][0]*building_amount;
											}
										} else {
											if (Array.isArray(config.building_stats[config.buildings[x]].produces[y][0])) {
												local_production_array[current_material + "_minimum"] = local_production_array[current_material + "_minimum"] + config.building_stats[config.buildings[x]].produces[y][0][0]*building_amount*usr.modifiers[current_material];
												local_production_array[current_material + "_maximum"] = local_production_array[current_material + "_maximum"] + config.building_stats[config.buildings[x]].produces[y][0][1]*building_amount*usr.modifiers[current_material];
											} else {
												local_production_array[current_material + "_minimum"] = local_production_array[current_material + "_minimum"] + config.building_stats[config.buildings[x]].produces[y][0]*building_amount*usr.modifiers[current_material];
												local_production_array[current_material + "_maximum"] = local_production_array[current_material + "_maximum"] + config.building_stats[config.buildings[x]].produces[y][0]*building_amount*usr.modifiers[current_material];
											}
										}
									}
								}
							}
							if (config.building_stats[config.buildings[x]].cost_per_turn != undefined) {
								for (var y = 0; y < config.building_stats[config.buildings[x]].cost_per_turn.length; y++) {
									var is_material = false;
									var current_material = "";
									for (var z = 0; z < config.materials.length; z++) {
										if (config.building_stats[config.buildings[x]].cost_per_turn[y][1] == config.materials[z]) {
											is_material = true;
											current_material = config.building_stats[config.buildings[x]].cost_per_turn[y][1];
										}
									}
									if (is_material) {
										if (Array.isArray(config.building_stats[config.buildings[x]].cost_per_turn[y][0])) {
											local_production_array[current_material + "_minimum"] = local_production_array[current_material + "_minimum"] - config.building_stats[config.buildings[x]].cost_per_turn[y][0][0]*building_amount;
											local_production_array[current_material + "_maximum"] = local_production_array[current_material + "_maximum"] - config.building_stats[config.buildings[x]].cost_per_turn[y][0][1]*building_amount;
										} else {
											local_production_array[current_material + "_minimum"] = local_production_array[current_material + "_minimum"] - config.building_stats[config.buildings[x]].cost_per_turn[y][0]*building_amount;
											local_production_array[current_material + "_maximum"] = local_production_array[current_material + "_maximum"] - config.building_stats[config.buildings[x]].cost_per_turn[y][0]*building_amount;
										}
									}
								}
							}
						}
					}
							
					var pop_knowledge_gain = 0;
						
					for (var i = 0; i < config.pop_array.length; i++) {
						if (config.pops[config.pop_array[i]].knowledge_per_100k != undefined) {
							pop_knowledge_gain = pop_knowledge_gain + Math.ceil(((usr[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].knowledge_per_100k));
						}
					}
							
					for (var i = 0; i < config.materials.length; i++) {
						var current_material = config.materials[i];
						
						if (current_material != "knowledge") {
							local_production_array[current_material + "_minimum"] = local_production_array[current_material + "_minimum"]*usr.modifiers.production_efficiency;
							local_production_array[current_material + "_maximum"] = local_production_array[current_material + "_maximum"]*usr.modifiers.production_efficiency;
						} else {
							local_production_array[current_material + "_minimum"] = local_production_array[current_material + "_minimum"]*usr.modifiers.research_efficiency;
							local_production_array[current_material + "_maximum"] = local_production_array[current_material + "_maximum"]*usr.modifiers.research_efficiency;
						}
					}
					
					local_production_array["knowledge_minimum"] = local_production_array["knowledge_minimum"] + pop_knowledge_gain;
					local_production_array["knowledge_maximum"] = local_production_array["knowledge_maximum"] + pop_knowledge_gain;
					
					//Add resource production to string
					for (var i = 0; i < config.materials.length; i++) {
						var local_resource_name = config.materials[i].charAt(0).toUpperCase() + config.materials[i].slice(1);
						if (local_production_array[config.materials[i] + "_minimum"] == local_production_array[config.materials[i] + "_maximum"]) {
							economy_string.push("- **" + parseNumber(local_production_array[config.materials[i] + "_minimum"]) + "** " + local_resource_name + " per turn.");
						} else if (local_production_array[config.materials[i] + "_maximum"] != local_production_array[config.materials[i] + "_minimum"]) {
							economy_string.push("- **" + parseNumber(local_production_array[config.materials[i] + "_minimum"]) + "** - **" + parseNumber(local_production_array[config.materials[i] + "_maximum"]) + "** " + local_resource_name + " per turn.");
						}
					}
					economy_string.push("");
					economy_string.push("For a complete list of resource production and buildings, type `" + bot_prefix + "industry`.");
					economy_string.push("To view your **current resources**, type `" + bot_prefix + "inventory`.");
					
					const embed_economy = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Economy:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(economy_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'economy.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					return embed_economy;
				} else {
					msg.channel.send("The user you have specified needs to have a country in order for this command to operate properly!");
				}
			}
			
			function printExports (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				//Fetch export list
				var export_list = [];
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					if (usr.trade_array.length > 0) {
						for (var i = 0; i < usr.trade_array.length; i++) {
							if (usr.trade_array[i][1] != arg0_user) {
								var export_amount = usr.trade_array[i][0][0];
								var export_type = usr.trade_array[i][0][1];
								var importer_name = main.users[usr.trade_array[i][1]].name;
								var time_remaining = usr.trade_array[i][2];
									
								var export_icon = "";
									
								for (var x = 0; x < config.materials.length; x++) {
									if (config.materials[x] == export_type) {
										export_icon = config.resource_icons[x];
									}
								}
									
								export_list.push("Exporting " + export_icon + " " + export_amount + " " + export_type + " to **" + importer_name + "**. The shipment will arrive in **" + time_remaining + "** turn(s).");
							}
						}
					}
						
					var export_embeds = [];
					var local_export_string = [];
						
					if (export_list.length > 0) {
						for (var i = 0; i < export_list.length; i++) {
							local_export_string.push(export_list[i]);
							if (i % 20 == 0 || i == usr.export_list.length-1) {
								const embed_exports = new Discord.MessageEmbed()
									.setColor('#a98ac7')
									.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
									.setTitle('**Exports:\n------------------**')
									.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
									.setDescription(local_export_string.join("\n"))
									.setTimestamp()
									.setFooter('To access this menu again, type ' + bot_prefix + 'exports.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
									
								export_embeds.push(embed_exports);
								local_export_string = [];
							}
						}
					} else {
						const embed_exports = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Exports:\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription("_You have no outgoing exports._")
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'exports.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
							
						export_embeds.push(embed_exports);
					}
						
					scrollMessage(msg, export_embeds, 0);
				} else {
					msg.channel.send("You must have a nation in order to be receiving exports!");
				}
			}
			
			function printImports (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				var import_list = [];
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]].trade_array.length > 0 && main.user_array[i] != arg0_user) {
							for (var x = 0; x < main.users[main.user_array[i]].trade_array.length; x++) {
								var import_amount = main.users[main.user_array[i]].trade_array[x][0][0];
								var import_type = main.users[main.user_array[i]].trade_array[x][0][1];
								var exporter_name = main.users[main.user_array[i]].name;
								var time_remaining = main.users[main.user_array[i]].trade_array[x][2];
									
								var import_icon = "";
									
								//Get import icon
								for (var y = 0; y < config.materials.length; y++) {
									if (config.materials[y] == import_type) {
										import_icon = config.resource_icons[y];
									}
								}
									
								//Check if user is exporting items to selected user
								if (main.users[main.user_array[i]].trade_array[x][1] == arg0_user) {
									//Add to string array
									import_list.push("Importing " + import_icon + " " + parseNumber(import_amount) + " " + import_type + " from " + "**" + exporter_name + "**.\nThe shipment will arrive in **" + time_remaining + "** turn(s).");
								}
							}
						}
					}
					
					var import_embeds = [];
					var local_import_string = [];
					
					if (import_list.length > 0) {
						for (var i = 0; i < import_list.length; i++) {
							local_import_string.push(import_list[i]);
							if (i % 20 == 0 || i == usr.import_list.length-1) {
								const embed_imports = new Discord.MessageEmbed()
									.setColor('#a98ac7')
									.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
									.setTitle('**Imports:\n------------------**')
									.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
									.setDescription(local_import_string.join("\n"))
									.setTimestamp()
									.setFooter('To access this menu again, type ' + bot_prefix + 'imports.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
									
									import_embeds.push(embed_imports);
									local_import_string = [];
								}
							}
						} else {
							const embed_imports = new Discord.MessageEmbed()
								.setColor('#a98ac7')
								.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setTitle('**Imports:\n------------------**')
								.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setDescription("_You have no incoming imports._")
								.setTimestamp()
								.setFooter('To access this menu again, type ' + bot_prefix + 'imports.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
								
							import_embeds.push(embed_imports);
						}
						
						scrollMessage(msg, import_embeds, 0);
				} else {
					msg.channel.send("You must have a nation in order to receive imports!");
				}
			}
			
			function printInterface (arg0_user, arg1_msg, arg2_position) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = arg0_user;
					var embed_array = [printStats(usr, msg), printBudget(usr, msg), printEconomy(usr, msg), printTechnology(usr, msg), printPolitics(usr, msg), printPopulation(usr, msg), printTrade(usr, msg), printDiplomacy(usr, msg), printColonisation(usr, msg), printMilitaryInterface(usr, msg)];
					
					//scrollMessage (arg0_msg, arg1_embeds, arg2_starting_page)
					
					if (arg2_position != undefined) {
						scrollMessage(msg, embed_array, arg2_position);
					} else {
						scrollMessage(msg, embed_array, 0);
					}
				} else {
					msg.channel.send("The user you have specified does not exist!");
				}
			}
			
			function printInv (arg0_user, arg1_username, arg2_msg) {
				var inv_string = [];
				
				if (main.users[arg0_user] == undefined) {
					arg2_msg.channel.send("The person you are looking for has no inventory!");
				} else {
					var usr = main.users[arg0_user];
					inv_string.push("<:trade:716828677115084812> **Materials:**\n------------------ \n");
					inv_string.push("<:money:716817688718213192> **money**: " + parseNumber(main.users[arg0_user].money));
					inv_string.push("");
					for (var i = 0; i < config.materials.length; i++) {
						if (main.users[arg0_user]["inventory"][config.materials[i]] != undefined) {
							if (config.materials[i] != "knowledge") {
								inv_string.push(config.resource_icons[i] + " **" + config.materials[i] + "**: " + parseNumber(main.users[arg0_user]["inventory"][config.materials[i]]));
							}
						}
					}
					inv_string.push("");
					inv_string.push("<:building:716827579650408538> **Crafting Points:**\n------------------ \n");
					inv_string.push("<:active_personnel:716820390474940426> Army CP: **" + usr.ground_units_cp + "**");
					inv_string.push("<:artillery:716821195055431681> Artillery CP: **" + usr.ground_artillery_cp + "**");
					inv_string.push("<:land_vehicles:716821195215077406> Armour CP: **" + usr.ground_vehicles_cp + "**");
					inv_string.push("<:naval_units:716821195277729832> Naval CP: **" + usr.naval_units_cp + "**");
					inv_string.push("<:aeroplanes:716821195407884358>Air CP: **" + usr.aeroplanes_cp + "**");
					
					const inventory_embed = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Inventory:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(inv_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'inventory.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					arg2_msg.channel.send(inventory_embed);
				}
			}
			
			function printMilitary (arg0_user, arg1_username, arg2_msg) {
				var military_string = [];
				
				if (main.users[arg0_user] == undefined) {	
					arg2_msg.channel.send("The person you are looking for has no country!");
				} else {
					var usr = main.users[arg0_user];
					var ap = 0;
					var dp = 0;
					
					military_string.push("<:globe:716811246556545035> Country: **" + main.users[arg0_user].name + "**");
					military_string.push("Type `" + bot_prefix + "create-army <name>` to create a new army.");
					military_string.push("------------------ \n<:manpower:716817688705499177> **Reserves:**");
					military_string.push("------------------ \n<:active_personnel:716820390474940426> **Ground Infantry:**\n");
					for (var i = 0; i < config.units.length; i++) {
						ap = ap + main.users[arg0_user]["military"][config.units[i]]*config.unit_stats[config.units[i]].ap;
						dp = dp + main.users[arg0_user]["military"][config.units[i]]*config.unit_stats[config.units[i]].dp;
					}
					var has_ground_units = false;
					for (var i = 0; i < config.ground_units.length; i++) {
						if (usr.military[config.ground_units[i]] > 0) {
							military_string.push("**" + config.ground_units[i] + "**: " + parseNumber(main.users[arg0_user]["military"][config.ground_units[i]]));
							has_ground_units = true;
						}
					}
					if (has_ground_units == false) {
						military_string.push("_No units in this category could be found._");
					}
					var has_artillery = false;
					military_string.push("------------------ \n<:artillery:716821195055431681> **Artillery:**\n");
					for (var i = 0; i < config.ground_artillery.length; i++) {
						if (usr.military[config.ground_artillery[i]] > 0) {
							military_string.push("**" + config.ground_artillery[i] + "**: " + parseNumber(main.users[arg0_user]["military"][config.ground_artillery[i]]));
							has_artillery = true;
						}
					}
					if (has_artillery == false) {
						military_string.push("_No units in this category could be found._");
					}
					var has_vehicles = false;
					military_string.push("------------------ \n<:land_vehicles:716821195215077406> **Land Vehicles:**\n");
					for (var i = 0; i < config.ground_vehicles.length; i++) {
						if (usr.military[config.ground_vehicles[i]] > 0) {
							military_string.push("**" + config.ground_vehicles[i] + "**: " + parseNumber(main.users[arg0_user]["military"][config.ground_vehicles[i]]));
							has_vehicles = true;
						}
					}
					if (has_vehicles == false) {
						military_string.push("_No units in this category could be found._");
					}
					var has_aeroplanes = false;
					military_string.push("------------------ \n<:aeroplanes:716821195407884358> **Aeroplanes:**\n");
					for (var i = 0; i < config.aeroplanes.length; i++) {
						if (usr.military[config.aeroplanes[i]] > 0) {
							military_string.push("**" + config.aeroplanes[i] + "**: " + parseNumber(main.users[arg0_user]["military"][config.aeroplanes[i]]));
							has_aeroplanes = true;
						}
					}
					if (has_aeroplanes == false) {
						military_string.push("_No units in this category could be found._");
					}
					var has_naval_units = false;
					military_string.push("------------------ \n<:naval_units:716821195277729832> **Naval Units:**\n");
					for (var i = 0; i < config.naval_units.length; i++) {
						if (usr.military[config.naval_units[i]] > 0) {
							military_string.push("**" + config.naval_units[i] + "**: " + parseNumber(main.users[arg0_user]["military"][config.naval_units[i]]));
							has_naval_units = true;
						}
					}
					if (has_naval_units == false) {
						military_string.push("_No units in this category could be found._");
					}
					var has_colonists = false;
					military_string.push("------------------ \n<:colonisation:716821194891853826> **Colonists:**\n");
					for (var i = 0; i < config.colonists.length; i++) {
						if (usr.military[config.colonists[i]] > 0) {
							military_string.push("**" + config.colonists[i] + "**: " + parseNumber(main.users[arg0_user]["military"][config.colonists[i]]));
							has_colonists = true;
						}
					}
					if (has_colonists == false) {
						military_string.push("_No units in this category could be found._");
					}
					military_string.push("------------------ \n<:money:716817688718213192> **Upkeep:**\n");
					military_string.push("**" + new Intl.NumberFormat('de', {style: 'decimal'}).format(Math.ceil((main.users[arg0_user].used_soldiers/100)*usr.modifiers.army_upkeep)) + "** will be spent on the military each turn.");
					military_string.push("");
					military_string.push("Total AP: `" + ap + "`  Total DP: `" + dp + "`.");
					
					const military_embed = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Reserves:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(military_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'reserves.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					arg2_msg.channel.send(military_embed);
				}
			}
			
			function printMilitaryInterface (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var military_interface_string = [];
					
					military_interface_string.push("**Wartime Status:**\n");
					if (usr.at_war.length > 0) {
						military_interface_string.push("We are engaged in a state of **war** with " + usr.at_war.join(", ") + ".");
					} else {
						military_interface_string.push("_We are currently at peace._");
					}
					
					military_interface_string.push("<:infamy:716817688453709905> War Exhaustion: **" + usr.modifiers.war_exhaustion + "%**");
					military_interface_string.push("");
					military_interface_string.push("<:active_personnel:716820390474940426> Army CP: **" + usr.ground_units_cp + "**");
					military_interface_string.push("<:artillery:716821195055431681> Artillery CP: **" + usr.ground_units_cp + "**");
					military_interface_string.push("<:land_vehicles:716821195215077406> Armour CP: **" + usr.ground_units_cp + "**");
					military_interface_string.push("<:naval_units:716821195277729832> Naval CP: **" + usr.ground_units_cp + "**");
					military_interface_string.push("<:aeroplanes:716821195407884358>Air CP: **" + usr.ground_units_cp + "**");
					military_interface_string.push("");
					military_interface_string.push("------------------\n**Reserves:** For a full overview, type `" + bot_prefix + "reserves`.\n");
					military_interface_string.push("To begin training units, type `" + bot_prefix + "craft list`.");
					
					var reserves_ap = 0;
					var reserves_dp = 0;
					
					for (var i = 0; i < config.units.length; i++) {
						reserves_ap = reserves_ap + config.unit_stats[config.units[i]].ap*usr.military[config.units[i]];
						reserves_dp = reserves_dp + config.unit_stats[config.units[i]].dp*usr.military[config.units[i]];
					}
					
					military_interface_string.push("Reserves AP: `" + parseNumber(reserves_ap) + "`  DP: `" + parseNumber(reserves_dp) + "`.");
					military_interface_string.push("------------------\n**Army List:** `" + bot_prefix + "army-list`");
					
					var armies_string = [];
					for (var i = 0; i < usr.armies.army_array.length; i++) {
						if (usr.armies[usr.armies.army_array[i]].name != "deleted_army") {
							var icon = "";
							if (usr.armies[usr.armies.army_array[i]].type == "army") {
								icon = "<:active_personnel:716820390474940426> ";
							} else if (usr.armies[usr.armies.army_array[i]].type == "navy") {
								icon = "<:naval_units:716821195277729832> ";
							} else if (usr.armies[usr.armies.army_array[i]].type == "air force") {
								con = "<:aeroplanes:716821195407884358> ";
							}
						}
						armies_string.push(" - " + icon + "**" + usr.armies[usr.armies.army_array[i]].name + "** (" + usr.armies[usr.armies.army_array[i]].state + ", Province #**" + usr.armies[usr.armies.army_array[i]].province + "**).");
					}
					
					if (armies_string.length > 0) {
						military_interface_string.push(armies_string.join("\n"));
					} else {
						military_interface_string.push("_You currently have no armies in active service._");
					}
					military_interface_string.push("------------------\n**Mobilisation:**\n");
					
					if (usr.enable_mobilisation) {
						if (usr.mobilised_manpower[0] == 0) {
							if (main.roundCount-usr.last_mobilised > config.mobilisation_cooldown) {
								var manpower_mobilised = Math.ceil((usr.workers-usr.used_workers)*0.5);
								military_interface_string.push("You can mobilise! Type `" + bot_prefix + "mobilise` in order to call upon your people to take up arms.");
								military_interface_string.push(parseNumber(manpower_mobilised) + " " + usr.mobilise_unit + " will be placed in your reserves.");
							} else {
								military_interface_string.push("Your people have demobilised too recently to be willing to be called up for war again. Wait for **" + parseNumber(config.mobilisation_cooldown-(main.roundCount-usr.last_mobilised)) + "** more turns.");
							}
						} else {
							military_interface_string.push("You are currently mobilised. Type `" + bot_prefix + "demobilise` in order to lay down your arms.");
						}
					} else {
						military_interface_string.push("Military mobilisation is currently locked, as your people haven't heard of the concept yet.");
					}
					
					const embed_military = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Military:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(military_interface_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'military.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					return embed_military;
				} else {
					msg.channel.send("You don't even have a nation!");
				}
			}
			
			function printLedger (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				var ledger_array = [];
				
				if (main.users[arg0_user] != undefined) {
					var user_id = main.users[arg0_user];
					
					ledger_array.push("<:globe:716811246556545035> **Ledger:**\n------------------\n");
					for (var i = 0; i < main.user_array.length; i++) {
						ledger_array.push("**" + main.users[main.user_array[i]].name + "**: (ID: " + main.user_array[i] + ")");
						//ledger_array.push(" - **Technological Level:** " + main.users[main.user_array[i]].technology_level);
						ledger_array.push(" - **Government:** " + main.users[main.user_array[i]].government);
						ledger_array.push(" - **Population:** " + parseNumber(main.users[main.user_array[i]].population));
						ledger_array.push(" - **Army Size:** " + parseNumber(main.users[main.user_array[i]].used_soldiers));
						ledger_array.push(" - **Cities:** (" + main.users[main.user_array[i]].city_count + "/" + main.users[main.user_array[i]].city_cap + ")");
						ledger_array.push(" - **Provinces:** " + main.users[main.user_array[i]].provinces);
					}
					
					if (ledger_array.length > 42) {
						var temp_ledger_string = [];
						for (var i = 0; i < ledger_array.length; i++) {
							if (temp_ledger_string.length < 42) {
								temp_ledger_string.push(ledger_array[i]);
							} else {
								const ledger_embed = new Discord.MessageEmbed()
									.setColor('#a98ac7')
									.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
									.setTitle('**World Ledger:\n------------------**')
									.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
									.setDescription(temp_ledger_string.join("\n"))
									.setTimestamp()
									.setFooter('To access this menu again, type ' + bot_prefix + 'ledger.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
								msg.channel.send(ledger_embed);
								temp_ledger_string = [];
								temp_ledger_string.push(ledger_array[i]);
							}
										
							if (ledger_array.length > 42) {
								if (i == ledger_array.length-1) {
									const ledger_embed = new Discord.MessageEmbed()
										.setColor('#a98ac7')
										.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setTitle('**World Ledger:\n------------------**')
										.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setDescription(temp_ledger_string.join("\n"))
										.setTimestamp()
										.setFooter('To access this menu again, type ' + bot_prefix + 'ledger.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
									msg.channel.send(ledger_embed);
									temp_ledger_string = [];
								}
							}
						}
					} else {
						const ledger_embed = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**World Ledger:\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(ledger_array.join("\n"))
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'ledger.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						msg.channel.send(ledger_embed);
					}
				} else {
					arg1_msg.channel.send("You don't have a nation yet!");
				}
			}
			
			function printStats (arg0_user, arg2_msg) {
				var stats_string = [];
				var minimum = 0;
				var maximum = 0;
				
				for (var i = 0; i < main.users[arg0_user].cities.city_array.length; i++) {
					for (var x = 0; x < config.buildings.length; x++) {
						//console.log(config.building_stats[config.buildings[x]]);
						if (config.building_stats[config.buildings[x]].produces != undefined) {
							for (var y = 0; y < config.building_stats[config.buildings[x]].produces.length; y++) {
								if (config.building_stats[config.buildings[x]].produces[y][1] == "actions") {
									if (Array.isArray(config.building_stats[config.buildings[x]].produces[y][0])) {
										minimum = minimum + config.building_stats[config.buildings[x]].produces[y][0][0];
										maximum = maximum + config.building_stats[config.buildings[x]].produces[y][0][1];
									} else {
										minimum = minimum + config.building_stats[config.buildings[x]].produces[y][0];
										maximum = maximum + config.building_stats[config.buildings[x]].produces[y][0];
									}
								}
							}
						}
					}
				}
				
				if (main.users[arg0_user] == undefined) {
					arg2_msg.channel.send("The person you are looking for has no country!");
					
				} else {
					var usr = main.users[arg0_user];
					var percentage_manpower = Math.round((usr.manpower_percentage+(usr.modifiers.national_manpower-1))*100);
					
					stats_string.push("<:globe:716811246556545035> Country: **" + usr.name + "**  _" + usr.motto + "_");
					var prestige_prefix = "";
					if (usr.modifiers.prestige_gain >= 0) {
						prestige_prefix = "+";
					}
					stats_string.push("<:prestige:762428452636721202> Prestige: **" + parseNumber(usr.prestige) + "** (+" + usr.modifiers.prestige_gain + " per turn)");
					stats_string.push("");
					stats_string.push("Type `" + bot_prefix + "customisation` to view nation customisation options.");
					stats_string.push("------------------ \n**Population:**\n");
					//Get city list
					var name_array = [];
					var name_string = "";
					for (var i = 0; i < usr.cities.city_array.length; i++) {
						if (i == 0) {
							name_array.push("**" + usr.cities[usr.cities.city_array[i]].name + "**");
						} else {
							name_array.push(usr.cities[usr.cities.city_array[i]].name);
						}
					}
					if (name_array.length > 2) {
						name_array[name_array.length-1] = "and " + name_array[name_array.length-1];
						name_string = name_array.join(", ");
					} else if (name_array.length == 2) {
						name_array[name_array.length-1] = "and " + name_array[name_array.length-1];
						name_string = name_array.join(" ");
					} else if (name_array.length == 1) {
						name_string = name_array[0];
					}
					stats_string.push("<:development:716811992421367869> Cities: (**" + usr.city_count + "**/**" + main.users[arg0_user].city_cap + "**): " + name_string);
					stats_string.push("<:population:716817688810356826> Population: **" + parseNumber(usr.population) + "** (Requires <:food:716797746715033602> **" + Math.ceil(usr.population/1000000) + "** food per turn)");
					stats_string.push("<:workers:732730754735276124> Workers: (**" + parseNumber(Math.ceil(usr.used_workers)) + "**/**" + parseNumber(usr.workers) + "**) ");
					stats_string.push("<:soldiers:732730754592669702> Soldiers: (**" + parseNumber(usr.used_soldiers) + "**/**" + parseNumber(usr.soldiers*usr.manpower_percentage*usr.modifiers.national_manpower) + "**)  (**" + percentage_manpower + "%** Recruitable Population)");
					stats_string.push("------------------ \n**Economy:**\n");
					stats_string.push("<:technology:716812861514711040> Techs Researched: (**" + usr.techs_researched + "**/**" + config.valid_technologies.length + "**)");
					var last_turn_income_prefix = "";
					if (last_turn_income_prefix > 0) {
						last_turn_income_prefix = "+";
					}
					stats_string.push("<:money:716817688718213192> Money: **" + parseNumber(usr.money) + "**" + " (<:money:716817688718213192> **" + last_turn_income_prefix + parseNumber(Math.ceil(usr.last_turn_income)) + "** per turn).");
					stats_string.push("------------------ \n**Internal Politics:**\n");
					stats_string.push("<:government:716817688693047306> Government Type: **" + config.governments[usr.government].name[0].toLowerCase() + "**");
					stats_string.push("<:political_capital:716817688525275257> Political Capital: **" + usr.political_capital + "**");
					stats_string.push("");
					stats_string.push("<:infamy:716817688453709905> Infamy: **" + usr.infamy + "**");
					stats_string.push("------------------ \n**Actions:**\nActions can be used to `" + bot_prefix + "mine` or `" + bot_prefix + "chop`, which give you raw resources. **" + usr.civilian_actions_percentage*100 + "%** of your actions will be used up by civilians next turn.");
					stats_string.push("<:actions:716817688244256770> Actions: **" + usr.actions + "**");
					
					const embed_stats = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Nation Overview:\n------------------**')
						.setThumbnail(usr.flag)
						.setDescription(stats_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'overview.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					return embed_stats;
				}
			}
			
			function printPolitics (arg0_user, arg2_msg) {
				var politics_string = [];
				
				if (main.users[arg0_user] == undefined) {	
					arg2_msg.channel.send("The person you are looking for has no country!");
				} else {
					var usr = main.users[arg0_user];
					politics_string.push("**Ruling Government:**");
					politics_string.push("");
					politics_string.push("<:government:716817688693047306> Government Type: **" + main.users[arg0_user].government + "**");
					politics_string.push("<:political_capital:716817688525275257> Political Capital: **" + main.users[arg0_user].political_capital + "**");
					politics_string.push("");
					politics_string.push("`" + bot_prefix + "coup` - Coup your government to a chosen ideology for **150** <:political_capital:716817688525275257> Political Capital.");
					politics_string.push("------------------ \n**Political Parties:**\n`" + bot_prefix + "politics support` - Raise a party's popularity by **10%** for **50** <:political_capital:716817688525275257> Political Capital.");
					if (usr.available_reforms.length > 0) {
						politics_string.push("`" + bot_prefix + "reforms` - View available reforms that you can enact for **" + config.reform_cost + "** <:political_capital:716817688525275257> Political Capital.");
					} else {
						politics_string.push("Reforms are currently locked until additional related technologies are researched.");
					}
					politics_string.push("`" + bot_prefix + "culture` - View the cultural fabric of your nation.\n");
					var total_reform_desire_gain = usr.modifiers.reform_desire_gain;
					
					for (var i = 0; i < config.government_list.length; i++) {
						if (usr.politics[config.government_list[i]] > 0) {
							if (config.governments[config.government_list[i]].reform_desire != undefined) {
								total_reform_desire_gain = total_reform_desire_gain + config.governments[config.government_list[i]].reform_desire*(usr.politics[config.government_list[i]]/100);
							}
						}
					}
					
					if (total_reform_desire_gain > 0.15) {
						total_reform_desire_gain = 0.15;
					}
					
					var reform_desire_suffix = "";
					if (total_reform_desire_gain > 0) {
						reform_desire_suffix = "+";
					}
					
					if (usr.available_reforms.length > 0) {
						politics_string.push("<:consciousness:758424911852470293> Reform Desire: **" + (Math.round(usr.modifiers.reform_desire*100*100)/100) + "%** (" + reform_desire_suffix + (Math.round(total_reform_desire_gain*100*100)/100) + "% per turn). Pass reforms to lower **Reform Desire.**");
						politics_string.push("");
					}
					
					for (var i = 0; i < config.government_list.length; i++) {
						var discontented_stage = "";
						
						if (usr["modifiers"][config.government_list[i] + "_discontent"] < 0) {
							discontented_stage = "pleased";
						} else if (usr["modifiers"][config.government_list[i] + "_discontent"] >= 0 && usr["modifiers"][config.government_list[i] + "_discontent"] < 13) {
							discontented_stage = "satisfied";
						} else if (usr["modifiers"][config.government_list[i] + "_discontent"] >= 13 && usr["modifiers"][config.government_list[i] + "_discontent"] < 25) {
							discontented_stage = "dissatisfied";
						} else if (usr["modifiers"][config.government_list[i] + "_discontent"] >= 25 && usr["modifiers"][config.government_list[i] + "_discontent"] < 38) {
							discontented_stage = "discontented";
						} else if (usr["modifiers"][config.government_list[i] + "_discontent"] >= 38 && usr["modifiers"][config.government_list[i] + "_discontent"] < 50) {
							discontented_stage = "unhappy";
						} else if (usr["modifiers"][config.government_list[i] + "_discontent"] >= 50 && usr["modifiers"][config.government_list[i] + "_discontent"] < 75) {
							discontented_stage = "outraged";
						} else if (usr["modifiers"][config.government_list[i] + "_discontent"] >= 75 && usr["modifiers"][config.government_list[i] + "_discontent"] < 88) {
							discontented_stage = "repulsed";
						} else if (usr["modifiers"][config.government_list[i] + "_discontent"] >= 88 && usr["modifiers"][config.government_list[i] + "_discontent"] < 100) {
							discontented_stage = "disgusted";
						} else if (usr["modifiers"][config.government_list[i] + "_discontent"] >= 100) {
							discontented_stage = "ready to revolt";
						}
						
						if (usr["politics"][config.government_list[i]] > 0) {
							politics_string.push(usr["politics"][config.government_list[i]] + "% of your population identify as " + config.governments[config.government_list[i]].name[1].toLowerCase() + ". They are currently **" + discontented_stage + "** (" + Math.floor(usr["modifiers"][config.government_list[i] + "_discontent"]) + ") with the state of affairs in our nation.");
						}
					}
					
					politics_string.push("------------------ \n**Stability:**\n`" + bot_prefix + "stability raise` - Raise stability by **10%** for **75** <:political_capital:716817688525275257> Political Capital.\n");
					
					var tax_rate = usr.tax_rate;
					var ruling_party_popularity = usr["politics"][usr.government];
					
					var stab_government_modifier = 0;
					var stab_government_text = "";
					var stab_government_prefix = "";
					
					var age_modifier = 0;
					
					if (config.governments[usr.government].stability != undefined) {
						stab_government_modifier = config.governments[usr.government].stability;
					}
					if (stab_government_modifier > 0) {
						stab_government_text = "due to the current government being a " + usr.government + ".";
					} else {
						stab_government_text = "due to " + usr.government + "being in power.";
					}
					
					var calculated_stability = Math.ceil(25 + (ruling_party_popularity*0.75) + stab_government_modifier - Math.ceil(tax_rate*100) - Math.ceil(usr.provinces/5) + age_modifier + usr.stability_decay);
					
					politics_string.push("**+25%** base stability modifier.");
					politics_string.push("**+" + Math.ceil(ruling_party_popularity*0.75) + "%** from ruling party popularity.");
					
					//Tax rate
					if (tax_rate > 0) {
						politics_string.push("**-" + Math.round(Math.ceil(tax_rate*100)) + "%** from current tax rate.");
					}
					
					//Government type
					if (stab_government_modifier != 0) {
						politics_string.push("**" + stab_government_prefix + stab_government_modifier + "%** " + stab_government_text);
					}
					
					//Artificially boosted stability
					if (usr.stability_decay > 0) {
						politics_string.push("**+" + usr.stability_decay + "%** from boosted stability. (**-1%** per turn).");
					}
					
					//Province stability
					politics_string.push("**-" + Math.ceil(usr.provinces/5) + "%** from overextension.");
					
					politics_string.push("------------------ \n**Calculated Stability:**\n");
					politics_string.push("<:stability:716817688722407424> Calculated Stability: **" + Math.ceil(calculated_stability) + "%**");
					politics_string.push("<:stability:716817688722407424> Current Stability: **" + Math.ceil(usr.stability) + "%**");
					
					if (calculated_stability < 40) {
						politics_string.push("------------------");
						politics_string.push("You have a <:revolt:716819535964930149> **revolt risk** of **" + (40-calculated_stability) + "%**!");
					}
					
					const embed_politics = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Political Overview:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(politics_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'politics view.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					return embed_politics;
				}
			}
			
			function printPopulation (arg0_user, arg1_msg) { //Improve in future for better moddability
				var msg = arg1_msg;
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var population_string = [];
					var urban_pops = {};
					var rural_pops = {};
					var urban_pop_total = 0;
					var rural_pop_total = 0;
					var urban_pop_percentile = 0;
					var rural_pop_percentile = 0;
					
					var pop_tax_efficiency = 0;
					var pop_research_efficiency = 0;
					var pop_stability_gain = 0;
					var pop_knowledge_gain = 0;
					
					for (var i = 0; i < config.pop_array.length; i++) {
						urban_pops[config.pop_array[i]] = 0;
						rural_pops[config.pop_array[i]] = 0;
					}
					//Add pops from all cities
					for (var i = 0; i < usr.cities.city_array.length; i++) {
						for (var x = 0; x < config.pop_array.length; x++) {
							urban_pops[config.pop_array[x]] = urban_pops[config.pop_array[x]] + usr.pops[usr.cities[usr.cities.city_array[i]].province][config.pop_array[x]];
						}
					}
					for (var i = 0; i < config.pop_array.length; i++) {
						rural_pops[config.pop_array[i]] = usr[config.pop_array[i]] - urban_pops[config.pop_array[i]];
					}
					
					//Get percentile and total of rural and urban population
					for (var i = 0; i < config.pop_array.length; i++) {
						urban_pop_total = urban_pop_total + urban_pops[config.pop_array[i]];
						rural_pop_total = rural_pop_total + rural_pops[config.pop_array[i]];
					}
					urban_pop_percentile = Math.floor((urban_pop_total/usr.population)*100);
					rural_pop_percentile = Math.floor((rural_pop_total/usr.population)*100);
					
					//Get population bonuses
					for (var i = 0; i < config.pop_array.length; i++) {
						if (config.pops[config.pop_array[i]].tax_efficiency_per_100k != undefined) {
							pop_tax_efficiency = Math.ceil(((usr[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].tax_efficiency_per_100k)*100);
						}
						if (config.pops[config.pop_array[i]].stability_per_100k != undefined) {
							pop_stability_gain = Math.ceil(((usr[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].stability_per_100k)*100);
						}
						if (config.pops[config.pop_array[i]].research_efficiency_per_100k != undefined) {
							pop_research_efficiency = Math.ceil(((usr[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].research_efficiency_per_100k)*100);
						}
						if (config.pops[config.pop_array[i]].knowledge_per_100k != undefined) {
							pop_knowledge_gain = Math.ceil(((usr[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].knowledge_per_100k));
						}
					}
					
					//Begin adding to string
					population_string.push("**Urban population:** `" + bot_prefix + "pops view`\n");
					population_string.push("<:development:716811992421367869> Urban Population: **" + urban_pop_percentile + "%**");
					population_string.push("- <:aristocrats:732730754643132457> Aristocrats: **" + parseNumber(urban_pops.aristocrats) + "**");
					population_string.push("- <:faculty:732730754911436830> Faculty: **" + parseNumber(urban_pops.faculty) + "**");
					population_string.push("- <:soldiers:732730754592669702> Soldiers: **" + parseNumber(urban_pops.soldiers) + "**");
					population_string.push("- <:workers:732730754735276124> Workers: **" + parseNumber(urban_pops.workers) + "**");
					population_string.push("");
					if (usr.city_count < usr.city_cap) {
						population_string.push("You can found up to **" + (usr.city_cap-usr.city_count) + "** more cities for more pops!");
					}
					population_string.push("------------------ \n**Rural Population:**\n");
					population_string.push("<:provinces:716809229603700737> Rural Population: **" + rural_pop_percentile + "%**");
					population_string.push("- <:aristocrats:732730754643132457> Aristocrats: **" + parseNumber(rural_pops.aristocrats) + "**");
					population_string.push("- <:faculty:732730754911436830> Faculty: **" + parseNumber(rural_pops.faculty) + "**");
					population_string.push("- <:soldiers:732730754592669702> Soldiers: **" + parseNumber(rural_pops.soldiers) + "**");
					population_string.push("- <:workers:732730754735276124> Workers: **" + parseNumber(rural_pops.workers) + "**");
					population_string.push("------------------ \n**Total Population:**\n");
					population_string.push("- <:aristocrats:732730754643132457> Total Aristocrats: **" + parseNumber(usr.aristocrats) + "**");
					population_string.push("- <:faculty:732730754911436830> Total Faculty: **" + parseNumber(usr.faculty) + "**");
					population_string.push("- <:soldiers:732730754592669702> Available Soldiers: **" + parseNumber(usr.soldiers*usr.modifiers.national_manpower*usr.manpower_percentage) + "**");
					population_string.push("- <:workers:732730754735276124> Available Workers: **" + parseNumber(usr.workers-usr.used_workers) + "**");
					population_string.push("------------------ \n**Population Modifiers:**\n");
					if (pop_tax_efficiency > 0) {
						population_string.push("- **" + pop_tax_efficiency + "%** tax efficiency from **" + parseNumber(usr.aristocrats) + "** aristocrats.");
					}
					if (pop_stability_gain > 0) {
						population_string.push("- **" + pop_stability_gain + "%** base stability from **" + parseNumber(usr.aristocrats) + "** aristocrats.");
					}
					if (pop_research_efficiency > 0) {
						population_string.push("- **" + pop_research_efficiency + "%** research efficiency from **" + parseNumber(usr.faculty) + "** scientists and faculty.");
					}
					if (pop_knowledge_gain > 0) {
						population_string.push("- **+" + pop_knowledge_gain + "** knowledge each turn from **" + parseNumber(usr.faculty) + "** scientists and faculty.");
					}
					population_string.push("");
					var pop_growth_modifiers = usr.pop_growth_modifier-1;
					var local_pop_growth_prefix = "";
					for (var i = 0; i < usr.temporary_modifiers.length; i++) {
						if (usr.temporary_modifiers[i][0] == "pop_growth_modifier") {
							pop_growth_modifiers = pop_growth_modifiers + usr.temporary_modifiers[i][1];
						}
					}
					if (pop_growth_modifiers > 0) {
						local_pop_growth_prefix = "+";
					}
					
					population_string.push("<:development:716811992421367869> Pop Growth Modifier: **" + local_pop_growth_prefix + Math.ceil(pop_growth_modifiers*100) + "%**");
					population_string.push("<:population:716817688810356826> Pop Growth Next Turn: **" + local_pop_growth_prefix + parseNumber(Math.ceil(usr.population*pop_growth_modifiers)) + "**");
					
					const embed_pops = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Population:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(population_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'pops.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					return embed_pops;
				} else {
					msg.channel.send("The user you have specified did not have a country!");
				}
			}
			
			function printTechnology (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var technology_string = [];
					
					technology_string.push("**Technological Advancement:**\n");
					technology_string.push("<:government:716817688693047306> Current Tech Count: (**" + usr.techs_researched + "**/" + parseNumber(config.valid_technologies.length) + ")");
					for (var i = 0; i < config.tech_categories.length; i++) {
						var category_research_progress = usr[config.tech_categories[i] + "_researched"];
						//Get tech count for category
						var category_tech_count = 0;
						for (var x = 0; x < config.valid_technologies.length; x++) {
							if (config.technology[config.valid_technologies[x]].category == config.tech_categories[i]) {
								category_tech_count++;
							}
						}
						
						technology_string.push(" - <:technology:716812861514711040> " + config.tech_categories[i].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + " Research Progress: (**" + category_research_progress + "**/" + category_tech_count + ")");
					}
					technology_string.push("");
					technology_string.push("<:knowledge:716797747193446441> Knowledge per turn: +**" + parseNumber(usr.knowledge_per_turn) + "**");
					
					var tech_array_dump = [];
					for (var i = 0; i < config.valid_technologies.length; i++) {
						var tech_available = false;
						
						if (config.technology[config.valid_technologies[i]].prerequisite_techs != undefined) {
							var prerequisite_checks = 0;
							for (var y = 0; y < config.technology[config.valid_technologies[i]].prerequisite_techs.length; y++) {
								for (var z = 0; z < usr.researched_technologies.length; z++) {
									if (config.technology[config.valid_technologies[i]].prerequisite_techs[y] == usr.researched_technologies[z]) {
										prerequisite_checks++;
									}
								}
							}
							
							if (prerequisite_checks == config.technology[config.valid_technologies[i]].prerequisite_techs.length) {
								tech_available = true;
							}
						} else { //No prerequisite checks found, so must be a starting tech
							tech_available = true;
						}
						
						//Check if user has already researched tech
						for (var y = 0; y < usr.researched_technologies.length; y++) {
							if (usr.researched_technologies[y] == config.valid_technologies[i]) {
								tech_available = false;
							}
						}
						
						//Append to valid tech dump for later categorisation
						if (tech_available) {
							tech_array_dump.push(config.valid_technologies[i]);
						}
					}
					
					technology_string.push("------------------ \n**Research Possibilities:** Type `" + bot_prefix + "research list` for a full list.\n");
					if (tech_array_dump.length > 0) {
						for (var i = 0; i < tech_array_dump.length; i++) {
							if (i <= 5) {
								var local_icon = "";
								var research_string = "";
								if (config.technology[tech_array_dump[i]].icon != undefined) {
									local_icon = config.technology[tech_array_dump[i]].icon + " ";
								}
								if (usr.researching.length < usr.modifiers.research_slots) {
									research_string = "\n`" + bot_prefix + "research " + tech_array_dump[i] + "`";
								}
								technology_string.push("- " + local_icon + "" + tech_array_dump[i].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + " (<:knowledge:716797747193446441> **" + config.technology[tech_array_dump[i]].research_cost + "**)" + research_string);
							}
						}
						if (tech_array_dump.length > 5) {
							technology_string.push("+" + parseNumber(tech_array_dump.length-5) + " more ...");
						}
					} else {
						technology_string.push("_No available techs could be found._");
					}
					technology_string.push("");
					technology_string.push("**Current Research:** `" + bot_prefix + "research`");
					technology_string.push("Type `" + bot_prefix + "research-queue` to queue up research.");
					technology_string.push("---");
					
					if (usr.researching.length > 0) {
						for (var i = 0; i < usr.researching.length; i++) {
							if (config.technology[usr.researching[i][1]].icon != undefined) {
								icon = config.technology[usr.researching[i][1]].icon + " ";
							}
							technology_string.push("`" + bot_prefix + "cancel-research " + i + "`");
							technology_string.push("Currently researching " + icon + "**" + usr.researching[i][1].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + "**.");
							technology_string.push("- Research Progress: **" + parseNumber(usr.researching[i][0]) + "/" + parseNumber(config.technology[usr.researching[i][1]].research_cost) + "** <:government:716817688693047306>.");
							technology_string.push("");
						}
					} else {
						technology_string.push("_You currently aren't researching anything!_");
					}
					
					const technology_embed = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Technology:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(technology_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'technology.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					return technology_embed;
				} else {
					msg.channel.send("The user you have specified did not have a valid country!");
				}
			}
			
			function printTrade (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var trade_string = [];
					
					trade_string.push("**Travel Modifiers:**");
					trade_string.push("");
					if (usr.blockaded) {
						trade_string.push("<:blockade:716817688592252979> **You are currently blockaded!**");
						trade_string.push("Being blockaded means you won't be able to ship or receive goods anymore. You can challenge this blockade by building up a naval fleet.");
					}
					trade_string.push("Base travel time: **" + parseNumber(Math.ceil(config.base_transfer_time*usr.modifiers.shipment_time)) + "** turns.");
					trade_string.push("Current travel speed: **" + parseNumber(Math.ceil(config.shipment_time/usr.modifiers.shipment_time)) + "** provinces a turn.");
					var local_static_prefix = "";
					if (usr.modifiers.shipment_time > 1) {
						local_static_prefix = "+";
					}
					if (usr.modifiers.shipment_time != 1) {
						trade_string.push("- Shipment Time Modifier: **" + local_static_prefix + Math.ceil((usr.modifiers.shipment_time-1)*100) + "%**.");
					}
					var local_dynamic_prefix = "";
					var local_temp_modifiers = 0;
					
					for (var i = 0; i < usr.temporary_modifiers.length; i++) {
						if (usr.temporary_modifiers[i][0] == "shipment_time") {
							local_temp_modifiers = local_temp_modifiers + usr.temporary_modifiers[i][1];
						}
					}
					
					if (local_temp_modifiers > 0) {
						local_dynamic_prefix = "+";
					}
					
					if (local_temp_modifiers != 0) {
						trade_string.push("- Shipment Time from temporary modifiers: **" + local_dynamic_prefix + Math.ceil((local_temp_modifiers)*100) + "%**.");
					}
					
					//Import/Export list
					trade_string.push("------------------ \n**Imports/Exports:**");
					trade_string.push("");
					if (usr.auto_trades.length > 0) {
						trade_string.push("You currently have **" + usr.auto_trades.length + "** ongoing auto-trades. In order to access them, type `" + bot_prefix + "auto-trades`.");
					} else {
						trade_string.push("_You currently have no ongoing auto-trades._ In order to access the Auto Trade UI, type `" + bot_prefix + "auto-trades`.");
					}
					trade_string.push("");
					//[[3, "iron"], "213287117017710593", 3]
					trade_string.push("<:taxes:716817688781127810> **Import List:** `" + bot_prefix + "list-imports`");
					
					var import_list = [];
					//Fetch import list, only print up to 10 imports
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]].trade_array.length > 0 && main.user_array[i] != arg0_user) {
							for (var x = 0; x < main.users[main.user_array[i]].trade_array.length; x++) {
								var import_amount = main.users[main.user_array[i]].trade_array[x][0][0];
								var import_type = main.users[main.user_array[i]].trade_array[x][0][1];
								var exporter_name = main.users[main.user_array[i]].name;
								var time_remaining = main.users[main.user_array[i]].trade_array[x][2];
								
								var import_icon = "";
								
								//Get import icon
								for (var y = 0; y < config.materials.length; y++) {
									if (config.materials[y] == import_type) {
										import_icon = config.resource_icons[y];
									}
								}
								
								//Check if user is exporting items to selected user
								if (main.users[main.user_array[i]].trade_array[x][1] == arg0_user) {
									//Add to string array
									import_list.push("Importing " + import_icon + " " + parseNumber(import_amount) + " " + import_type + " from " + "**" + exporter_name + "**.\nThe shipment will arrive in **" + time_remaining + "** turn(s).");
								}
							}
						}
					}
					
					if (import_list.length > 0) {
						trade_string.push("You currently have **" + import_list.length + "** imports in transfer.");
					} else {
						trade_string.push("_You have no incoming imports._");
					}
					
					trade_string.push("");
					trade_string.push("<:trade:716828677115084812> **Export List:** `" + bot_prefix + "list-exports`  `" + bot_prefix + "give <@user> [number] <item>`");
					
					//Fetch export list
					var export_list = [];
					
					if (usr.trade_array.length > 0) {
						trade_string.push("You currently have **" + export_list.length + "** exports in transfer.");
					} else {
						trade_string.push("_You have no outgoing exports._");
					}
					
					//World Market
					trade_string.push("");
					trade_string.push("------------------\n**World Market:**");
					trade_string.push("For more complete information on the World Market, type `" + bot_prefix + "buy list`.");
					trade_string.push("");
					
					//Enter entries
					for (var i = 0; i < config.resource_list.length; i++) {
						var local_resource_icon = "";
						for (var x = 0; x < config.materials.length; x++) {
							if (config.materials[x] == config.resource_list[i][0]) {
								local_resource_icon = config.resource_icons[x];
							}
						}
						var resource_price = main.users.global[config.resource_list[i][0] + "_buy_price"];
						var resource_stock = main.users.global[config.resource_list[i][0] + "_stock"];
						trade_string.push(local_resource_icon + " - " + parseNumber(resource_price) + " (**" + resource_stock + "**): `" + bot_prefix + "buy " + config.resource_list[i][0] + "`  `" + bot_prefix + "sell " + config.resource_list[i][0] + "`.");
					}
					
					const embed_trade = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Trade:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(trade_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'trade.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					return embed_trade;
				} else {
					msg.channel.send("The user you have specified did not have a country!");
				}
			}
			
			//Print lists
			{
				//Build List
				function printBuildList (arg0_user, arg1_msg) {
					var msg = arg1_msg;
					var build_list = [];
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						var user_id = main.users[arg0_user];
						
						build_list.push("<:government_scroll:716828975175041054> **Building List:**");
						build_list.push("------------------");
						
						//Use building_categories as a variable
						for (var i = 0; i < config.building_categories.length; i++) {
							var valid_buildings = 0;
							var valid_building_array = [];
							
							//Parse through all available buildings of the category
							for (var x = 0; x < config[config.building_categories[i]].length; x++) {
								//Get technology argument
								var tech_argument_found = false;
								var tech_level_needed = 1;
								console.log("[Triumph & Tragedy]: " + config[config.building_categories[i]][x] + " costs:");
								console.log("[Triumph & Tragedy]: " + config.building_stats[config[config.building_categories[i]][x]].costs);
								for (var y = 0; y < usr.available_buildings.length; y++) {
									if (usr.available_buildings[y] == config[config.building_categories[i]][x]) {
										tech_argument_found = true;
										//Push valid items and valid item array
										valid_buildings++;
										valid_building_array.push(config[config.building_categories[i]][x]);
									}
								}
							}
							
							//Append category header
							if (valid_buildings > 0) {
								//Parse category name
								var regular_category_name = config.building_categories[i];
								regular_category_name = regular_category_name.replace(/_/gm, " ");
								var split_category_name = regular_category_name.split(" ");
								for (var x = 0; x < split_category_name.length; x++) {
									split_category_name[x] = split_category_name[x].charAt(0).toUpperCase() + split_category_name[x].substring(1);
								}										
								
								//Return regular category name
								regular_category_name = split_category_name.join(" ");
								build_list.push("**" + regular_category_name + ":**");
								build_list.push("------------------");
								build_list.push("");
								
								for (var x = 0; x < valid_building_array.length; x++) {
									//Get building costs
									var costs_array = [];
									var costs_string = "";
									
									var manpower_cost = 0;
									var manpower_string = "";
									
									var building_stat_valid = false;
									var building_stat_string = "";
									
									//Production stuff
									var production_array = [];
									var maintenance_array = [];
									var has_production = false;
									var has_maintenance = false;
									
									var production_string = "";
									
									//Display
									var building_icon = "";
									var manpower_type = "";
									
									//Run through costs array
									for (var y = 0; y < config.building_stats[valid_building_array[x]].costs.length; y++) {
										//Parse debug name
										var resource_name = config.building_stats[valid_building_array[x]].costs[y][1];
										
										if (resource_name != "money" && resource_name != "manpower" && resource_name != "tech") {
											resource_name = resource_name.replace(/_/gm, " ");
											var split_resource_name = resource_name.split(" ");
											for (var z = 0; z < split_resource_name.length; z++) {
												split_resource_name[z] = split_resource_name[z].charAt(0).toUpperCase() + split_resource_name[z].substring(1);
											}
											
											costs_array.push(Math.ceil(config.building_stats[valid_building_array[x]].costs[y][0]*usr.modifiers.building_cost) + " " + split_resource_name.join(" "));
										} else if (resource_name == "money") {
											costs_array.push("" + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].costs[y][0]*usr.modifiers.building_cost)));
										}
										
										var pop_cost = false;
										for (var z = 0; z < config.pop_array.length; z++) {
											if (config.pop_array[z] == resource_name) {
												pop_cost = true;
												manpower_type = config.pop_array[z].charAt(0).toUpperCase() + config.pop_array[z].substring(1);
											}
										}
										if (pop_cost) {
											manpower_cost = manpower_cost + config.building_stats[valid_building_array[x]].costs[y][0];
											costs_array.pop();
										}
									}
									
									if (manpower_cost > 0) {
										manpower_string = "  " + parseNumber(manpower_cost) + " " + manpower_type;
									}
									
									//Get production string
									if (config.building_stats[valid_building_array[x]].produces != undefined) {
										has_production = true;
										for (var y = 0; y < config.building_stats[valid_building_array[x]].produces.length; y++) {
											
											//See if the building produces a random value of goods
											console.log("[Triumph & Tragedy]: " + user_id.modifiers.production_efficiency);
											if (Array.isArray(config.building_stats[valid_building_array[x]].produces[y][0])) {
												var resource_name = config.building_stats[valid_building_array[x]].produces[y][1];
												if (resource_name != "money" && resource_name != "manpower" && resource_name != "actions" && resource_name != "knowledge") {
													resource_name = resource_name.replace(/_/gm, " ");
													var split_resource_name = resource_name.split(" ");
													for (var z = 0; z < split_resource_name.length; z++) {
														split_resource_name[z] = split_resource_name[z].charAt(0).toUpperCase() + split_resource_name[z].substring(1);
													}
													
													production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][0]*user_id.modifiers.production_efficiency*user_id.modifiers[config.building_stats[valid_building_array[x]].produces[y][1]])) + "-" + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][1]*user_id.modifiers.production_efficiency*user_id.modifiers[config.building_stats[valid_building_array[x]].produces[y][1]])) + split_resource_name.join(" "));
												} else if (resource_name == "money") {
													production_array.push("" + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][0]*user_id.modifiers.production_efficiency)) + " - " + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][1]*user_id.modifiers.production_efficiency)));
												} else if (resource_name == "actions") {
													production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][0]*user_id.modifiers.production_efficiency)) + "-" + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][1]*user_id.modifiers.production_efficiency)) + " Actions");
												} else if (resource_name == "knowledge") {
													production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][0]*user_id.modifiers.research_efficiency)) + "-" + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][1]*user_id.modifiers.research_efficiency)) + " Knowledge");
												}
											} else {
												var resource_name = config.building_stats[valid_building_array[x]].produces[y][1];
												
												if (resource_name != "money" && resource_name != "manpower" && resource_name != "actions" && resource_name != "knowledge" && resource_name.indexOf("_cp") == -1) {
													resource_name = resource_name.replace(/_/gm, " ");
													var split_resource_name = resource_name.split(" ");
													for (var z = 0; z < split_resource_name.length; z++) {
														split_resource_name[z] = split_resource_name[z].charAt(0).toUpperCase() + split_resource_name[z].substring(1);
													}
													console.log("[Triumph & Tragedy]: " + Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*user_id.modifiers[config.building_stats[valid_building_array[x]].produces[y][1]]*user_id.modifiers.production_efficiency));
													production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*user_id.modifiers[config.building_stats[valid_building_array[x]].produces[y][1]]*user_id.modifiers.production_efficiency)) + " " + split_resource_name.join(" "));
												} else if (resource_name == "money") {
													production_array.push("" + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*user_id.modifiers.production_efficiency)));
												} else if (resource_name == "actions") {
													production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*user_id.modifiers.production_efficiency)) + " Actions");
												}  else if (resource_name == "knowledge") {
													production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*user_id.modifiers.research_efficiency)) + " Knowledge");
												} else if (resource_name.indexOf("_cp") != -1) {
													if (resource_name == "ground_units_cp") {
														production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*user_id.modifiers.production_efficiency)) + " Army CP");
													} else if (resource_name == "ground_artillery_cp") {
														production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*user_id.modifiers.production_efficiency)) + " Artillery CP");
													} else if (resource_name == "ground_vehicles_cp") {
														production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*user_id.modifiers.production_efficiency)) + " Armour CP");
													} else if (resource_name == "naval_units_cp") {
														production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*user_id.modifiers.production_efficiency)) + " Naval CP");
													} else if (resource_name == "aeroplanes_cp") {
														production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*user_id.modifiers.production_efficiency)) + " Air CP");
													}
												}
											}
										}
									}
									
									//Get maintenance string
									if (config.building_stats[valid_building_array[x]].cost_per_turn != undefined) {
										has_maintenance = true;
										for (var y = 0; y < config.building_stats[valid_building_array[x]].cost_per_turn.length; y++) {
											
											//See if the building takes a random value of goods
											if (Array.isArray(config.building_stats[valid_building_array[x]].cost_per_turn[y][0])) {
												var resource_name = config.building_stats[valid_building_array[x]].cost_per_turn[y][1];
												
												if (resource_name != "money" && resource_name != "manpower" && resource_name != "actions") {
													resource_name = resource_name.replace(/_/gm, " ");
													var split_resource_name = resource_name.split(" ");
													for (var z = 0; z < split_resource_name.length; z++) {
														split_resource_name[z] = split_resource_name[z].charAt(0).toUpperCase() + split_resource_name[z].substring(1);
													}
													
													maintenance_array.push(config.building_stats[valid_building_array[x]].cost_per_turn[y][0][0] + "-" + config.building_stats[valid_building_array[x]].cost_per_turn[y][0][1] + split_resource_name.join(" "));
												} else if (resource_name == "money") {
													maintenance_array.push("" + parseNumber(config.building_stats[valid_building_array[x]].cost_per_turn[y][0][0]) + " - " + parseNumber(config.building_stats[valid_building_array[x]].cost_per_turn[y][0][1]));
												} else if (resource_name == "actions") {
													maintenance_array.push(parseNumber(config.building_stats[valid_building_array[x]].cost_per_turn[y][0][0]) + "-" + parseNumber(config.building_stats[valid_building_array[x]].cost_per_turn[y][0][1]) + " Actions");
												}
											} else {
												var resource_name = config.building_stats[valid_building_array[x]].cost_per_turn[y][1];
												
												if (resource_name != "money" && resource_name != "manpower" && resource_name != "actions") {
													resource_name = resource_name.replace(/_/gm, " ");
													var split_resource_name = resource_name.split(" ");
													for (var z = 0; z < split_resource_name.length; z++) {
														split_resource_name[z] = split_resource_name[z].charAt(0).toUpperCase() + split_resource_name[z].substring(1);
													}
													
													maintenance_array.push(config.building_stats[valid_building_array[x]].cost_per_turn[y][0] + " " + split_resource_name.join(" "));
												} else if (resource_name == "money") {
													maintenance_array.push("" + parseNumber(config.building_stats[valid_building_array[x]].cost_per_turn[y][0]));
												} else if (resource_name == "actions") {
													maintenance_array.push(parseNumber(config.building_stats[valid_building_array[x]].cost_per_turn[y][0]) + " Actions");
												}
											}
										}
									}
									
									//Entry logic
									if (has_maintenance && has_production) {
										production_string = "  Produces " + production_array.join(", ") + " from " + maintenance_array.join(", ");
									} else if (has_production) {
										production_string = "  Produces " + production_array.join(", ") + " per turn";
									} else if (has_maintenance) {
										production_string = "  Costs " + maintenance_array.join(", ") + " per turn";
									} else {
										//Custom localisation
										if (config.building_stats[valid_building_array[x]].description != undefined) {
											production_string = "  " + config.building_stats[valid_building_array[x]].description;
										}
									}
									
									if (config.building_stats[valid_building_array[x]].icon != undefined) {
										building_icon = config.building_stats[valid_building_array[x]].icon + " ";
									}
									
									//Manpower string
									if (manpower_cost > 0) {
										manpower_string = "  " + parseNumber(manpower_cost) + " " + manpower_type;
									}
									
									//Push items to array
									var entry_exists = false;
									var final_string = building_icon + "**" + valid_building_array[x] + "** - " + costs_array.join(", ") + manpower_string + production_string;
									
									//Test for duplicates
									for (var y = 0; y < build_list.length; y++) {
										if (build_list[y] == final_string) {
											entry_exists = true;
										}
									}
									
									if (entry_exists == false) {
										build_list.push(final_string);
									}
								}
								//Insert margin	
								build_list.push("");
							}
						}
						
						//Split up build_list array into multiple sections
						longMessage(arg1_msg, build_list);
					} else {
						msg.channel.send("You don't even have a country!");
					}
				}
				
				//Buy List
				function printBuyList (arg0_user, arg1_msg) {
					var msg = arg1_msg;
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						var market = main.users.global;
						var market_array = [];
						
						for (var i = 0; i < config.resource_list.length; i++) {
							var local_resource_name = config.resource_list[i][0];
							var resource_icon = "";
							//Iterate through resource icon array
							for (var x = 0; x < config.materials.length; x++) {
								if (config.materials[x] == config.resource_list[i][0]) {
									resource_icon = config.resource_icons[x];
								}
							}
							
							//[Icon] - Steel (**9** in stock): Buy Price: 3.500  Sell Price: 2.000
							//`+buy steel`  `+sell steel`
							
							market_array.push(resource_icon + " - " + local_resource_name + " (**" + parseNumber(market[local_resource_name + "_stock"]) + "** in stock): Buy Price: " + parseNumber(market[local_resource_name + "_buy_price"]) + "  Sell Price: " + parseNumber(market[local_resource_name + "_sell_price"]) + "\n`" + bot_prefix + "buy [number] " + local_resource_name + "`  `" + bot_prefix + "sell [number] " + local_resource_name + "`");
							market_array.push("");
						}
						
						market_array.push("_Our deals are always steals!_");
						
						const buy_list_embed = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**World Market:\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(market_array.join("\n"))
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'buy list.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
						msg.channel.send(buy_list_embed);
					} else {
						msg.channel.send("You must found a nation in order to participate in the World Market!");
					}
				}
				
				function printCBList (arg0_user, arg1_msg) {
					var msg = arg1_msg;
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						var cb_keys = Object.keys(config.casus_belli);
						var cb_list = [];
						
						//status_quo, install_government, cut_down_to_size, liberation, puppet, retake_cores, annexation
						
						cb_list.push("**Casus Belli:**");
						cb_list.push("------------------");
						cb_list.push("Notice: Status Quo includes war reparations.");
						cb_list.push("");
						
						for (var i = 0; i < cb_keys.length; i++) {
							var icon = "";
							var peace_demands = config.casus_belli[cb_keys[i]].peace_demands.join(", ");
							peace_demands = peace_demands.replace("status_quo", "Status Quo");
							peace_demands = peace_demands.replace("install_government", "Install Government");
							peace_demands = peace_demands.replace("cut_down_to_size", "Cut Down To Size");
							peace_demands = peace_demands.replace("liberation", "Liberation");
							peace_demands = peace_demands.replace("puppet", "Puppet");
							peace_demands = peace_demands.replace("retake_cores", "Retake Cores");
							peace_demands = peace_demands.replace("annexation", "Annexation");
							if (config.casus_belli[cb_keys[i]].icon != undefined) {
								icon = config.casus_belli[cb_keys[i]].icon + " ";
							}
							cb_list.push(icon + "**" + config.casus_belli[cb_keys[i]].name + ":**");
							cb_list.push("```css");
							cb_list.push("- Requirement: " + config.casus_belli[cb_keys[i]].description);
							cb_list.push("- Peace Demands: " + peace_demands + ".");
							cb_list.push("- Infamy: " + parseNumber(config.casus_belli[cb_keys[i]].infamy) + ".");
							cb_list.push("```");
						}
						
						longMessage(msg, cb_list, 35);
					} else {
						msg.channel.send("You must found a country with the `" + bot_prefix + "found` command in order to view this list!");
					}
				}
				
				//Craft List - oof size large
				function printCraftList (arg0_user, arg1_msg) {
					var msg = arg1_msg;
					var craft_recipe = [];
					
					if (main.users[arg0_user] != undefined) {
						//Only show the user crafting recipes relevant to his tech level.
						var usr = main.users[arg0_user];
						var user_id = usr;
						
						craft_recipe.push("<:building:716827579650408538>" + " **Crafting List:**");
						craft_recipe.push("------------------");
						for (var i = 0; i < config.unit_categories.length; i++) {
							var valid_items = 0;
							var valid_item_array = [];
							
							//Parse through all available unit categories
							for (var x = 0; x < config[config.unit_categories[i]].length; x++) {
								var valid_item = false;
								for (var y = 0; y < usr.available_units.length; y++) {
									if (usr.available_units[y] == config[config.unit_categories[i]][x]) {
										valid_item = true;
									}
								}
								if (usr.obsolete_units != undefined) {
									for (var y = 0; y < usr.obsolete_units.length; y++) {
										if (usr.obsolete_units[y] == config[config.unit_categories[i]][x]) {
											valid_item = false;
										}
									}
								}
								if (valid_item) {
									valid_items++;
									valid_item_array.push(config[config.unit_categories[i]][x]);
								}
							}
							
							console.log("[Triumph & Tragedy]: Valid Item Array (Craft List): " + valid_item_array);
							
							//Append category header
							if (valid_items > 0) {
								//Parse category name
								var regular_category_name = config.unit_categories[i];
								regular_category_name = regular_category_name.replace(/_/gm, " ");
								var split_category_name = regular_category_name.split(" ");
								for (var x = 0; x < split_category_name.length; x++) {
									split_category_name[x] = split_category_name[x].charAt(0).toUpperCase() + split_category_name[x].substring(1);
								}										
								
								//Return regular category name
								regular_category_name = split_category_name.join(" ");
								
								//Get quantities
								var quantity_array = [];
								
								for (var x = 0; x < config[config.unit_categories[i]].length; x++) {
									//Check if quantity already exists in array
									var quantity_exists = false;
									for (var y = 0; y < quantity_array.length; y++) {
										if (quantity_array[y] == parseNumber(config.unit_stats[config[config.unit_categories[i]][x]].quantity)) {
											quantity_exists = true;
										}
									}
									
									if (quantity_exists == false) {
										quantity_array.push(parseNumber(config.unit_stats[config[config.unit_categories[i]][x]].quantity));
									}
								}
								
								//Push results
								craft_recipe.push(config.unit_category_icons[i] + " **" + regular_category_name + ":** (x" + quantity_array.join(", ") + ")");
								craft_recipe.push("------------------");
								craft_recipe.push("");
							}
							
							//Append category items
							if (valid_items > 0) {
								//Loop through all category items
								for (var x = 0; x < valid_item_array.length; x++) {
									//Get item costs
									var costs_array = [];
									var costs_string = "";
									
									var manpower_cost = 0;
									var manpower_string = "";
									
									var unit_stat_valid = false;
									var unit_stat_string = "";
									
									for (var y = 0; y < config.unit_stats[valid_item_array[x]].costs.length; y++) {
										//Parse debug name
										var resource_name = config.unit_stats[valid_item_array[x]].costs[y][1];
										
										if (resource_name != "money" && resource_name != "manpower" && resource_name != "tech" && resource_name.indexOf("_cp") == -1) {
											resource_name = resource_name.replace(/_/gm, " ");
											var split_resource_name = resource_name.split(" ");
											for (var z = 0; z < split_resource_name.length; z++) {
												split_resource_name[z] = split_resource_name[z].charAt(0).toUpperCase() + split_resource_name[z].substring(1);
											}
											
											costs_array.push(Math.ceil(config.unit_stats[valid_item_array[x]].costs[y][0]*user_id.modifiers.unit_cost) + " " + split_resource_name.join(" "));
										} else if (resource_name == "money") {
											costs_array.push("" + parseInteger(config.unit_stats[valid_item_array[x]].costs[y][0]*user_id.modifiers.unit_cost));
										} else if (resource_name.indexOf("_cp") != -1) {
											if (resource_name == "ground_units_cp") {
												costs_array.push(parseInteger(config.unit_stats[valid_item_array[x]].costs[y][0]*user_id.modifiers.training_cost) + " Army CP");
											} else if (resource_name == "ground_artillery_cp") {
												costs_array.push(parseInteger(config.unit_stats[valid_item_array[x]].costs[y][0]*user_id.modifiers.training_cost) + " Artillery CP");
											} else if (resource_name == "ground_vehicles_cp") {
												costs_array.push(parseInteger(config.unit_stats[valid_item_array[x]].costs[y][0]*user_id.modifiers.training_cost) + " Armour CP");
											} else if (resource_name == "naval_units_cp") {
												costs_array.push(parseInteger(config.unit_stats[valid_item_array[x]].costs[y][0]*user_id.modifiers.training_cost) + " Naval CP");
											} else if (resource_name == "aeroplanes_cp") {
												costs_array.push(parseInteger(config.unit_stats[valid_item_array[x]].costs[y][0]*user_id.modifiers.training_cost) + " Air CP");
											}
										}
										
										var pop_cost = false;
										for (var z = 0; z < config.pop_array.length; z++) {
											if (resource_name == config.pop_array[z]) {
												pop_cost = true;
												costs_array.pop();
											}
										}
										if (pop_cost) {
											manpower_cost = config.unit_stats[valid_item_array[x]].costs[y][0];
										}
									}
									
									
									if (manpower_cost > 0) {
										manpower_string = "  " + parseInteger(manpower_cost) + " Manpower";
									}
									if (config.unit_stats[valid_item_array[x]].colonise_provinces != undefined) {
										manpower_string = "  " + parseInteger(manpower_cost) + " Manpower  Settles " + parseInteger(config.unit_stats[valid_item_array[x]].colonise_provinces);
										if (config.unit_stats[valid_item_array[x]].colonise_provinces > 1) {
											manpower_string = manpower_string + " Provinces";
										} else {
											manpower_string = manpower_string + " Province";
										}
									}
									//Push item to array
									craft_recipe.push("**" + valid_item_array[x] + "** - " + costs_array.join(", ") + manpower_string);
									
									//See if user stats are valid
									if (config.unit_stats[valid_item_array[x]].ap > 0 || config.unit_stats[valid_item_array[x]].dp > 0 || config.unit_stats[valid_item_array[x]].mp > 0 || config.unit_stats[valid_item_array[x]].ip > 0) {
										unit_stat_valid = true;
										var ap_modifier = 0;
										var dp_modifier = 0;
										
										var unit_category = "";
										for (var y = 0; y < config.unit_categories.length; y++) {
											for (var z = 0; z < config[config.unit_categories[y]].length; z++) {
												if (config[config.unit_categories[y]][z] == valid_item_array[x]) {
													unit_category = config.unit_categories[y];
												}
											}
										}
										
										ap_modifier = usr.modifiers[unit_category + "_ap"];
										dp_modifier = usr.modifiers[unit_category + "_dp"];
										
										unit_stat_string = parseInteger(Math.round(config.unit_stats[valid_item_array[x]].ap*ap_modifier)) + " AP - " + parseInteger(Math.round(config.unit_stats[valid_item_array[x]].dp*dp_modifier)) + " DP - " + parseInteger(config.unit_stats[valid_item_array[x]].mp) + " MP - " + parseInteger(config.unit_stats[valid_item_array[x]].ip) + " IP";
									}
									
									if (unit_stat_valid) {
										craft_recipe.push("`" + unit_stat_string + "`");
									}
								}
								
								craft_recipe.push("");
							}
						}
						
						//Split up craft_recipe array into multiple sections
						longMessage(arg1_msg, craft_recipe, 30);
					} else {
						msg.channel.send("You don't even have a country yet!");
					}
				}
			
				function printGovernmentList (arg0_user, arg1_msg) {
					var msg = arg1_msg;
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						var government_string = [];
						
						government_string.push("**Governments:**");
						government_string.push("------------------");
						government_string.push("Notice: Only governments relevant to you are being shown.");
						government_string.push("");
						
						for (var i = 0; i < usr.available_governments.length; i++) {
							var government = config.governments[usr.available_governments[i]];
							var icon = "";
							var description = "";
							var war_capability = "";
							var has_elections = "";
							if (config.governments[usr.available_governments[i]].icon != undefined) {
								icon = config.governments[usr.available_governments[i]].icon + " ";
							}
							if (config.governments[usr.available_governments[i]].description != undefined) {
								description = "  " + config.governments[usr.available_governments[i]].description;
							}
							if (config.governments[usr.available_governments[i]].can_justify_wars != undefined) {
								if (config.governments[usr.available_governments[i]].can_justify_wars) {
									war_capability = "- Capability to declare wars: Yes.";
								} else {
									war_capability = "- Capability to declare wars by vote only.";
								}
							}
							if (config.governments[usr.available_governments[i]].has_elections != undefined) {
								if (config.governments[usr.available_governments[i]].has_elections) {
									has_elections = "- Has Elections: Yes.";
								} else {
									has_elections = "- Has Elections: No.";
								}
							}
							
							government_string.push(icon + "**" + config.governments[usr.available_governments[i]].name[0] + ":**" + description);
							government_string.push("Type `" + bot_prefix + "government " + usr.available_governments[i] + "` to adopt this system of government.");
							government_string.push("");
							government_string.push("```css");
							government_string.push(war_capability);
							government_string.push(has_elections);
							government_string.push("- Maximum Manpower: " + parseNumber(government.maximum_manpower*100) + "%.");
							government_string.push("- Maximum Tax Rate: " + parseNumber(government.maximum_tax_rate*100) + "%.");
							government_string.push("- Civilian Actions: " + parseNumber(government.civilian_actions*100) + "%.");
							government_string.push("```");
							government_string.push("");
						}
						
						longMessage(msg, government_string, 100);
					} else {
						msg.channel.send("You must have a country in order to view this list!");
					}
				}
			}
		}
		
		//Technology commands
		{
			function addResearchQueue (arg0_user, arg1_name, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var tech_exists = [false, ""];
					//Soft match first
					for (var i = 0; i < config.valid_technologies.length; i++) {
						if (config.valid_technologies[i].toLowerCase().indexOf(arg1_name.toLowerCase()) != -1) {
							tech_exists = [true, config.valid_technologies[i]];
						}
					}
					//Hard match later
					for (var i = 0; i < config.valid_technologies.length; i++) {
						if (config.valid_technologies[i].toLowerCase() == arg1_name.toLowerCase()) {
							tech_exists = [true, config.valid_technologies[i]];
						}
					}
					
					if (tech_exists[0]) {
						var item_already_in_queue = false;
						
						if (usr.research_queue.length != 0) {
							for (var i = 0; i < usr.research_queue.length; i++) {
								if (usr.research_queue == tech_exists[1]) {
									item_already_in_queue = true;
								}
							}
						}
						
						if (usr.research_queue.length < 20) {
							if (item_already_in_queue == false) {
								usr.research_queue.push(tech_exists[1]);
								msg.channel.send("You have successfully added **" + tech_exists[1].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()).toLowerCase() + "** to your research queue. Type `" + bot_prefix + "research-queue` to check your current queue.");
							} else {
								msg.channel.send("This item has already been added to your queue! Type `" + bot_prefix + "research-queue` to check your current queue.");
							}
						} else {
							msg.channel.send("You have already hit your maximum queue limit! Consider freeing up space by typing `" + bot_prefix + "research-queue`.");
						}
					} else {
						msg.channel.send("The tech you have specified proved as elusive as perpetual motion!");
					}
				} else {
					msg.channel.send("You must have a country in order to add items to your research queue!");
				}
			}
			
			function cancelResearch (arg0_user, arg1_slot, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (usr.researching[arg1_slot] != undefined) {
						usr.researching.splice(arg1_slot, 1);
						msg.channel.send("You cancelled your current research for slot **" + parseInt(arg1_slot) + "**. Type `" + bot_prefix + "research list` for a valid list of research options.");
					} else {
						msg.channel.send("This research slot is either already empty, or you haven't defined the slot as a valid number!");
					}
				} else {
					msg.channel.send("You must have a nation before you're able to even conduct research in the first place!");
				}
			}
			
			function printTechList (arg0_user, arg1_message) {
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var msg = arg1_message;
					var tech_list_array = [];
					
					var tech_array_dump = [];
					var tech_category_techs_available = [];
					
					for (var i = 0; i < config.valid_technologies.length; i++) {
						var tech_available = false;
						
						if (config.technology[config.valid_technologies[i]].prerequisite_techs != undefined) {
							var prerequisite_checks = 0;
							for (var y = 0; y < config.technology[config.valid_technologies[i]].prerequisite_techs.length; y++) {
								for (var z = 0; z < usr.researched_technologies.length; z++) {
									if (config.technology[config.valid_technologies[i]].prerequisite_techs[y] == usr.researched_technologies[z]) {
										prerequisite_checks++;
									}
								}
							}
							
							if (prerequisite_checks == config.technology[config.valid_technologies[i]].prerequisite_techs.length) {
								tech_available = true;
							}
						} else { //No prerequisite checks found, so must be a starting tech
							tech_available = true;
						}
						
						//Check if user has already researched tech
						for (var y = 0; y < usr.researched_technologies.length; y++) {
							if (usr.researched_technologies[y] == config.valid_technologies[i]) {
								tech_available = false;
							}
						}
						
						//Append to valid tech dump for later categorisation
						if (tech_available) {
							tech_array_dump.push(config.valid_technologies[i]);
						}
					}
					
					//Eliminate technological categories with no techs in them
					for (var i = 0; i < config.tech_categories.length; i++) {
						tech_category_techs_available.push(0);
						for (var x = 0; x < tech_array_dump.length; x++) {
							if (config.technology[tech_array_dump[x]].category == config.tech_categories[i]) {
								tech_category_techs_available[i]++;
							}
						}
					}
					
					//Begin assembling the tech array by getting all valid tech categories
					for (var i = 0; i < config.tech_categories.length; i++) {
						var processed_name = config.tech_categories[i].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase());
						if (tech_category_techs_available[i] > 0) {
							tech_list_array.push("<:technology:716812861514711040> **" + processed_name + "**:");
							tech_list_array.push("---");
							tech_list_array.push("");
						}
						
						for (var x = 0; x < tech_array_dump.length; x++) {
							if (config.technology[tech_array_dump[x]].category == config.tech_categories[i]) {
								var local_tech = config.technology[tech_array_dump[x]];
								var gfx_icon = "";
								var researching_status = "";
								
								if (usr.researching.length == 0) {
									researching_status = "`" + bot_prefix + "research " + tech_array_dump[x] + "`";
								}
								
								for (var y = 0; y < usr.researching.length; y++) {
									if (usr.researching[y][1] == tech_array_dump[x]) {
										researching_status = "__Researching__";
									} else {
										researching_status = "`" + bot_prefix + "research " + tech_array_dump[x] + "`";
									}
									
									if (usr.research_queue.length > 0) {
										for (var z = 0; z < usr.research_queue.length; z++) {
											if (usr.research_queue[z] == tech_array_dump[x]) {
												researching_status = "__Queued (#" + z + ")__";
											}
										}
									}
								}
								
								if (local_tech.icon != undefined) {
									gfx_icon = local_tech.icon + " ";
								}
								
								tech_list_array.push(gfx_icon + "**" + tech_array_dump[x].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + "**: " + researching_status);
								
								if (local_tech.description != undefined) {
									tech_list_array.push("");
									tech_list_array.push("_" + local_tech.description + "_");
									tech_list_array.push("");
								}
								
								tech_list_array.push("- **Cost:** <:knowledge:716797747193446441> " + local_tech.research_cost);
								
								tech_list_array.push("- **Effects:**");
								
								for (var y = 0; y < local_tech.modifiers.length; y++) {
									tech_list_array.push("      - " + local_tech.modifiers[y]);
								}
								
								//Leads to:
								var leads_to_array = [];
								for (var y = 0; y < config.valid_technologies.length; y++) {
									if (config.technology[config.valid_technologies[y]].prerequisite_techs != undefined) {
										if (config.technology[config.valid_technologies[y]].prerequisite_techs.indexOf(tech_array_dump[x]) != -1) {
											leads_to_array.push("_" + config.valid_technologies[y].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + "_");
										}
									}
								}
								
								if (leads_to_array.length > 0) {
									tech_list_array.push("- **Leads to: **" + leads_to_array.join(", "));
								}
								tech_list_array.push("");
							}
						}
						
						if (tech_category_techs_available[i] > 0) {
							tech_list_array.push("---");
							tech_list_array.push("");
						}
					}
					
					if (tech_list_array.length == 0) {
						tech_list_array.push("_You have researched all available technologies!_");
					}
					
					longMessage(msg, tech_list_array, 30);
				} else {
					arg1_message.channel.send("You need a country in order to be able to conduct research!");
				}
			}
			
			function printResearch (arg0_user, arg1_message) {
				var msg = arg1_message;
				var research_string = [];
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					if (usr.researching.length > 0) {
						var min_knowledge_per_turn = 0;
						var max_knowledge_per_turn = 0;
						var pop_knowledge_gain = 0;
						
						for (var i = 0; i < config.pop_array.length; i++) {
							if (config.pops[config.pop_array[i]].knowledge_per_100k != undefined) {
								pop_knowledge_gain = pop_knowledge_gain + Math.ceil(((usr[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].knowledge_per_100k));
							}
						}
								
						for (var i = 0; i < usr.cities.city_array.length; i++) {
							for (var x = 0; x < config.buildings.length; x++) {
								if (usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]] > 0) {
									var produces_knowledge = false;
									for (var y = 0; y < config.building_stats[config.buildings[x]].produces.length; y++) {
										if (config.building_stats[config.buildings[x]].produces[y][1] == "knowledge") {
											if (Array.isArray(config.building_stats[config.buildings[x]].produces[y][0])) {
												min_knowledge_per_turn = min_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0][0]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
												max_knowledge_per_turn = max_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0][1]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
											} else {
												min_knowledge_per_turn = min_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
												max_knowledge_per_turn = max_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
											}
										}
									}
								}
							}
						}
								
						console.log("Min Knowledge Per Turn: " + min_knowledge_per_turn);
								
						min_knowledge_per_turn = Math.ceil(min_knowledge_per_turn) + pop_knowledge_gain;
						max_knowledge_per_turn = Math.ceil(max_knowledge_per_turn) + pop_knowledge_gain;
								
						min_knowledge_per_turn = Math.ceil(min_knowledge_per_turn/(usr.researching.length));
						max_knowledge_per_turn = Math.ceil(max_knowledge_per_turn/(usr.researching.length));
						
						research_string.push("<:technology:716812861514711040> Research Slots: (**" + usr.researching.length + "**/" + usr.modifiers.research_slots + "):");
						research_string.push("To view your research queue, type `" + bot_prefix + "research-queue`.");
						research_string.push("");
						research_string.push("---");
						
						for (var i = 0; i < usr.researching.length; i++) {
							var turn_string = "";
							if (min_knowledge_per_turn == 0 && max_knowledge_per_turn == 0) {
								turn_string = "infinite**";
							} else if (min_knowledge_per_turn == max_knowledge_per_turn) {
								turn_string = parseNumber(Math.ceil((config.technology[usr.researching[i][1]].research_cost-usr.researching[i][0])/min_knowledge_per_turn)) + "** ";
							} else {
								turn_string = parseNumber(Math.ceil((config.technology[usr.researching[i][1]].research_cost-usr.researching[i][0])/min_knowledge_per_turn)) + " - " + parseNumber(Math.ceil((config.technology[usr.researching[i][1]].research_cost-usr.researching[i][0])/max_knowledge_per_turn)) + "** ";
							}
							
							var icon = "";
							
							if (config.technology[usr.researching[i][1]].icon != undefined) {
								icon = config.technology[usr.researching[i][1]].icon + " ";
							}
							
							research_string.push(icon + "**" + usr.researching[i][1].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + "**: `" + bot_prefix + "cancel-research " + i + "`");
							
							if (config.technology[usr.researching[i][1]].modifiers != undefined) {
								research_string.push("");
								research_string.push("**Effects:**");
								for (var x = 0; x < config.technology[usr.researching[i][1]].modifiers.length; x++) {
									research_string.push(" " + config.technology[usr.researching[i][1]].modifiers[x]);
								}
							}
							
							research_string.push("");
							research_string.push("You have invested **" + parseNumber(usr.researching[i][0]) + "/" + parseNumber(config.technology[usr.researching[i][1]].research_cost) + "** <:government:716817688693047306> Knowledge into this technology.");
							research_string.push("Your advisors estimate that it will take **" + turn_string + " turn(s) to finish researching this technology.");
							research_string.push("");
						}
					} else {
						research_string.push("_Nothing is currently being researched._");
					}
						
					const research_embed = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Research:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(research_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'research.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					msg.channel.send(research_embed);
				} else {
					msg.channel.send("The person you have specified doesn't even have a nation!");
				}
			}
			
			function printResearchQueue (arg0_user, arg1_message) {
				var msg = arg1_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var research_queue_string = [];
					
					research_queue_string.push("Your current <:building:716827579650408538> **Research Queue** allows for the consecutive research of multiple technologies, even whilst your asleep. As soon as a technology is researched, any valid technologies in the research queue will take its spot. You must have at least one active research slot for the Research Queue to work, and you may only queue up to **20** technologies.");
					research_queue_string.push("");
					research_queue_string.push("You currently have " + usr.research_queue.length + " items in your research queue.");
					
					if (usr.research_queue.length < 20) {
						research_queue_string.push("Type `" + bot_prefix + "add-research-queue` to add additional technologies to your queue.");
					} else {
						research_queue_string.push("Your **Research Queue** is currently full up!");
					}
					
					research_queue_string.push("");
					research_queue_string.push("---");
					research_queue_string.push("");
					
					if (usr.researching.length > 0) {
						if (usr.research_queue.length != 0) {
							for (var i = 0; i < usr.research_queue.length; i++) {
								var icon = "";
								if (config.technology[usr.research_queue[i]].icon != undefined) {
									icon = config.technology[usr.research_queue[i]].icon + " ";
								}
								research_queue_string.push("**" + (i+1) + ".** " + icon + usr.research_queue[i].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + " `" + bot_prefix + "cancel-research-queue " + i + "`");
							}
						} else {
							research_queue_string.push("_You currently have nothing queued up._");
						}
					} else {
						research_queue_string.push("_You must have an active research slot in order for your research queue to become functional!_ Type `" + bot_prefix + "research` to begin researching a technology. Type `" + bot_prefix + "research-list` for a list of available technologies.");
					}
					
					const research_queue_embed = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Research Queue:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(research_queue_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'research-queue.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					msg.channel.send(research_queue_embed);
				} else {
					msg.channel.send("You need to have a country before being able to view/edit your research queue!");
				}
			}
			
			function removeResearchQueue (arg0_user, arg1_id, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					if (isNaN(parseInt(arg1_id)) == false) {
						if (usr.research_queue[parseInt(arg1_id)] != undefined) {
							msg.channel.send("You have removed **" + usr.research_queue[parseInt(arg1_id)] + "** from your research queue. Type `" + bot_prefix + "research-queue` for a more updated list of your current technological requests.");
							usr.research_queue.splice(parseInt(arg1_id), 1);
						} else {
							msg.channel.send("That slot was not a valid numeric ID! Type `" + bot_prefix + "research-queue` to check which research orders can be cancelled.");
						}
					} else {
						msg.channel.send("You must specify a valid numeric ID! Type `" + bot_prefix + "research-queue` to check which research orders can be cancelled.");
					}
				} else {
					msg.channel.send("You need to have a nation before you can edit your research queue!");
				}
			}
			
			function research (arg0_user, arg1_technology, arg2_message) {
				var msg = arg2_message;
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var technology_exists = false;
					
					for (var i = 0; i < config.valid_technologies.length; i++) {
						if (config.valid_technologies[i] == arg1_technology) {
							technology_exists = true;
						}
					}
					
					if (technology_exists) {
						var tech_array_dump = [];
						var tech_category_techs_available = [];
						
						for (var i = 0; i < config.valid_technologies.length; i++) {
							var tech_available = false;
							
							if (config.technology[config.valid_technologies[i]].prerequisite_techs != undefined) {
								var prerequisite_checks = 0;
								for (var y = 0; y < config.technology[config.valid_technologies[i]].prerequisite_techs.length; y++) {
									for (var z = 0; z < usr.researched_technologies.length; z++) {
										if (config.technology[config.valid_technologies[i]].prerequisite_techs[y] == usr.researched_technologies[z]) {
											prerequisite_checks++;
										}
									}
								}
								
								if (prerequisite_checks == config.technology[config.valid_technologies[i]].prerequisite_techs.length) {
									tech_available = true;
								}
							} else { //No prerequisite checks found, so must be a starting tech
								tech_available = true;
							}
							
							//Check if user has already researched tech
							for (var y = 0; y < usr.researched_technologies.length; y++) {
								if (usr.researched_technologies[y] == config.valid_technologies[i]) {
									tech_available = false;
								}
							}
							
							//Append to valid tech dump for later categorisation
							if (tech_available) {
								tech_array_dump.push(config.valid_technologies[i]);
							}
						}
						
						//Execute research function
						
						var can_research = false;
						for (var i = 0; i < tech_array_dump.length; i++) {
							if (tech_array_dump[i] == arg1_technology) {
								can_research = true;
							}
						}
						if (can_research) {
							if (usr.researching.length < usr.modifiers.research_slots) {
								//Researching array: [[points_invested, technology]], e.g. [[20, "fleet_in_being"]]
								//usr["inventory"].knowledge = usr["inventory"].knowledge - config.technology[arg1_technology].research_cost;
								var min_knowledge_per_turn = 0;
								var max_knowledge_per_turn = 0;
								var pop_knowledge_gain = 0;
								
								for (var i = 0; i < config.pop_array.length; i++) {
									if (config.pops[config.pop_array[i]].knowledge_per_100k != undefined) {
										pop_knowledge_gain = pop_knowledge_gain + Math.ceil(((usr[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].knowledge_per_100k));
									}
								}
								
								for (var i = 0; i < usr.cities.city_array.length; i++) {
									for (var x = 0; x < config.buildings.length; x++) {
										if (usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]] > 0) {
											var produces_knowledge = false;
											for (var y = 0; y < config.building_stats[config.buildings[x]].produces.length; y++) {
												if (config.building_stats[config.buildings[x]].produces[y][1] == "knowledge") {
													if (Array.isArray(config.building_stats[config.buildings[x]].produces[y][0])) {
														min_knowledge_per_turn = min_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0][0]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
														max_knowledge_per_turn = max_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0][1]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
													} else {
														min_knowledge_per_turn = min_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
														max_knowledge_per_turn = max_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
													}
												}
											}
										}
									}
								}
								
								console.log("Min Knowledge Per Turn: " + min_knowledge_per_turn);
								
								min_knowledge_per_turn = Math.ceil(min_knowledge_per_turn) + pop_knowledge_gain;
								max_knowledge_per_turn = Math.ceil(max_knowledge_per_turn) + pop_knowledge_gain;
								
								min_knowledge_per_turn = Math.ceil(min_knowledge_per_turn/(usr.researching.length+1));
								max_knowledge_per_turn = Math.ceil(max_knowledge_per_turn/(usr.researching.length+1));
								
								var turn_string = "";
								if (min_knowledge_per_turn == 0 && max_knowledge_per_turn == 0) {
									turn_string = "forever**";
								} else if (min_knowledge_per_turn == max_knowledge_per_turn) {
									turn_string = parseNumber(Math.ceil(config.technology[arg1_technology].research_cost/min_knowledge_per_turn)) + "** turn(s)";
								} else {
									turn_string = parseNumber(Math.ceil(config.technology[arg1_technology].research_cost/min_knowledge_per_turn)) + " - " + parseNumber(Math.ceil(config.technology[arg1_technology].research_cost/max_knowledge_per_turn)) + "** turn(s)";
								}
								
								if (arg2_message != "none") {
									msg.channel.send("Your scientists have started research on **" + arg1_technology + "**. Your advisor estimates that it will take them **" + turn_string + " to complete researching this technology.");
								}
								
								usr.researching.push([0, arg1_technology]);
							} else {
								if (arg2_message != "none") {
									msg.channel.send("Your research slots are already full up! Consider typing `" + bot_prefix + "cancel-research <number>` to cancel your current research in one of your slots, or queue up technologies using `" + bot_prefix + "research-queue`.");
								}
							}
						} else {
							if (arg2_message != "none") {
								msg.channel.send("You don't have the necessary prerequisites to research **" + arg1_technology + "** yet!");
							}
						}
					} else {
						if (arg2_message != "none") {
							msg.channel.send("**" + arg1_technology + "** is not a valid technology that you can currently research!");
						}
					}
				} else {
					if (arg2_message != "none") {
						msg.channel.send("You need to have a nation in order to conduct research!");
					}
				}
			}
		}
		
		//Trade commands
		{
			function autoTrade (arg0_user, arg1_user, arg2_amount, arg3_item, arg4_message) {
				var msg = arg4_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (arg0_user != arg1_user) {
							var ot_user = main.users[arg1_user];
							var item_exists = [false, ""];
							
							for (var i = 0; i < config.materials.length; i++) {
								if (config.materials[i].toLowerCase() == arg3_item.toLowerCase()) {
									item_exists = [true, arg3_item.toLowerCase()];
								}
							}
							if (arg3_item.toLowerCase() == "money") {
								item_exists = [true, "money"];
							}
							
							if (item_exists[0]) {
								if (item_exists[1] != "knowledge") {
									if (isNaN(parseInt(arg2_amount)) == false) {
										if (Math.ceil(arg2_amount) > 0) {
											if (ot_user.blockaded == false) {
												usr.auto_trades.push([ot_user.id, Math.ceil(arg2_amount), item_exists[1]]);
												msg.channel.send("You have begun shipping out **" + parseNumber(Math.ceil(arg2_amount)) + "** " + item_exists[1] + " per turn to the country of **" + ot_user.name + "**.\n\nTo view a list of all your auto-trades, type `" + bot_prefix + "auto-trades`. To see incoming imports, type `" + bot_prefix + "trade`.");
											} else {
												msg.channel.send("You can't send goods to blockaded users!");
											}
										} else if (Math.ceil(arg2_amount) == 0) {
											msg.channel.send("Why did you even try to set up an auto trade ...");
										} else if (Math.ceil(arg2_amount) < 0) {
											msg.channel.send("You can't steal items from other users like that!");
										}
									} else {
										msg.channel.send("You must specify a valid number!");
									}
								} else {
									msg.channel.send("You can't ship out knowledge from your country!");
								}
							} else {
								msg.channel.send("The item you have specified doesn't even exist!");
							}
						} else {
							msg.channel.send("You cannot trade with yourself!");
						}
					} else {
						msg.channel.send("The user you are trying to ship goods to doesn't even exist!");
					}
				} else {
					msg.channel.send("You must have a country before being able to ship out goods across the world!");
				}
			}
		
			function cancelAutoTrade (arg0_user, arg1_id, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var trade_exists = false;
					var index = Math.abs(Math.round(parseInt(arg1_id)));
					
					if (usr.auto_trades.length > 0) {
						if (isNaN(index) == false) {
							if (index >= 0) {
								if (usr.auto_trades[index] != undefined) {
									msg.channel.send("You have cancelled the automatic shipment of **" + usr.auto_trades[index][1] + "** " + usr.auto_trades[index][2] + " to **" + main.users[usr.auto_trades[index][0]].name + "**.\n\nType `" + bot_prefix + "auto-trades` to see an updated list of all your automatic trading.");
									usr.auto_trades.splice(index, 1);
								} else {
									msg.channel.send("The Autotrade ID you have specified is nonexistent! Type `" + bot_prefix + "auto-trades` to see an updated list of all Autotrade IDs.");
								}
							} else {
								msg.channel.send("IDs less than zero do not exist!");
							}
						} else {
							msg.channel.send("You must type a valid number!");
						}
					} else {
						msg.channel.send("You currently have no ongoing auto-trades!");
					}
				} else {
					msg.channel.send("You can't cancel the trades of a nonexistent nation!");
				}
			}
			
			function printAutoTrades (arg0_user, arg1_message) {
				var msg = arg1_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var auto_trade_embeds = [];
					var auto_trade_prefix = [];
					var auto_trade_suffix = [];
					var local_auto_trade_string = [];
					
					auto_trade_prefix.push("<:taxes:716817688781127810> **Auto-Trades** are shipments of goods that occur automatically from your nation to another country. These goods are shipped out once per turn.\n\nTo cancel an auto-trade, type `" + bot_prefix + "cancel-auto-trade`.\nTo create a new auto-trade, type `" + bot_prefix + "auto-trade`.");
					auto_trade_prefix.push("---");
					auto_trade_prefix.push("");
					
					auto_trade_suffix.push("");
					auto_trade_suffix.push("To return to the trade menu, type `" + bot_prefix + "trade`.");
					
					if (usr.auto_trades.length > 0) {
						for (var i = 0; i < usr.auto_trades.length; i++) {
							console.log("DEBUG LOG: " + usr.auto_trades[i]);
							var icon = "";
							for (var x = 0; x < config.materials.length; x++) {
								if (config.materials[x] == usr.auto_trades[i][2]) {
									icon = config.resource_icons[x];
								}
							}
							
							local_auto_trade_string.push("Exporting " + icon + " " + usr.auto_trades[i][1] + " " + usr.auto_trades[i][2] + " to **" + main.users[usr.auto_trades[i][0]].name + "** each turn.");
							local_auto_trade_string.push("`" + bot_prefix + "cancel-auto-trade " + i + "`");
							
						}
						for (var i = 0; i < local_auto_trade_string.length; i++) {
							if (i % 30 == 0 || i == usr.auto_trades.length-1) {
								const embed_trade = new Discord.MessageEmbed()
									.setColor('#a98ac7')
									.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
									.setTitle('**Auto-Trades:\n------------------**')
									.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
									.setDescription(auto_trade_prefix.join("\n") + local_auto_trade_string.join("\n") + "\n" + auto_trade_suffix.join("\n"))
									.setTimestamp()
									.setFooter('To access this menu again, type ' + bot_prefix + 'auto-trades.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
								
								auto_trade_embeds.push(embed_trade);
								local_auto_trade_string = [];
							}
						}
					} else {
						const embed_trade = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Auto-Trades:\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(auto_trade_prefix.join("\n") + "_You currently have no ongoing auto-trades._" + "\n" + auto_trade_suffix.join("\n"))
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'auto-trades.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
							
						auto_trade_embeds.push(embed_trade);
					}
					
					scrollMessage(msg, auto_trade_embeds, 0);
				} else {
					msg.channel.send("You must have a nation in order to conduct automatic trading with other countries!");
				}
			}
		}
		
		function buildRequest (arg0_user, arg1_message, arg2_name, arg3_costs, arg4_build_request, arg5_amount, arg6_city) {
			//Costs: [[5, "iron"],[1, "stone"]]
			var usr = arg0_user;
			var inventory = usr["inventory"];
			var print_results = [];
			
			if (arg4_build_request == arg2_name) {
				var fatal_error = false;
				var local_singular = config.building_stats[arg2_name].singular.toLowerCase();
				for (var a = 0; a < arg5_amount; a++) {
					var valid_building = false;
					
					for (var i = 0; i < usr.available_buildings.length; i++) {
						if (usr.available_buildings[i] == arg2_name) {
							valid_building = true;
						}
					}
					
					if (valid_building) {
						console.log("Request to build " + arg5_amount + " " + arg2_name + " was recieved.");
						var checks_passed = 0;

						for (var i = 0; i < arg3_costs.length; i++) {
							var pop_argument = false;
										
							for (var x = 0; x < config.pop_array.length; x++) {
								if (arg3_costs[i][1] == config.pop_array[x]) {
									pop_argument = true;
								}
							}
										
							if (pop_argument) {
								var remaining_pops = usr[arg3_costs[i][1]] - usr["used_" + arg3_costs[i][1]];
								if (remaining_pops >= arg3_costs[i][0]) {
									checks_passed++;
								}
							} else {
								if (arg3_costs[i][1] == "money") {
									if (usr.money >= Math.ceil(arg3_costs[i][0]*usr.modifiers.building_cost)) {
										checks_passed++;
									}
								} else {
									if (inventory[arg3_costs[i][1]] >= Math.ceil(arg3_costs[i][0]*usr.modifiers.building_cost)) {
										checks_passed++;
									}
								}
							}
						}
						
						if (checks_passed >= arg3_costs.length) {
							
							var city_name = "";
							
							//Soft match
							for (var i = 0; i < usr.cities.city_array.length; i++) {
								if (usr.cities[usr.cities.city_array[i]].name.toLowerCase().indexOf(arg6_city.toLowerCase()) != -1) {
									city_name = usr.cities.city_array[i];
									console.log(usr.cities.city_array[i]);
								}
							}
							
							//Hard match
							for (var i = 0; i < usr.cities.city_array.length; i++) {
								if (usr.cities[usr.cities.city_array[i]].name.toLowerCase() == arg6_city.toLowerCase()) {
									city_name = usr.cities.city_array[i];
									console.log(usr.cities.city_array[i]);
								}
							}
							
							console.log("City Name: " + city_name);
							
							if (city_name == "") {
								if (fatal_error == false) {
									print_results.push("The city you have specified proved more elusive than El Dorado!");
									fatal_error = true;
								}
							} else {
								if (usr["cities"][city_name].building_count < usr["cities"][city_name].building_cap) {
									console.log(arg2_name + ": " + usr["cities"][city_name]["buildings"][arg2_name]);
									if (usr["cities"][city_name]["buildings"][arg2_name]+arg5_amount <= (usr.modifiers[arg2_name]+usr.modifiers.extra_building_slots)) {
										var single_object = arg2_name;

										for (var i = 0; i < arg3_costs.length; i++) {
											var pop_argument = false;
											
											for (var x = 0; x < config.pop_array.length; x++) {
												if (arg3_costs[i][1] == config.pop_array[x]) {
													pop_argument = true;
												}
											}
											
											if (pop_argument) {
												var remaining_pops = usr[arg3_costs[i][1]] - usr["used_" + arg3_costs[i][1]];
												if (remaining_pops >= arg3_costs[i][0]) {
													usr["used_" + arg3_costs[i][1]] = usr["used_" + arg3_costs[i][1]] + arg3_costs[i][0];
												}
											} else {
												if (arg3_costs[i][1] == "money") {
													if (usr.money >= arg3_costs[i][0]) {
														usr.money = usr.money - Math.ceil(arg3_costs[i][0]*usr.modifiers.building_cost);
													}
												} else {
													if (inventory[arg3_costs[i][1]] >= arg3_costs[i][0]) {
														inventory[arg3_costs[i][1]] = inventory[arg3_costs[i][1]] - Math.ceil(arg3_costs[i][0]*usr.modifiers.building_cost);
													}
												}
											}
										}
										
										console.log(city_name);
										
										if (city_name == "") {
											if (fatal_error == false) {
												print_results.push("The city you have specified proved more elusive than El Dorado!");
												fatal_error = true;
											}
										} else {
											usr["cities"][city_name]["buildings"][arg2_name]++;
											usr["cities"][city_name].building_count++;
											
											var building_term = "";
											
											if (arg5_amount > 1) {
												building_term = config.building_stats[arg2_name.toLowerCase()].name.toLowerCase();
											} else {
												building_term = config.building_stats[arg2_name.toLowerCase()].singular.toLowerCase();
											}
											
											//Add building to count for easier access
											usr["buildings"][arg2_name]++;
										}
									} else {
										if (fatal_error == false) {
											print_results.push("Your build request exceeded the maximum capacity for **" + arg2_name + "**! Research additional technology first in order to raise your building cap.");
											fatal_error = true;
										}
									}
								} else {
									if (fatal_error == false) {
										print_results.push("The city you have specified didn't have enough building slots remaining!");
										fatal_error = true;
									}
								}
							}
						} else {
							if (fatal_error == false) {
								print_results.push("You don't have the resources to build this!");
								fatal_error = true;
							}
							console.log(print_results.join("\n"));
						}
					} else {
						print_results.push("The building you have specified was invalid, either due to obsoletion or the building being too advanced for your country!");
						fatal_error = true;
					}
				}
				
				if (fatal_error == false) {
					var building_term = "";
					if (arg5_amount == 1) {
						building_term = local_singular;
					} else {
						building_term = arg2_name;
					}
					print_results.push("You have successfully built " + arg5_amount + " **" + building_term + "** in " + usr.cities[city_name].name + "!");
					arg1_message.channel.send(print_results.join("\n"));
				} else {
					arg1_message.channel.send(print_results.join("\n"));
				}
			}
		}
		
		function build (arg0_user, arg1_msg, arg2_building, arg3_amount, arg4_city) {
			if (main.users[arg0_user] == undefined) {
				arg1_msg.channel.send("You don't have a country yet!");
			} else {
				var usr = main.users[arg0_user];
				var inventory = main.users[arg0_user]["inventory"];
				var result_string = [];
				var building_exists = false;
				for (var i = 0; i < config.buildings.length; i++) {
					if (arg2_building == config.buildings[i]) {
						building_exists = true;
					}
				}
				
				if (building_exists) {
					//buildRequest(usr, arg1_msg, "farms", [[10, "lumber"], [5, "iron"], [1500, "money"], [500, "manpower"]], arg2_building, arg3_amount, arg4_city);
					if (arg3_amount == 0) {
						result_string.push("Why did you even issue this command?");
					} else if (arg3_amount < 0) {
						result_string.push("You can't build negative buildings!");
					}
					
					if (arg3_amount > 0) {
						for (var i = 0; i < config.buildings.length; i++) {
							console.log(config.building_stats[config.buildings[i]].costs);
							buildRequest(usr, arg1_msg, config.buildings[i], config.building_stats[config.buildings[i]].costs, arg2_building.toLowerCase(), arg3_amount, arg4_city);
						}
					}
				} else {
					result_string.push("You were unable to build this building.");
				}
				
				arg1_msg.channel.send(result_string.join("\n"));
			}
		}
		
		function craftRequest (arg0_user, arg1_message, arg2_name, arg3_costs, arg4_build_request, arg5_amount, arg6_int) {
			//Costs: [[5, "iron"],[1, "stone"]]
			var usr = arg0_user;
			var military = usr["military"];
			var inventory = usr["inventory"];
			var print_results = [];
			var fatal_error = false;
			var tech_request = false;
			
			var obsolete_recipe = false;
			var ceiled_amount = Math.ceil(arg5_amount);
			
			var remaining_manpower = usr.soldiers*usr.manpower_percentage*usr.modifiers.national_manpower - usr.used_soldiers;
			
			if (arg4_build_request == arg2_name) {
				
				var has_building = false;
				var found_cp = false;
				var extra_check_passed = false;
				
				for (var i = 0; i < arg3_costs.length; i++) {
					var actual_material = false;
					for (var x = 0; x < config.materials.length; x++) {
						if (config.materials[x] == arg3_costs[i][1]) {
							actual_material = true;
						} else if (arg3_costs[i][1] == "money") {
							actual_material = true;
						}
					}
					var is_pop = false;
					if (actual_material == false) {
						for (var x = 0; x < config.pop_array.length; x++) {
							if (config.pop_array[x] == arg3_costs[i][1]) {
								is_pop = true;
							}
						}
						if (is_pop == false) {
							//Must be CP!
							found_cp = true;
							if (usr[arg3_costs[i][1]] >= Math.ceil(arg3_costs[i][0]*ceiled_amount*usr.modifiers.training_cost)) {
								has_building = true;
								console.log("Need " + Math.ceil(arg3_costs[i][0]*ceiled_amount*usr.modifiers.training_cost) + ", has " + usr[arg3_costs[i][1]] + " CP.");
								extra_check_passed = true;
							} else {
								console.log("DEBUG LOG: " + arg3_costs[i][0]);
								console.log("Need " + Math.ceil(arg3_costs[i][0]*ceiled_amount*usr.modifiers.training_cost) + ", has " + usr[arg3_costs[i][1]] + " CP.");
							}
						}
					}
					if (found_cp == false) {
						has_building = true;
					}
				}
				
				for (var x = 0; x < ceiled_amount; x++) {
					console.log("Request to build " + ceiled_amount + " " + arg2_name + " was recieved.");
					var checks_passed = 0;
					obsolete_recipe = true;
					
					for (var i = 0; i < usr.available_units.length; i++) {
						if (usr.available_units[i] == arg2_name) {
							obsolete_recipe = false;
						}
					}
					
					for (var i = 0; i < arg3_costs.length; i++) {
						if (arg3_costs[i][1] == "soldiers") {
							if (remaining_manpower >= arg3_costs[i][0]) {
								checks_passed++;
							}
						} else if (arg3_costs[i][1] == "money") {
							if (usr.money >= Math.ceil(arg3_costs[i][0]*usr.modifiers.unit_cost)) {
								checks_passed++;
							}
						} else {
							if (inventory[arg3_costs[i][1]] >= Math.ceil(arg3_costs[i][0]*usr.modifiers.unit_cost)) {
								checks_passed++;
							}
						}
					}
					
					if (extra_check_passed) {
						checks_passed++;
					}
					
					console.log("CHECKS PASSED: " + checks_passed + ", COSTS LENGTH: " + arg3_costs.length);
					
					if (obsolete_recipe == false) {
						if (has_building != false) {
							if (checks_passed >= arg3_costs.length) {
								if (tech_request != true) {
									usr["military"][arg2_name] = usr["military"][arg2_name] + arg6_int;
								}
								
								for (var i = 0; i < arg3_costs.length; i++) {
									if (arg3_costs[i][1] == "soldiers") {
										if (remaining_manpower >= arg3_costs[i][0]) {
											usr.used_soldiers = usr.used_soldiers + arg3_costs[i][0];
										}
									} else if (arg3_costs[i][1] == "money") {
										if (usr.money >= arg3_costs[i][0]) {
											usr.money = usr.money - Math.ceil(arg3_costs[i][0]*usr.modifiers.unit_cost);
										}
									} else if (arg3_costs[i][1].indexOf("_cp") != -1) {
										usr[arg3_costs[i][1]] = usr[arg3_costs[i][1]] - Math.ceil(arg3_costs[i][0]*ceiled_amount*usr.modifiers.training_cost);
									} else {
										if (inventory[arg3_costs[i][1]] >= arg3_costs[i][0]) {
											inventory[arg3_costs[i][1]] = inventory[arg3_costs[i][1]] - Math.ceil(arg3_costs[i][0]*usr.modifiers.unit_cost);
										}
									}
								}
							} else {
								if (fatal_error == false) {
									print_results.push("You were unable to craft this item!");
									fatal_error = true;
								}
							}
						} else {
							if (fatal_error == false) {
								print_results.push("You do not possess enough **Crafting Points** needed to train these units!");
								fatal_error = true;
							}
						}
					} else {
						if (fatal_error == false) {
							print_results.push("The unit you tried to craft is not currently available either because it is obsolete, or due to technological limitations!");
							fatal_error = true;
						}
					}
				}
				
				if (fatal_error == false) {
					arg1_message.channel.send("You have successfully trained **" + ceiled_amount + "** regiments of **" + arg2_name + "**!");
				} else {
					arg1_message.channel.send(print_results.join("\n"));
				}
			}
		}
		
		function craft (arg0_user, arg1_msg, arg2_crafting, arg3_amount) {
			if (main.users[arg0_user] == undefined) {
				arg1_msg.channel.send("You don't have a country yet!");
			} else {
				var usr = main.users[arg0_user];
				var military = main.users[arg0_user]["military"];
				var result_string = [];
				var unit_exists = false;
				
				for (var i = 0; i < config.units.length; i++) {
					if (arg2_crafting == config.units[i]) {
						unit_exists = true;
					}
				}
				if (unit_exists) {
					//craftRequest(usr, arg1_msg, "farms", [[10, "lumber"], [5, "iron"], [1500, "money"], [500, "manpower"]], arg2_building, arg3_amount);
					
					//Loop through config unit array
					for (var i = 0; i < config.units.length; i++) {
						craftRequest(usr, arg1_msg, config.units[i], config.unit_stats[config.units[i]].costs, arg2_crafting, arg3_amount, config.unit_stats[config.units[i]].quantity);
					}
				} else {
					result_string.push("No such recipe exists!");
				}
				
				arg1_msg.channel.send(result_string.join("\n"));
			}
		}
		
		function modifyItem (arg0_user, arg1_amount, arg2_item, arg3_mode) {
			var current_user = arg0_user.toString();
			
			if (arg3_mode == "add") {
				if (main.users[current_user] == undefined) {
					initUser(current_user);
					main.users[current_user]["inventory"][arg2_item] = main.users[current_user]["inventory"][arg2_item] + parseInt(arg1_amount);
				} else {
					main.users[current_user]["inventory"][arg2_item] = main.users[current_user]["inventory"][arg2_item] + parseInt(arg1_amount);
				}
			} else if (arg3_mode == "remove") {
				if (main.users[current_user] == undefined) {
					initUser(current_user);
					main.users[current_user]["inventory"][arg2_item] = main.users[current_user]["inventory"][arg2_item] - parseInt(arg1_amount);
				} else {
					main.users[current_user]["inventory"][arg2_item] = main.users[current_user]["inventory"][arg2_item] - parseInt(arg1_amount);
				}
			}
		}
		
		function give (arg0_user, arg1_user2, arg2_amount, arg3_item, arg4_mode, arg5_message) {
			var msg = arg5_message;
			if (main.users[arg0_user] != undefined) {
				var usr = main.users[arg0_user];
				var other_usr_id = arg1_user2.replace(/(<)(@)(!)/g, "");
				var other_usr_id = arg1_user2.replace(/(<)(@)/g, "");
				var other_usr = main.users[other_usr_id];
				
				var inventory = main.users[arg0_user]["inventory"];
				console.log(other_usr_id);
				
				var ceiled_amount = Math.ceil(arg2_amount);
				if (arg0_user != arg1_user2) {
					if (ceiled_amount > 0) {
						if (arg4_mode == "item") {
							if (arg3_item == "money") {
								if (usr.money >= ceiled_amount) {
									var distance = Math.abs(usr.capital_id-other_usr.capital_id);
									var amount_of_turns = Math.ceil((config.base_transfer_time+(distance/config.shipment_time))*usr.modifiers.shipment_time);
									usr.trade_array.push([[parseInt(ceiled_amount), "money"], other_usr_id, amount_of_turns]);
									//base_transfer_time + shipment_time
									if (arg5_message != "none") {
										arg5_message.channel.send("Your transports have begun to ship " + ceiled_amount + " " + arg3_item + " to <@" + other_usr_id + ">. They will arrive in **" + amount_of_turns + "** turns.");
									}
									if (arg5_message != "none") {
										arg5_message.channel.send("You sent <@" + other_usr_id + "> " + ceiled_amount + " money.");
									}
								} else {
									if (arg5_message != "none") {
										arg5_message.channel.send("You were unable to execute this command due to a shortage of money.");
									}
								}
							} else if (arg3_item == "knowledge") {
								if (arg5_message != "none") {
									arg5_message.channel.send("You can't send knowledge as a resource!");
								}
							} else {
								var item_exists = false;
								for (var i = 0; i < config.materials.length; i++) {
									if (arg3_item == config.materials[i]) {
										item_exists = true;
									}
								}
								if (item_exists) {
									if (inventory[arg3_item] >= ceiled_amount) { 
										var distance = Math.abs(usr.capital_id-other_usr.capital_id);
										var amount_of_turns = Math.ceil((config.base_transfer_time+(distance/config.shipment_time))*usr.modifiers.shipment_time);
										usr.trade_array.push([[parseInt(ceiled_amount), arg3_item], other_usr_id, amount_of_turns]);
										//base_transfer_time + shipment_time
										if (arg5_message != "none") {
											arg5_message.channel.send("Your transports have begun to ship " + ceiled_amount + " " + arg3_item + " to <@" + other_usr_id + ">. They will arrive in **" + amount_of_turns + "** turns.");
										}
									} else {
										if (arg5_message != "none") {
											arg5_message.channel.send("You were unable to execute this command due to a shortage of items.");
										}
									}
								} else {
									if (arg5_message != "none") {
										arg5_message.channel.send("The item you are trying to send is nonexistent!");
									}
								}
							}
						} else if (arg4_mode == "industry") {
							var building_exists = false;
							for (var i = 0; i < config.buildings.length; i++) {
								if (arg3_item == config.buildings[i]) {
									building_exists = true;
								}
							}
							if (building_exists) {
								if (usr["buildings"][arg3_item] >= ceiled_amount) {
									usr["buildings"][arg3_item] = parseInt(usr["buildings"][arg3_item]) - parseInt(ceiled_amount);
									other_usr["buildings"][arg3_item] = parseInt(other_usr["buildings"][arg3_item]) + parseInt(ceiled_amount);
									if (arg5_message != "none") {
										arg5_message.channel.send("You gave <@" + other_usr_id + "> " + ceiled_amount + " " + arg3_item + ".");
									}
								} else {
									if (arg5_message != "none") {
										arg5_message.channel.send("You were unable to execute this command due to a shortage of buildings.");
									}
								}
							} else {
								if (arg5_message != "none") {
									arg5_message.channel.send("The item you are trying to send is nonexistent!");
								}
							}
						}
					} else if (ceiled_amount == 0) {
						if (arg5_message != "none") {
							msg.channel.send("You can't give zero units of something!");
						}
					} else {
						if (arg5_message != "none") {
							msg.channel.send("You can't steal from other users!");
						}
					}
				} else {
					if (arg5_message != "none") {
						msg.channel.send("You can't give stuff to yourself!");
					}
				}
			} else {
				if (arg5_message != "none") {
					arg5_message.channel.send("The person you are trying to give items to doesn't even have a country!");
				}
			}
		}
	}
	
	//Logic
	{
		setTimeout(function(){
			console.log("[Triumph & Tragedy] is ready to recieve data requests!");
			setInterval(function(){
				fs.writeFile('database.js', JSON.stringify(main), function (err,data) {
					if (err) {
						return console.log(err);
					}
					//console.log(data);
				});
				
				//Check if a turn has passed
				
				if (main.lastTurn == undefined) {
					main.lastTurn = new Date().getTime();
				} else {
					var current_date = new Date().getTime();
					var time_difference = current_date - main.lastTurn;
					
					//Initialise global if not defined
					if (main.users.global == undefined) {
						initGlobal();
					}
					
					//Write map to processed_test.svg
					{
						fs.writeFile("./maps/processed_test.svg", original_svg, function (err, data) {
							if (err) {
								return console.log(err);
							}
						});
					}
					
					//World Market Up-Logic
					{
						if (main.user_array.length > 0) {
							var market = main.users.global;
							for (var i = 0; i < config.resource_list.length; i++) {
								var local_resource = config.resource_list[i][0];
								if (market[local_resource + "_buy_price"] < market[local_resource + "_sell_price"]*1.2) {
									market[local_resource + "_buy_price"] = Math.ceil(market[local_resource + "_buy_price"]*1.2);
								}
							}
						}
					}
					
					//War Logic, add casualties
					{
						var all_wars = Object.keys(main.users.global.wars);
						
						for (var i = 0; i < all_wars.length; i++) {
							main.users.global.wars.attacker_total_casualties = 0;
							main.users.global.wars.defender_total_casualties = 0;
							var attacker_war_exhaustion = 0;
							var defender_war_exhaustion = 0;
							
							for (var x = 0; x < main.users.global.wars[all_wars[i]].attackers.length; x++) {
								if (main.users.global.wars[all_wars[i]][main.users.global.wars[all_wars[i]].attackers[x] + "_casualties"] == undefined) {
									main.users.global.wars[all_wars[i]][main.users.global.wars[all_wars[i]].attackers[x] + "_casualties"] = 0;
								} else {
									main.users.global.wars.attacker_total_casualties = main.users.global.wars.attacker_total_casualties + main.users.global.wars[all_wars[i]][main.users.global.wars[all_wars[i]].attackers[x] + "_casualties"];
								}
								attacker_war_exhaustion = attacker_war_exhaustion + main.users[main.users.global.wars[all_wars[i]].attackers[x]].modifiers.war_exhaustion;
							}
							for (var x = 0; x < main.users.global.wars[all_wars[i]].defenders.length; x++) {
								if (main.users.global.wars[all_wars[i]][main.users.global.wars[all_wars[i]].defenders[x] + "_casualties"] == undefined) {
									main.users.global.wars[all_wars[i]][main.users.global.wars[all_wars[i]].defenders[x] + "_casualties"] = 0;
								} else {
									main.users.global.wars.defender_total_casualties = main.users.global.wars.defender_total_casualties + main.users.global.wars[all_wars[i]][main.users.global.wars[all_wars[i]].defenders[x] + "_casualties"];
								}
								if (main.users.global.wars[all_wars[i]].defenders[x] != main.users.global.wars[all_wars[i]].original_target) {
									defender_war_exhaustion = defender_war_exhaustion + main.users[main.users.global.wars[all_wars[i]].defenders[x]].modifiers.war_exhaustion;
								}
							}
							main.users.global.wars[all_wars[i]].attacker_warscore = attacker_war_exhaustion/main.users.global.wars[all_wars[i]].attackers.length;
							main.users.global.wars[all_wars[i]].defender_warscore = ((0.75*defender_war_exhaustion)+(0.25*main.users[main.users.global.wars[all_wars[i]].original_target].modifiers.war_exhaustion))/main.users.global.wars[all_wars[i]].defenders.length;
							if (main.users.global.wars[all_wars[i]].attacker_warscore > 100) {
								main.users.global.wars[all_wars[i]].attacker_warscore = 100;
							}
							if (main.users.global.wars[all_wars[i]].defender_warscore > 100) {
								main.users.global.wars[all_wars[i]].defender_warscore = 100;
							}
						}
					}
					
					//Battle Logic/Battle Tick
					{
						var battle_difference = current_date - main.users.global.battle_tick;
						if (battle_difference > (turn_timer*1000)/10) {
							//Test if any armies between warring nations are in the same province
							main.users.global.battle_tick = current_date;
							
							//ABRS - Automated Backup and Restoration System
							{
								var d = new Date();
								var current_year = d.getFullYear();
								var current_month = d.getMonth()+1;
								var current_day = d.getDate();
								
								if (current_month < 10) {
									current_month = "0" + current_month;
								}
								if (current_day < 10) {
									current_day = "0" + current_day;
								}
								
								var current_hours = d.getHours();
								var current_minutes = d.getMinutes();
								var current_seconds = d.getSeconds();
								
								if (current_hours < 10) {
									current_hours = "0" + current_hours;
								}
								if (current_minutes < 10) {
									current_minutes = "0" + current_minutes;
								}
								if (current_seconds < 10) {
									current_seconds = "0" + current_seconds;
								}
									
								if (JSON.stringify(main).length != 0) {
									var create_backup = fs.createWriteStream("./backups/" + current_day + "." + current_month + "." + current_year + " " + current_hours + "." + current_minutes + "." + current_seconds + ".txt");
									create_backup.end();
										
									fs.writeFile("./backups/" + current_day + "." + current_month + "." + current_year + " " + current_hours + "." + current_minutes + "." + current_seconds + ".txt", JSON.stringify(main), function (err,data) {
										if (err) {
											return console.log(err);
										}
										//console.log(data);
									});
								} else {
									loadMostRecentSave();
								}
							}
							
							for (var i = 0; i < main.user_array.length; i++) {
								var usr = main.users[main.user_array[i]];
								var in_combat = false;
								
								if (usr.armies.army_array.length > 0 && usr.at_war.length > 0) {
									for (var x = 0; x < usr.armies.army_array.length; x++) {
										//Check for hostile armies in the same province
										for (var y = 0; y < usr.at_war.length; y++) {
											for (var z = 0; z < main.user_array.length; z++) {
												for (var a = 0; a < main.users[main.user_array[z]].armies.army_array.length; a++) {
													if (main.users[main.user_array[z]].name == usr.at_war[y]) {
														//Checked that user is hostile, scan through each of their armies and see if they share a province position
														if (main.users[main.user_array[z]].armies[main.users[main.user_array[z]].armies.army_array[a]].province == usr.armies[usr.armies.army_array[x]].province) {
															//Conduct battle tick for province
															//function combat (arg0_user, arg1_army, arg2_user, arg3_army, arg4_province, arg5_msg) { 
															//$combat [@def. user] [army name] [@att. user] [army name] [province]
															var defending_user = "";
															var attacking_user = "";
															var defending_army = "";
															var attacking_army = "";
															
															if (main.users[main.user_array[z]].armies[main.users[main.user_array[z]].armies.army_array[a]].stationary_turns > usr.armies[usr.armies.army_array[x]].stationary_turns) {
																defending_user = main.user_array[z];
																defending_army = main.users[main.user_array[z]].armies.army_array[a];
																attacking_user = usr.id;
																attacking_army = usr.armies.army_array[x];
															} else {
																defending_user = usr.id;
																defending_army = usr.armies.army_array[x];
																attacking_user = main.user_array[z];
																attacking_army = main.users[main.user_array[z]].armies.army_array[a];
															}
															
															if (main.users[main.user_array[z]].armies[main.users[main.user_array[z]].armies.army_array[a]].name != "deleted-army" && usr.armies[usr.armies.army_array[x]].name != "deleted-army") {
																combat(defending_user, defending_army, attacking_user, attacking_army, usr.armies[usr.armies.army_array[x]].province.toString(), "none");
																in_combat = true;
															}
														}
													}
												}
											}
										}
										
										var hostile_province = false;
										var hostile_owner = "";
										var army_obj = usr.armies[usr.armies.army_array[x]];
										
										for (var y = 0; y < usr.at_war.length; y++) {
											for (var z = 0; z < main.user_array.length; z++) {
												//Scan for all hostile enemies
												if (main.users[main.user_array[z]].name == usr.at_war[y]) {
													//Scan through all provinces
													for (var a = 0; a < main.users[main.user_array[z]].pops.pop_array.length; a++) {
														if (main.users[main.user_array[z]].pops.pop_array[a] == army_obj.province) {
															hostile_province = true;
															hostile_owner = main.user_array[z];
														}
													}
												}
											}
										}
										
										if (in_combat == false && hostile_province == true) {
											transferProvince(hostile_owner, army_obj.province, usr.id);
											var is_city = false;
											
											//Check if province is home to an enemy city
											for (var y = 0; y < main.users[hostile_owner].cities.city_array.length; y++) {
												var city_obj = main.users[hostile_owner].cities[main.users[hostile_owner].cities.city_array[y]];
												
												if (city_obj.province == army_obj.province) {
													is_city = true;
												}
											}
											main.users.global.occupations.push([army_obj.province, is_city, hostile_owner, usr.id]);
										}
									}
								}
							}
						}
					}
					
					if (time_difference > turn_timer*1000) {
						if (main.roundCount == undefined) {
							main.roundCount = 0;
						} else {
							main.roundCount++;
						}
						
						if (main.user_array.length > 0) {
							for (var x = 0; x < main.user_array.length; x++) {
								nextTurn(main.user_array[x]);
							}
						}
							
						//World Market Down-Logic
						{
							if (main.user_array.length > 0) {
								var market = main.users.global;
								for (var i = 0; i < config.resource_list.length; i++) {
									market[config.resource_list[i][0] + "_buy_price"] = Math.ceil(market[config.resource_list[i][0] + "_buy_price"]*(randomNumber(103, 108)/100));
									if (market[config.resource_list[i][0] + "_sell_price"] > 100) {
										console.log(Math.ceil(market[config.resource_list[i][0] + "_sell_price"]*randomNumber(0.92, 0.97)));
										market[config.resource_list[i][0] + "_sell_price"] = Math.ceil(market[config.resource_list[i][0] + "_sell_price"]*(randomNumber(92, 97)/100));
									}
								}
							}
						}
							
						//console.log('[Country Battle] A turn has elapsed!');
						console.log(announcements_channel);
						returnChannel(announcements_channel).send("<@&700158364822405190> A turn has elapsed! It is now round **" + main.roundCount + "**.\nWelcome to the year of our Lord, **" + (1500+main.roundCount) + "**.");
						main.lastTurn = current_date;
							
						for (var x = 0; x < news.length; x++) {
							returnChannel(announcements_channel).send(news[x]);
						}
						
						displaySVG(returnChannel(map_channel));
						news = [];
					}
				}
				
				for (var x = 0; x < main.user_array.length; x++) {
					initUser(main.user_array[x]);
				}
				
			}, 100);
		},1000);
	}
}

//Reaction Logic

const removeReaction = async (m, msg, emoji) => {
	console.log(msg.author.id);
	try { m.reactions.cache.find(r => r.emoji.name == emoji).users.remove(msg.author.id); } catch (err) { console.log(err); }
}

function resetReactions (msg) {
	msg.reactions.removeAll().catch(error => console.error('Failed to clear reactions: ', error));
}

var help_page_array = []; //lmao
var data_prompt_array = {
	current_key: 0
};

const awaitReactions = async (msg, m, options, filter) => {
	const { min, max, arg1_embeds, limit, type, data_id, prompt_string } = options;
	
	if (type == "help message") {
		m.awaitReactions(filter, { max: 1, time: limit, errors: ["time"] })
			.then(async (collected) => {
				async function arrowReset () {
					if (help_page_array[data_id] == min) {
						resetReactions(m);
						await m.react("");
					} else if (help_page_array[data_id] == max) {
						resetReactions(m);
						await m.react("");
					} else {
						if (help_page_array[data_id] == min+1 || help_page_array[data_id] == max-1) {
							resetReactions(m);
							await m.react("");
							await m.react("");
						}
					}
				}
				const reaction = collected.first();
				console.log("Page ID: " + data_id);
				
				if (reaction.emoji.name === "") {
					await removeReaction(m, msg, "");
					console.log("Page backwards");
					
					//Check if the page can go back
					if (help_page_array[data_id] != min) {
						help_page_array[data_id]--;
						await m.edit(arg1_embeds[help_page_array[data_id]]);
						arrowReset();
					}
					
					//Loop back and wait for a new reaction
					awaitReactions(msg, m, options, filter);
				} else if (reaction.emoji.name === "") {
					await removeReaction(m, msg, "");
					console.log("Page forwards");
					
					//Check if the page can go forwards
					if (help_page_array[data_id] != max) {
						help_page_array[data_id]++;
						await m.edit(arg1_embeds[help_page_array[data_id]]);
						arrowReset();
					}
					
					//Loop back and wait for a new reaction
					awaitReactions(msg, m, options, filter);
				} else {
					awaitReactions(msg, m, options, filter);
				}
				
				console.log(help_page_array[data_id]);
			}).catch((err) => { console.log(err) });
	}
}

//Reaction Framework
	async function scrollMessage (arg0_msg, arg1_embeds, arg2_starting_page) {
		var temp_page_id = help_page_array.length;
		
		var starting_page = 0;
		if (arg2_starting_page != undefined) {
			starting_page = arg2_starting_page;
		}
		
		help_page_array.push(starting_page);
		
		const options = {
			limit: 60 * 1000,
			min: 0,
			max: arg1_embeds.length-1,
			arg1_embeds: arg1_embeds,
			type: "help message",
			data_id: temp_page_id,
			prompt_string: ""
		}
		
		const m = await arg0_msg.channel.send(arg1_embeds[starting_page]);
		
		if (arg1_embeds.length > 1) {
			if (arg2_starting_page == 0) {
				await m.react("");
			} else if (arg2_starting_page != 0 && arg2_starting_page != arg1_embeds.length-1) {
				await m.react("");
				await m.react("");
			} else {
				await m.react("");
			}
		}
		
		const filter = (reaction, user) => {
			return ["", ""].includes(reaction.emoji.name) && user.id == arg0_msg.author.id;
		}
								
		awaitReactions(arg0_msg, m, options, filter);
	}
	
	async function printNumberPrompt (arg0_msg, arg1_prompt, arg2_min, arg3_max, arg4_data_key) {
		//Number, [Debug], Confirmation
		
		const options = {
			limit: 60 * 1000,
			min: arg2_min,
			max: arg3_max,
			prompt_string: arg1_prompt
		}
		
		const m = await arg0_msg.channel.send(arg1_prompt + "\nType `cancel` to cancel this command.");
		
		//Text input as number
		console.log(arg0_msg.author.id);
		const stringFilter = a => a.author.id === arg0_msg.author.id;
		
		//Regular input
		const collector = arg0_msg.channel.createMessageCollector(stringFilter, { time: 60000 });
		
		collector.on("collect", a => {
			console.log("Number collected: " + parseInt(a.content));
			if (a.content.indexOf(bot_prefix) == -1) {
				if (a.content == "cancel") {
					data_prompt_array[arg4_data_key] = "cancelled";
					collector.stop();
				} else if (Array.isArray(data_prompt_array[arg4_data_key])) {
					if (isNaN(parseInt(a.content))) {
						m.channel.send("You must specify a valid number!");
						console.log("Not recognised as number.");
					} else {
						console.log("Recognised as number.");
						if (parseInt(a.content) < options.min) {
							m.channel.send("The number you have specified was too small! The smallest number you can use is **" + options.min + "**.");
						} else if (parseInt(a.content) > options.max) {
							m.channel.send("The number you have specified was too large! The largest number you may use is **" + options.max + "**.");
						} else {
							console.log("Number output: " + Math.ceil(parseInt(a.content)));
							if (data_prompt_array[arg4_data_key] == undefined) {
								data_prompt_array[arg4_data_key] = [Math.ceil(parseInt(a.content))];
							} else {
								data_prompt_array[arg4_data_key].push(Math.ceil(parseInt(a.content)));
							}
							collector.stop();
						}
					}
				}
			}
		});
		
		collector.on("end", a => {
			if (a.size == 0) {
				data_prompt_array[arg4_data_key].push(arg2_min);
			}
		});
	}
	
	async function printStringPrompt (arg0_msg, arg1_prompt, arg2_minimum, arg3_maximum, arg4_data_key, arg5_mention) {
		//Number, [Debug], Confirmation
		
		const options = {
			limit: 60 * 1000
		}
		
		const m = await arg0_msg.channel.send(arg1_prompt + "\nType `cancel` to cancel this command.");
		
		//Text input
		console.log(arg0_msg.author.id);
		const stringFilter = a => a.author.id === arg0_msg.author.id;
		
		//Regular input
		const collector = arg0_msg.channel.createMessageCollector(stringFilter, { time: 60000 });
		
		collector.on("collect", a => {
			if (a.content.indexOf(bot_prefix) == -1) {
				if (a.content == "cancel") {
					data_prompt_array[arg4_data_key] = "cancelled";
					collector.stop();
				} else if (Array.isArray(data_prompt_array[arg4_data_key])) {
					console.log(a.content + "\nLength: " + a.content.length);
					if (a.content.length >= arg2_minimum) {
						if (a.content.length <= arg3_maximum) {
							
							if (arg5_mention == undefined) {
								if (data_prompt_array[arg4_data_key] == undefined) {
									data_prompt_array[arg4_data_key] = [a.content];
									collector.stop();
								} else {
									data_prompt_array[arg4_data_key].push(a.content);
									console.log("Input collected: " + a.content);
									collector.stop();
								}
							} else {
								if (parseNumber(parseInt(returnMention(a.content))) != "NaN") {
									if (data_prompt_array[arg4_data_key] == undefined) {
										data_prompt_array[arg4_data_key] = [returnMention(a.content)];
										collector.stop();
									} else {
										console.log("Mention: " + returnMention(a.content));
										data_prompt_array[arg4_data_key].push(returnMention(a.content));
										console.log("Mention was returned as: " + returnMention(a.content));
										collector.stop();
									}
								} else {
									m.channel.send("You must ping a valid user!");
								}
							}
						} else {
							m.channel.send("The text you have specified exceeded the maximum of **" + arg3_maximum + "** characters!");
						}
					} else {
						m.channel.send("The text you have specified must at least be **" + arg2_minimum + "** characters in length!");
					}
				}
			}
		});
		
		collector.on("end", a => {
			if (Array.isArray(data_prompt_array[arg4_data_key])) {
				if (a.size == 0) {
					if (arg5_mention != true) {
						data_prompt_array[arg4_data_key].push("");
					} else {
						data_prompt_array[arg4_data_key].push("213287117017710593");
					}
				}
			}
		});
	}
	
	async function getArguments (arg0_msg, arg1_prompts, arg2_code) {
		var msg = arg0_msg;
		
		/*
		Building prompt (as an example):
		
		arg1_prompts: [
			["text", "**Which city would you like to place your buildings in?**\nUse `$city-list` for a list of cities."], 
			["text", "**Which building would you like to build?**\nUse `$build list` for a valid list of buildings."], 
			["number", "**How many buildings would you like to build?", "minimum: 1"]
		]
		*/
		
		//Logic Loop - Hacky, but convenient
		
		var command_executed = false;
		var arguments_fetched = 0;
		var prompts_sent = [];
		var data_key = data_prompt_array.current_key;
		
		for (var i = 0; i < arg1_prompts.length; i++) {
			prompts_sent.push(false);
		}
		
		data_prompt_array.current_key++;
		data_prompt_array[data_key] = [];
		
		setInterval(function(){
			if (command_executed == false) {
				arguments_fetched = data_prompt_array[data_key].length;
				console.log("Arguments fetched: " + data_prompt_array[data_key]);
				
				if (Array.isArray(data_prompt_array[data_key])) {
					if (arguments_fetched < arg1_prompts.length) {
						console.log("Total prompts: " + arg1_prompts.length);
						var argument_type = arg1_prompts[arguments_fetched][0];
						
						if (argument_type == "number") {
							var has_minimum = [false, 1]; //lol 64 bit limit
							var has_maximum = [false, 18446744073709551616];
							
							for (var i = 0; i < arg1_prompts[arguments_fetched].length; i++) {
								if (arg1_prompts[arguments_fetched][i].match(/(minimum:)+/)) {
									has_minimum[0] = true;
									has_minimum[1] = parseInt(arg1_prompts[arguments_fetched][i].replace(/(minimum:)+/, ""));
								} else if (arg1_prompts[arguments_fetched][i].match(/(maximum:)+/)) {
									has_maximum[0] = true;
									has_maximum[1] = parseInt(arg1_prompts[arguments_fetched][i].replace(/(maximum:)+/, ""));
								}
							}
							
							//Send numeric prompt only once
							if (prompts_sent[arguments_fetched] == false) {
								printNumberPrompt(msg, arg1_prompts[arguments_fetched][1].replace(/\$/g, bot_prefix), has_minimum[1], has_maximum[1], data_key);
							}
							prompts_sent[arguments_fetched] = true;
						} else if (argument_type == "text") {
							var has_minimum = [false, 1];
							var has_maximum = [false, 2000];
							
							for (var i = 0; i < arg1_prompts[arguments_fetched].length; i++) {
								if (arg1_prompts[arguments_fetched][i].match(/(minimum:)+/)) {
									has_minimum[0] = true;
									has_minimum[1] = parseInt(arg1_prompts[arguments_fetched][i].replace(/(minimum:)+/, ""));
								} else if (arg1_prompts[arguments_fetched][i].match(/(maximum:)+/)) {
									has_maximum[0] = true;
									has_maximum[1] = parseInt(arg1_prompts[arguments_fetched][i].replace(/(maximum:)+/, ""));
								}
							}
							
							//Send textual prompt only once
							if (prompts_sent[arguments_fetched] == false) {
								console.log("Minimum: " + has_minimum[1]);
								printStringPrompt(msg, arg1_prompts[arguments_fetched][1].replace(/\$/g, bot_prefix), has_minimum[1], has_maximum[1], data_key);
							}
							prompts_sent[arguments_fetched] = true;
						} else if (argument_type == "mention") {
							//Send mention prompt only once
							if (prompts_sent[arguments_fetched] == false) {
								printStringPrompt(msg, arg1_prompts[arguments_fetched][1].replace(/\$/g, bot_prefix), 1, 2000, data_key, true);
							}
							prompts_sent[arguments_fetched] = true;
						}
					} else {
						var author_id = msg.author.id;
						var arg = data_prompt_array[data_key];
						
						eval(arg2_code);
						command_executed = true;
					}
				} else {
					msg.channel.send("<:cancel:725550245672517734> Command cancelled.");
					command_executed = true;
				}
			}
		},100);
	}

client.on('message', async (message) => {
	//Get arguments
	var arg = [];
	
	//Initialisation end
	
	username = message.author.username;
	user_id = message.author.id;
    input = message.content;
	
	//Parse arguments
	var temp_arg = message.content.replace(/ +(?= )/g, "");
	temp_arg = temp_arg.split("");
	
	//Check for quotation marks
	function splitCommandLine(commandLine) {
		var spaceMarker = '<SP>' ;
		while( commandLine.indexOf( spaceMarker ) > -1 ) spaceMarker += '@' ;

		var noSpacesInQuotes = commandLine.replace( /"([^"]*)"?/g, ( fullMatch, capture ) => {
			return capture.replace( / /g, spaceMarker ) ;
		});
		var mangledParamArray = noSpacesInQuotes.split( / +/ ) ;
		var paramArray = mangledParamArray.map( ( mangledParam ) => {
			return mangledParam.replace( RegExp( spaceMarker, 'g' ), ' ' ) ;
		});

		return paramArray;
	}
	
	console.log(arg.join(", "));
	arg = splitCommandLine(message.content);
	console.log("Author: " + username);
	console.log(input);
	console.log("Arguments: " + arg.join(", "));
	console.log(bot_prefix);
	
	if (arg[0].indexOf(bot_prefix) != -1) {
		console.log("Command detected!");
		//General commands
		{
			//Help commands
			{
				if (equalsIgnoreCase(arg[0], "customisation")) { //$customisation
					var nation_warning = "";
					if (main.users[returnMention(user_id)] == undefined) {
						nation_warning = "_You don't have a nation yet! Type_ `" + bot_prefix + "found <nation name>` _to get started._\n\n";
					}
					
					var customisation_help_warning = (nation_warning + "<:old_map:716821884867444746> **Rename Your Nation:** `$rename <name>`\nMessed up? Change your country's name.\n\n<:old_scroll:716828676880334881> **Change Your Motto:** `$set-motto <motto>`\nA new slogan to inspire the masses.\n\n<:infamy:716817688453709905> **Import A New Flag:** `$set-flag <image URL>`\nFor that flag I die!\n\n<:government:716817688693047306> **Set Your Nation's Colour:** `$set-colour <r> <g> <b>`\nChange your nation's colour to something else using RGB colour codes.\n\n<:culture:758424912049864784> **Customise Your Culture:** `$rename-culture <name>`\nA new label by which to identify your people.").replace(/\$/g, bot_prefix);
					const embed_customisation = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Customisation Menu:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(customisation_help_warning)
						.setTimestamp()
						.setFooter('To access this menu again, type $customisation.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					message.channel.send(embed_customisation);
				}
				
				if (equalsIgnoreCase(arg[0], "help") || equalsIgnoreCase(arg[0], "hotbar")) { //$help
					var nation_warning = "";
					if (main.users[returnMention(user_id)] == undefined) {
						nation_warning = "_You don't have a nation yet! Type_ `" + bot_prefix + "found <nation name>` _to get started._\n\n";
					}
					
					var general_help_string = (nation_warning + "<:old_map:716821884867444746> **Nation Overview:** `$overview`\nAccess your nation's interface.\n\n<:old_scroll:716828676880334881> **Create A Nation:** `$found <name>`\nFound a new nation.\n\n<:building:716827579650408538> **Next Round:** `$next-round`\nCheck the amount of time remaining until the next round.").replace(/\$/g, bot_prefix);
					const embed_help = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Help Menu:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(general_help_string)
						.setTimestamp()
						.setFooter('To access this menu again, type $help.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
								
					message.channel.send(embed_help);
				}
				
				if (equalsIgnoreCase(arg[0], "admin-help")) {
					if (hasRole(message, authorised_role)) {
						var admin_help_string = (":ship: `$blockade <@user>`\nToggle a user's blockade status.\n\n:guardsman: `$battle <@user> <attacking army> <@user> <defending army> <Province ID>`\nInitiate a battle in the selected province.\n\n:inbox_tray: `$create <@user> [number] <material>`\nGive resources to a player.\n\n:computer: `$eval <key> <value>`\nHighly unstable command used for editing player data values.\n\n:outbox_tray: `$remove <@user> [int] <material>`\nSubtract resources from a player's inventory.\n\n:clock: `$reset-rounds`\nReset the rounds on the server.\n\n:game_die: `$roll [min] <max>`\nRoll some dice.\n\n:speech_balloon: `$set-announcements-channel <Channel ID>`\nSet the announcements channel to a certain ID.\n\n:pencil: `$set-prefix <string>`\nChange the bot prefix. **Warning!** Help command strings will not be changed.\n\n:clock: `$set-round-time <seconds>`\nChange the round time.\n\n:park: `$transfer-province <@receiving country> <@original country> <Province ID>`\nTransfer a province between users.").replace(/\$/g, bot_prefix);
						const embed_help = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Admin Help Menu:\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(admin_help_string)
							.setTimestamp()
							.setFooter('To access this menu again, type $admin-help.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
								
						message.channel.send(embed_help);
					} else {
						message.channel.send("You do not have permissions to carry out this command!");
					}
				}
			}
			
			if (equalsIgnoreCase(arg[0], "roll")) { //$roll
				if (arg.length == 2) {
					//message.channel.send
					if (arg[1].indexOf("-") == -1) { //$roll arg1
						message.channel.send("You rolled a **" + randomNumber(1, parseInt(arg[1])) + "**.");
					} else { //$roll arg1-arg2
						var subargs = arg[1].split("-");
						message.channel.send("You rolled a **" + randomNumber(subargs[0], subargs[1]) + "**.");
					}
				} else if (arg.length == 3) {
					message.channel.send("You rolled a **" + randomNumber(parseInt(arg[1]), parseInt(arg[2])) + "**.");
				}
			}
		}
		
		//Administrative commands
		{
			if (hasRole(message, authorised_role)) {
				if (equalsIgnoreCase(arg[0], "add-pops")) { //$add-pops [@user] <number> <pops>
					if (arg.length == 3) {
						var target_user = returnMention(user_id);
						addPops(target_user, arg[1], arg[2]);
					} else if (arg.length > 3) {
						var target_user = returnMention(arg[1]);
						addPops(target_user, arg[2], arg[3]);
					} else {
						message.channel.send("Invalid amount of arguments.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "console")) { //$console <JS>
					var full_code = [];
					for (var i = 1; i < arg.length; i++) {
						full_code.push(arg[i]);
					}
					var quick_script = full_code.join(" ").toString();
					eval(quick_script);
					message.channel.send("Console command executed. Warning! This command can be highly unstable if not used correctly.");
				}
				
				if (equalsIgnoreCase(arg[0], "create")) { //$create @user int material
					if (arg.length > 1) {
						var target_user = returnMention(arg[1]);
						var material_exists = false;
						
						for (var i = 0; i < config.materials.length; i++) {
							if (config.materials[i] == arg[3]) {
								material_exists = true;
							}
						}
						
						if (material_exists) { //Execute command
							modifyItem(target_user, arg[2], arg[3], "add");
							console.log(JSON.stringify(main));
							message.channel.send("You gave " + arg[2] + " " + arg[3] + " to <@!" + target_user + ">.");
						} else {
							message.channel.send("Material '" + arg[3] + "' was not found.");
						}
					} else {
						message.channel.send("Invalid amount of arguments!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "eval")) { //$eval <@user> [property] [value]
					if (arg.length == 4) {
						var target_user = returnMention(arg[1]);
						eval("main.users['" + target_user + "']" + arg[2] + " = " + arg[3] + ";");
						message.channel.send("Eval command executed. Warning! This command can be highly unstable if not used correctly.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "pass-turn")) { //$pass-turn
					main.lastTurn = main.lastTurn-(turn_timer*1000);
				}
				
				if (equalsIgnoreCase(arg[0], "remove") || equalsIgnoreCase(arg[0], "delete")) { //$remove @user int material
					if (arg.length > 1) {
						var target_user = returnMention(arg[1]);
						var material_exists = false;
						
						for (var i = 0; i < config.materials.length; i++) {
							if (config.materials[i] == arg[3]) {
								material_exists = true;
							}
						}
						
						if (material_exists) { //Execute command
							modifyItem(target_user, arg[2], arg[3], "remove");
							console.log(JSON.stringify(main));
							message.channel.send("You deleted " + arg[2] + " " + arg[3] + " from <@!" + target_user + ">.");
						} else {
							message.channel.send("Material '" + arg[3] + "' was not found.");
						}
					} else {
						message.channel.send("Invalid amount of arguments!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "research-all")) { //$research-all
					var target_user = returnMention(user_id);
					researchAllTechs(target_user, message);
				}
				
				if (equalsIgnoreCase(arg[0], "unlock-all-reforms")) { //$unlock-all-reforms
					if (arg.length == 1) {
						var target_user = returnMention(user_id);
						unlockAllReforms(target_user, message);
					} else {
						var target_user = returnMention(arg[1]);
						unlockAllReforms(target_user, message);
					}
				}
				
				//Combat functions
				{
					if (equalsIgnoreCase(arg[0], "transfer-province")) { //$transfer-province [@user] [@user] <id>
						if (arg.length == 4) {
							var target_user = returnMention(arg[1]);
							var receiving_user = returnMention(arg[2]);
							
							transferProvince(receiving_user, arg[3], target_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Mention the receiving country of the province:**"],
									["mention", "**Mention the original province owner:**"],
									["text", "**Please input the province in question:**"]
								],
								'transferProvince(arg[0], arg[2], arg[1], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "battle") || equalsIgnoreCase(arg[0], "combat")) { //$battle [@attacking user] [army name] [@defending user] [army name] [province]
					//function combat (defending arg0_user, defending arg1_army, attacking arg2_user, attacking arg3_army, arg4_province, arg5_msg)
						if (arg.length == 6) {
							var target_user = returnMention(arg[1]);
							var receiving_user = returnMention(arg[3]);
							
							combat(receiving_user, arg[4], target_user, arg[2], arg[5], message);
						} else {
							getArguments(message,
								[
									["mention", "**Mention the attacking user:**"],
									["mention", "**Mention the defending user:**"],
									["text", "**Please input the attacking user's army:**"],
									["text", "**Please input the defending user's army:**"],
									["text", "**Please input the province where the battle is occurring:**"]
								],
								'combat(arg[1], arg[3], arg[0], arg[2], arg[4], msg);'
							);
						}
					}
				}
			}
		}
		
		//Country commands
		{
			//Resolve command
			if (equalsIgnoreCase(arg[0], "resolve")) { //$resolve <id>
				var target_user = returnMention(user_id);
				
				if (main.users[target_user] != undefined) {
					if (arg.length > 1) {
						resolveEvent(target_user, arg[1], message);
					} else {
						getArguments(message,
							[
								["text", "**Input the option of your choice:** (Check your DMs if you don't know what it is)."]
							],
							'resolveEvent(author_id, arg[0], msg);'
						);
					}
				}
			}
			
			//First Minister (Moderator)
			if (hasRole(message, '  Triumph & Tragedy')) {
				if (equalsIgnoreCase(arg[0], "found") || equalsIgnoreCase(arg[0], "rename")) { //$found <country_name>
					var target_user = returnMention(user_id);
					var just_registered = false;
					
					if (arg.length > 1) {
						if (main.users[target_user] == undefined) {
							just_registered = true;
						}
						initUser(target_user);
						var full_name = [];
						for (var i = 1; i < arg.length; i++) {
							full_name.push(arg[i]);
						}
						if (full_name.join(" ").length < 101) {
							if (main.users[target_user].at_war.length < 1) {
								let user = client.users.cache.find(user => user.id.toString() == target_user);
								main.users[target_user].name = full_name.join(" ");
								
								if (just_registered) {
									if (user != undefined) {
										user.send("You have successfully been registered as **" + main.users[target_user].name + "**!\nDo `" + bot_prefix + "government <government>` to set your government type. For a list of available government types, type `" + bot_prefix + "governments`.\n\nAfter you're done setting up your nation, type in `" + bot_prefix + "settle <Prov ID>` to inform Vis of where you want your capital city to be.\n\nAfterwards, make sure to found your capital city by typing in `" + bot_prefix + "city-new <Province ID> <city name>`.\nAfter typing all of these commands and thereby finishing setting up your nation, type `" + bot_prefix + "stats` to view your new country. Make sure that these commands are typed in a public channel! They will not work in DMs.\n");
									}
									message.channel.send("You have successfully been registered as **" + main.users[target_user].name + "**!\nDo `" + bot_prefix + "government <government>` to set your government type. For a list of available government types, type `" + bot_prefix + "governments`.\n\nAfter you're done setting up your nation, type in `" + bot_prefix + "settle <Prov ID>` to inform Vis of where you want your capital city to be.\n\nAfterwards, make sure to found your capital city by typing in `" + bot_prefix + "city-new <Province ID> <city name>`.\nAfter typing all of these commands and thereby finishing setting up your nation, type `" + bot_prefix + "stats` to view your new country.");
									localisation.push(main.users[target_user].culture);
									printEvent(target_user, "emergence_of_a_nation");
									main.users[target_user].culture = full_name.join(" ");
									main.users[target_user].accepted_cultures.push(full_name.join(" "));
								} else {
									if (user != undefined) {
										user.send("You renamed your country to **" + main.users[target_user].name + "**.");
										displaySVG(returnChannel(map_channel));
									}
								}
								for (var i = 0; i < config.resource_list.length; i++) {
									main.users.global[config.resource_list[i][0] + "_buy_price"] = Math.ceil(main.users.global[config.resource_list[i][0] + "_buy_price"]*0.9);
									main.users.global[config.resource_list[i][0] + "_sell_price"] = Math.ceil(main.users.global[config.resource_list[i][0] + "_sell_price"]*1.1);
								}
							} else {
								message.channel.send("You cannot change your name in times of war!");
							}
						} else {
							message.channel.send("Your name exceeded the maximum of 100 characters!");
						}
					} else {
						message.channel.send("Your country must have a name!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "rename-culture")) { //$rename-culture <name>
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (arg.length > 1) {
							renameCulture(target_user, arg[1], message);
						} else {
							getArguments(message,
								[
									["text", "**What would you like your nation's culture to be named?**"],
								],
								'renameCulture(author_id, arg[0], msg);'
							);
						}
					} else {
						message.channel.send("You need a country in order to have a culture to rename!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "set-motto")) { //$set-motto <motto>
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (arg.length > 1) {
							initUser(target_user);
							var full_name = [];
							for (var i = 1; i < arg.length; i++) {
								full_name.push(arg[i]);
							}
							if (full_name.join(" ").length < 251) {
								main.users[target_user].motto = full_name.join(" ");
								message.channel.send("You have set your motto to **" + main.users[target_user].motto + "**.");
							} else {
								message.channel.send("Your motto exceeded the maximum of 250 characters!");
							}
						} else {
							getArguments(message,
								[
									["text", "**What would you like your country's motto to be?**", "minimum: 1", "maximum: 250"],
								],
								'main.users[author_id].motto = arg[0]; msg.channel.send("You have set your motto to **" + main.users[author_id].motto + "**.");'
							);
						}
					} else {
						message.channel.send("You first need a country in order to have a national motto!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "set-colour")) { //$set-colour r g b
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (arg.length > 3) {
							if (parseInt(arg[1]) >= 0 && parseInt(arg[1]) <= 255 && parseInt(arg[2]) >= 0 && parseInt(arg[2]) <= 255 && parseInt(arg[3]) >= 0 && parseInt(arg[3]) <= 255) {
								main.users[target_user].colour = [parseInt(arg[1]), parseInt(arg[2]), parseInt(arg[3])];
								message.channel.send("You have set your RGB colour to **" + main.users[target_user].colour.join(", ") + "**.");
								displaySVG(returnChannel(map_channel));
							}	
						} else {
							getArguments(message,
								[
									["number", "**Please insert the R code of your colour:**", "minimum: 1", "maximum: 255"],
									["number", "**Please insert the G code of your colour:**", "minimum: 1", "maximum: 255"],
									["number", "**Please insert the B code of your colour:**", "minimum: 1", "maximum: 255"],
								],
								'main.users[author_id].colour = [parseInt(arg[0]), parseInt(arg[1]), parseInt(arg[2])]; msg.channel.send("You have set your RGB colour to **" + main.users[author_id].colour.join(", ") + "**."); displaySVG(returnChannel(map_channel));'
							);
						}
					}
				}
				
				if (equalsIgnoreCase(arg[0], "set-flag")) { //$set-flag <link>
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (arg.length > 1) {
							if (arg[1].indexOf(".png") != -1 || arg[1].indexOf(".jpg") != -1 || arg[1].indexOf(".jpeg") != -1) {
								main.users[target_user].flag = arg[1];
								message.channel.send("**You have successfully changed your flag!** Type `" + bot_prefix + "stats` to view it.");
							} else {
								message.channel.send("Your flag must be in .png, .jpg, or .jpeg form! Only URLs are accepted.");
							}
						} else {
							message.channel.send("You must specify a URL at the end of your command!");
						}
					} else {
						message.channel.send("You need to have a nation first before having a flag!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "government")) { //$government [listgovernment_type]
					var target_user = returnMention(user_id);
					if (arg.length == 2 && main.users[target_user] != undefined) {
						if (arg[1] == "list") {
							message.channel.send("Valid governments: " + config.government_list.join(", "));
						} else {
							if (main.users[target_user].government == "anarchy") {
								var government_exists = false;
								var government_valid = false;
								
								for (var i = 0; i < config.government_list.length; i++) {
									if (config.government_list[i] == arg[1].toLowerCase()) {
										government_exists = true;
									}
								}
								
								for (var i = 0; i < main.users[target_user].available_governments.length; i++) {
									if (main.users[target_user].available_governments[i] == arg[1]) {
										government_valid = true;
									}
								}
								
								if (government_exists) {
									if (government_valid) {
										message.channel.send("Your government has been changed to: **" + config.governments[arg[1]].name[0].toLowerCase() + "**.");
										setGovernment(main.users[target_user], arg[1].toLowerCase());
										main.users[target_user]["politics"][arg[1]] = 100;
									} else {
										message.channel.send("You can't start off with those ideologies!");
									}
								} else {
									message.channel.send("That government does not exist!");
								}
							} else {
								message.channel.send("You can't change your government on a whim!");
							}
						}
					} else {
						message.channel.send("Too few arguments were included in your command. Please try again.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "governments")) { //$governments
					var target_user = returnMention(user_id);
					printGovernmentList(target_user, message);
				}
				
				if (equalsIgnoreCase(arg[0], "cb")) { //$cb
					var target_user = returnMention(user_id);
					printCBList(target_user, message);
				}
				
				if (equalsIgnoreCase(arg[0], "politics")) { //$politics view <@user>
					if (arg.length == 2) {
						if (arg[1].toLowerCase() == "view") {
							if (arg.length == 2) {
								var target_user = returnMention(user_id);
								printInterface(target_user, message, 4);
							} else if (arg.length == 3) {
								var target_user = returnMention(arg[2]);
								printInterface(target_user, message, 4);
							} else {
								getArguments(message,
									[
										["mention", "**Who's internal politics would you like to view?**"],
									],
									'printInterface(arg[0], msg, 4);'
								);
							}
						} else if (arg[1].toLowerCase() == "support") {
							getArguments(message,
								[
									["text", "**Which political party would you like to support?**"],
								],
								'supportParty(author_id, arg[0], msg);'
							);
						}
					} else if (arg.length == 3) { //$politics support <party>
						var target_user = returnMention(user_id);
						if (arg[1].toLowerCase() == "support") {
							supportParty(target_user, arg[2], message);
						}
					}
				}
			
				if (equalsIgnoreCase(arg[0], "inv") || equalsIgnoreCase(arg[0], "inventory")) { //$inv <@user>
					if (arg.length == 1) {
						var target_user = returnMention(user_id);
						printInv(target_user, username, message);
					} else if (arg.length == 2) {
						var target_user = returnMention(arg[1]);
						printInv(target_user, username, message);
					} else {
						getArguments(message,
							[
								["mention", "**Who's inventory would you like to view?**"],
							],
							'printInv(author_id, arg[0], msg)'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "industry") || equalsIgnoreCase(arg[0], "buildings")) { //$industry <@user>
					if (arg.length == 1) {
						var target_user = returnMention(user_id);
						printBuildings(target_user, username, message);
					} else if (arg.length == 2) {
						var target_user = returnMention(arg[1]);
						printBuildings(target_user, username, message);
					} else {
						getArguments(message,
							[
								["mention", "**Who's industry would you like to view?**"],
							],
							'printBuildings(author_id, arg[0], msg)'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "craft")) { //$craft [int] <item>
					var target_user = returnMention(user_id);
					if (arg.length == 2) {
						var target_user = returnMention(user_id);
						if (arg[1] == "list") {
							printCraftList(target_user, message);
						} else {
							craft(target_user, message, arg[1], 1);
						}
					} else if (arg.length == 3) {
						craft(target_user, message, arg[2], arg[1]);
					} else {
						getArguments(message,
							[
								["text", "**What would you like to craft?**\nDo `$craft list` for a full list of recipes."],
								["number", "**How much of this unit would you like to craft?**"]
							],
							'craft(author_id, msg, arg[0], arg[1]);'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "build")) { //$build [int] <building> <city>
					//arg0_user, arg1_msg, arg2_building, arg3_amount, arg4_city
					var target_user = returnMention(user_id);
					if (arg.length == 2 && arg[1] == "list") {
						printBuildList(target_user, message);
					} else if (arg.length == 3) {
						var target_user = returnMention(user_id);
						build(target_user, message, arg[1], 1, arg[2]);
					} else if (arg.length > 3) {
						build(target_user, message, arg[2], arg[1], arg[3]);
					} else {
						getArguments(message,
							[
								["text", "**What type of building would you like to build?**\nDo `$build list` for a full list of buildings."],
								["number", "**How many buildings do you wish to build?**"],
								["text", "**Which city should these buildings go in?**\nDo `$city-list` for a full list of your cities."]
							],
							'build(author_id, msg, arg[0], arg[1], arg[2]); console.log(arg[0] + ", " + arg[1] + ", " + arg[2]);'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "mine")) { //$mine [int]
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (main.users[target_user].government == "") {
							message.channel.send("You don't even have a government!");
						} else {
							if (arg.length == 1) {
								//(arg0_user, arg1_msg, arg2_actions)
								mine(target_user, message, 1);
							} else if (arg.length == 2) {
								mine(target_user, message, parseInt(arg[1]));
							} else {
								
								getArguments(message,
									[
										["number", "**How many times would you like to mine?**", "minimum: 1", "maximum: 1000"]
									],
									'mine(author_id, msg, arg[0]);'
								);
							}
						}
					} else {
						message.channel.send("You don't even have a country!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "forage") || equalsIgnoreCase(arg[0], "chop")) { //$forage [int]
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (main.users[target_user].government == "") {
							message.channel.send("You don't even have a government!");
						} else {
							if (arg.length == 1) {
								//(arg0_user, arg1_msg, arg2_actions)
								forage(target_user, message, 1);
							} else if (arg.length == 2) {
								forage(target_user, message, parseInt(arg[1]));
							} else {
								getArguments(message,
									[
										["number", "**How much wood would you like to chop down?**", "minimum: 1", "maximum: 1000"]
									],
									'chop(author_id, msg, arg[0]);'
								);
							}
						}
					} else {
						message.channel.send("You don't even have a country!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "ledger")) { //$ledger
					var target_user = returnMention(user_id);
					
					printLedger(target_user, message);
				}
				
				if (equalsIgnoreCase(arg[0], "units") || equalsIgnoreCase(arg[0], "reserves")) { //$military <@user>
					if (arg.length == 1) {
						var target_user = returnMention(user_id);
						printMilitary(target_user, username, message);
					} else if (arg.length == 2) {
						var target_user = returnMention(arg[1]);
						printMilitary(target_user, arg[1], message);
					} else {
						getArguments(message,
							[
								["mention", "**Please ping a user:**"],
							],
							'printMilitary(arg[0], arg[0], message);'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "set-tax") || equalsIgnoreCase(arg[0], "settax")) { //$set-tax [int]
					if (arg.length == 2) {
						var target_user = returnMention(user_id);
						var new_tax = Math.ceil(parseInt(arg[1]));
						if (new_tax/100 <= main.users[target_user].max_tax && main.users[target_user] != undefined) {
							if (new_tax != NaN) {
								main.users[target_user].tax_rate = new_tax/100;
								message.channel.send("Your tax rate has been set to **" + Math.ceil(arg[1]) + "%**.");
							} else {
								message.channel.send("You must specify a number!");
							}
						} else {
							message.channel.send("Your government type doesn't allow for such a high tax rate!");
						}
					} else {
						getArguments(message,
							[
								["number", "**What would you like your tax rate to be set to (in percentage)?**", "minimum: 1", "maximum: 100"],
							],
							'main.users[author_id].tax_rate = Math.ceil(arg[0]); msg.channel.send("Your tax rate has been set to **" + Math.ceil(arg[0] + "%**.");'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "coup")) { //$coup
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (arg.length == 2) {
							if (main.users[target_user].overthrow_this_turn == "") {
								coup(target_user, arg[1], message);
							} else {
								message.channel.send("A coup has already been initiated! It will occur next turn.");
							}
						} else {
							getArguments(message,
								[
									["text", "**Please specify an ideology:**"],
								],
								'coup(author_id, arg[0], msg);'
							);
						}
					}
				}
				
				if (equalsIgnoreCase(arg[0], "vote")) { //$vote
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (main.users[target_user].government == "constitutional_monarchy" || main.users[target_user].government == "democracy") {
							var vote = randomNumber(0, 100);
							if (vote >= 50) {
								message.channel.send("The motion was passed, with :thumbsup: **" + vote.toString() + "** ayes, and :thumbsdown: **" + (100-vote).toString() + "** nays.");
							} else {
								message.channel.send("The motion was rejected, with :thumbsup: **" + vote.toString() + "** ayes, and :thumbsdown: **" + (100-vote).toString() + "** nays.");
							}
						} else {
							message.channel.send("You aren't even a democratic nation! '100%' of your voters say yes.");
						}
					}
				}
				
				if (equalsIgnoreCase(arg[0], "next-round") || equalsIgnoreCase(arg[0], "next-turn") || equalsIgnoreCase(arg[0], "nextround") || equalsIgnoreCase(arg[0], "nextturn")) { //$next-round
					var current_date = new Date().getTime();
					var time_difference = current_date - main.lastTurn;
					
					message.channel.send("It is currently round **" + main.roundCount + "**.\n" + parseMilliseconds((turn_timer*1000)-time_difference) + " remaining until the next turn.\nIt is also the year of our Lord, **" + (1500+main.roundCount) + "**.");
				}
				
				if (equalsIgnoreCase(arg[0], "disband")) { //$disband <amount> <unit> arg0_user, arg1_msg, arg2_unit, arg3_amount
					var target_user = returnMention(user_id);
					if (arg.length == 3) {
						if (main.users[target_user] != undefined) {
							disband(target_user, message, arg[2], parseInt(arg[1]));
						} else {
							message.channel.send("You're stateless!");
						}
					} else if (arg.length == 2) {
						if (main.users[target_user] != undefined) {
							disband(target_user, message, arg[1], 1);
						} else {
							message.channel.send("You're stateless!");
						}
					} else {
						getArguments(message,
							[
								["text", "**Please specify a unit you wish to disband:**"],
								["number", "**Please specify the number of troops you wish to disband:**"]
							],
							'disband(author_id, msg, arg[0], arg[1]);'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "demolish") || equalsIgnoreCase(arg[0], "destroy")) { //$demolish <amount> <building> <city>
					var target_user = returnMention(user_id);
					if (arg.length == 4) {
						if (main.users[target_user] != undefined) {
							demolish(target_user, message, arg[2], parseInt(arg[1]), arg[3]);
						} else {
							message.channel.send("You're stateless!");
						}
					} else if (arg.length == 3) {
						if (main.users[target_user] != undefined) {
							demolish(target_user, message, arg[1], 1, arg[2]);
						} else {
							message.channel.send("You're stateless!");
						}
					} else {
						getArguments(message,
							[
								["text", "**Please specify the city in which you wish to demolish buildings.**\nType `$city-list` for a complete list of your cities.**"],
								["text", "**What type of building would you like to demolish?**\nType `$build list for a complete list of buildings."],
								["number", "**Please specify the number of buildings you wish to demolish.**"]
							],
							'demolish(author_id, msg, arg[0], arg[2], arg[1]);'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "give")) { //$give <@user> <int> <item>
					if (arg.length == 4) {
						var target_user = returnMention(arg[1]);
						var current_user = returnMention(user_id);
						console.log(target_user);
						if (main.users[target_user] != undefined && main.users[current_user] != undefined) {
							if (main.users[target_user].blockaded == undefined || main.users[current_user].blockaded == undefined) {
								give(current_user, target_user, arg[2], arg[3], "item", message);
							} else if (main.users[target_user].blockaded || main.users[current_user].blockaded == undefined) {
								message.channel.send("The person you are trying to send these items to is currently blockaded!");
							} else {
								give(current_user, target_user, arg[2], arg[3], "item", message);
							}
						}
					} else {
						//arg0_user, arg1_user2, arg2_amount, arg3_item, arg4_mode, arg5_message
						getArguments(message,
							[
								["number", "**How many items would you like to give?**"],
								["text", "**Please specify the item you wish to give:**"],
								["mention", "**Who are you planning to give these items to?**"]
							],
							'give(author_id, arg[2], arg[0], arg[1], "item", msg);'
						);
					}
				}
				
				//(arg0_user, arg1_msg, arg2_amount, arg3_type)
				if (equalsIgnoreCase(arg[0], "buy")) { //$buy <int> <item>
					var target_user = returnMention(user_id);
					
					if (arg[1] == "list") {
						printBuyList(target_user, message);
					}
					
					if (main.users[target_user] != undefined) {
						if (arg.length == 3) {
							buy(target_user, message, parseInt(arg[1]), arg[2]);
						} else if (arg.length == 2) {
							buy(target_user, message, 1, arg[1]);
						} else {
							getArguments(message,
								[
									["text", "**What resource would you like to buy?**\nType `" + bot_prefix + "buy list` for a list of valid resources."],
									["number", "**How much would you like to buy?**"],
								],
								'buy(author_id, msg, arg[1], arg[0]);'
							);
						}
					} else {
						message.channel.send("You don't even have a country!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "sell")) { //$sell <int> <item>
					var target_user = returnMention(user_id);
					
					if (arg.length == 2) {
						sell(target_user, message, 1, arg[1]);
					} else if (arg.length == 3) {
						sell(target_user, message, parseInt(arg[1]), arg[2]);
					} else {
						getArguments(message,
							[
								["text", "**What resource would you like to sell?**\nType `" + bot_prefix + "buy list` for a list of valid resources."],
								["number", "**How much would you like to sell?**"],
							],
							'sell(author_id, msg, arg[1], arg[0]);'
						);
					}
				}
				
				//Armies
				{
					//Air Orders
					{
						if (equalsIgnoreCase(arg[0], "air-raid")) { //$air-raid <@user> <province id> <air wing>
							if (arg.length > 3) {
								var target_user = returnMention(user_id);
								var receiving_user = returnMention(arg[1]);
								airRaid(target_user, arg[3], receiving_user, arg[2], message);
							} else {
								getArguments(message,
									[
										["mention", "**Please ping the user you'd like to bomb.**"],
										["text", "**What is the name of the air wing you would like to send on this mission?**"],
										["text", "**Please insert the Province ID of the designated target.**"]
									],
									'airRaid(author_id, arg[1], arg[0], arg[2], msg);'
								);
							}
						}
					}
					
					//Army Orders
					{
						if (equalsIgnoreCase(arg[0], "merge-army")) { //$merge-army <army1> <army2>
							var target_user = returnMention(user_id);
							
							if (arg.length > 2) {
								mergeArmy(target_user, message, arg[1], arg[2]);
							} else {
								getArguments(message,
									[
										["text", "**What is the name of the first army you would like to merge?**"],
										["text", "**What is the name of the second army you would like to move the first army into?**"]
									],
									'mergeArmy(author_id, msg, arg[0], arg[1]);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "move") || equalsIgnoreCase(arg[0], "move-army")) { //$move-army <army name> <province>
							var target_user = returnMention(user_id);
							
							if (arg.length > 2) {
								moveArmy(target_user, message, arg[1], arg[2]);
							} else {
								getArguments(message,
									[
										["text", "**What is the name of the army you would like to move?**"],
										["text", "**Please specify the province ID you would like to move your army to.**"]
									],
									'moveArmy(author_id, msg, arg[0], arg[1]);'
								);
							}
						}
					}
					
					//Naval Orders
					{
						if (equalsIgnoreCase(arg[0], "blockade")) { //$blockade <@user> <fleet>
							if (arg.length > 2) {
								var target_user = returnMention(user_id);
								blockade(target_user, arg[1], arg[2], "add", message);
							} else {
								getArguments(message,
									[
										["mention", "**Who would you like to blockade?**"],
										["text", "**Please insert the name of the fleet you wish to institute this blockade:**"]
									],
									'blockade(author_id, arg[0], arg[1], "add", msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "challenge-blockade")) { //$challenge-blockade <@user> <fleet>
							if (arg.length == 2) {
								var target_user = returnMention(user_id);
								challengeBlockade(target_user, target_user, arg[1], message);
							} else if (arg.length > 2) {
								var target_user = returnMention(user_id);
								var receiving_user = returnMention(arg[1]);
								challengeBlockade(target_user, receiving_user, arg[1], message);
							} else {
								getArguments(message,
									[
										["mention", "**Please ping the person you would like to free from the grips of a blockade.**"],
										["text", "**Please type out the name of the fleet you'd like to send on this endeavour.**"]
									],
									'challengeBlockade(author_id, arg[0], arg[1], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "convoy-raid")) { //$convoy-raid <@user> <name>
							if (arg.length > 1) {
								var target_user = returnMention(user_id);
								submarineRaid(target_user, arg[1], arg[2], "convoy", message);
							} else {
								getArguments(message,
									[
										["mention", "**Please ping the user you would like to raid.**"],
										["text", "**Please type out the name of the submarine flotilla you'd like to send on this mission.**"]
									],
									'submarineRaid(author_id, arg[0], arg[1], "convoy", msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "harbour-raid")) { //$harbour-raid <@user> <name>
							if (arg.length > 1) {
								var target_user = returnMention(user_id);
								submarineRaid(target_user, arg[1], arg[2], "reserves", message);
							} else {
								getArguments(message,
									[
										["mention", "**Please ping the user you would like to raid.**"],
										["text", "**Please type out the name of the submarine flotilla you'd like to send on this mission.**"]
									],
									'submarineRaid(author_id, arg[0], arg[1], "reserves", msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "lift-blockade")) { //$lift-blockade <@user> <fleet>
							if (arg.length > 2) {
								var target_user = returnMention(user_id);
								blockade(target_user, arg[1], arg[2], "remove", message);
							} else {
								getArguments(message,
									[
										["mention", "**Who would you like to lighten the blockade on?**"],
										["text", "**Please insert the name of the fleet you wish to relieve from having to enforce this blockade:**"]
									],
									'blockade(author_id, arg[0], arg[1], "remove", msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "torpedo-fleet")) { //$torpedo-fleet <@user> <name>
							if (arg.length > 1) {
								var target_user = returnMention(user_id);
								submarineRaid(target_user, arg[1], arg[2], "naval", message);
							} else {
								getArguments(message,
									[
										["mention", "**Please ping the user you would like to raid.**"],
										["text", "**Please type out the name of the submarine flotilla you'd like to send on this mission.**"]
									],
									'submarineRaid(author_id, arg[0], arg[1], "naval", msg);'
								);
							}
						}
					}
					
					if (equalsIgnoreCase(arg[0], "new-army") || equalsIgnoreCase(arg[0], "create-army") || equalsIgnoreCase(arg[0], "create-navy") || equalsIgnoreCase(arg[0], "create-air-wing")) { //$create-army <name>
						var target_user = returnMention(user_id);
						
						if (main.users[target_user] != undefined) {
							if (arg.length > 1) {
								var full_name = [];	
								for (var i = 1; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								if (full_name.join(" ").length < 101) {
									newArmy(target_user, message, full_name.join(" "));
									message.channel.send("You have created the **" + full_name.join(" ") + "**! Do `" + bot_prefix + "army-list` for a full list of all your armies.");
								} else {
									message.channel.send("Your name exceeded the maximum character limit of 100 characters!");
								}
							} else {
								getArguments(message,
									[
										["text", "**What would you like to call your new army?**"]
									],
									'newArmy(author_id, msg, arg[0]); msg.channel.send("You have created the **" + arg[0] + "**! Do `" + bot_prefix + "army-list` for a full list of your armies.");'
								);
							}
						} else {
							message.channel.send("You're currently stateless!");
						}
					}
					
					if (equalsIgnoreCase(arg[0], "transfer") || equalsIgnoreCase(arg[0], "transfer-units") || equalsIgnoreCase(arg[0], "deploy")) { //$transfer <int> <unit> <army> add-remove
						if (arg.length > 3) {
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								var full_name = [];
								for (var i = 3; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								if (parseInt(arg[1])-parseInt(arg[1]) != 0) {
									message.channel.send("You must provide a number of units!");
								} else {
									if (parseInt(arg[1] < 0)) {
										message.channel.send("Stop trying to cheese the system!");
									} else {
										editArmy(target_user, message, full_name.join(" "), parseInt(arg[1]), arg[2], "add");
									}
								}
							}
						} else if (arg.length == 3) { //$transfer <unit> <army>
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								editArmy(target_user, message, 1, arg[2], "add");
							} else {
								message.channel.send("You don't even have a country yet!");
							}
						} else {
							getArguments(message,
								[
									["text", "**Which army would you like to deploy your units in?**\nDo `$army-list` for a full list of your armies."],
									["text", "**What type of unit do you wish to deploy?**"],
									["number", "**How many troops would you like to deploy?**", "minimum: 1"]
								],
								'editArmy(author_id, msg, arg[0], arg[2], arg[1], "add");'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "relieve") || equalsIgnoreCase(arg[0], "relieve-units")) { //$relieve <int> <unit> <army> add-remove
						if (arg.length > 3) {
							var target_user = returnMention(user_id);
							var full_name = [];
							for (var i = 3; i < arg.length; i++) {
								full_name.push(arg[i]);
							}
							if (main.users[target_user] != undefined) {
								if (parseInt(arg[1])-parseInt(arg[1]) != 0) {
									message.channel.send("You must provide a number of units!");
								} else {
									if (parseInt(arg[1] > 0)) {
										message.channel.send("Stop trying to cheese the system!");
									} else {
										editArmy(target_user, message, full_name.join(" "), parseInt(arg[1]), arg[2], "remove");
									}
								}
							}
						} else if (arg.length == 3) { //$transfer <unit> <army>
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								editArmy(target_user, message, 1, arg[2], "remove");
							} else {
								message.channel.send("You don't even have a country yet!");
							}
						} else {
							getArguments(message,
								[
									["text", "**Which army would you like to withdraw your units from?**\nDo `$army-list` for a full list of your armies."],
									["text", "**What type of unit do you wish to place back in the reserves?**"],
									["number", "**How many troops should go back into the reserves?**", "minimum: 1"]
								],
								'editArmy(author_id, msg, arg[0], arg[2], arg[1], "remove");'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "army") || equalsIgnoreCase(arg[0], "navy") || equalsIgnoreCase(arg[0], "fleet") || equalsIgnoreCase(arg[0], "flotilla") || equalsIgnoreCase(arg[0], "airforce") || equalsIgnoreCase(arg[0], "air-wing") || equalsIgnoreCase(arg[0], "airwing") || equalsIgnoreCase(arg[0], "air")) { //$army <name>
						var target_user = returnMention(user_id);
						
						if (main.users[target_user] != undefined) {
							if (arg.length > 1) {
								var full_name = [];
								for (var i = 1; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								printArmy(target_user, message, full_name.join(" ").toLowerCase());
							} else {
								getArguments(message,
								[
									["text", "**Which army would you like to inspect?**\nDo `$army-list` for a full list of your armies."]
								],
								'printArmy(target_user, msg, arg[0].toLowerCase());'
							);
							}
						} else {
							message.channel.send("You're currently stateless!");
						}
					}
					
					if (equalsIgnoreCase(arg[0], "rename-army")) { //$rename-army <old_name> <new_name>
						var target_user = returnMention(user_id);
						
						if (main.users[target_user] != undefined) {
							if (arg.length >= 3) {
								
								//Get full new name
								var full_name = [];
								for (var i = 2; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								
								if (full_name.join(" ").length <= 100) {
									renameArmy(target_user, message, arg[1], full_name.join(" "));
								} else {
									message.channel.send("Your city name exceeded the maximum character limit of 100 characters!");
								}
							} else {
								getArguments(message,
								[
									["text", "**Which army would you like to rename?**\nDo `$army-list` for a full list of your armies."],
									["text", "**What do you want the new name to be?**"]
								],
								'renameArmy(author_id, msg, arg[0], arg[1]);'
							);
							}
						} else {
							message.channel.send("You don't even have a nation!");
						}
					}
					
					if (equalsIgnoreCase(arg[0], "disband-army") || equalsIgnoreCase(arg[0], "delete-army")) { //$disband-army <name>
						var target_user = returnMention(user_id);
						
						if (main.users[target_user] != undefined) {
							if (arg.length > 1) {
								var full_name = [];
								for (var i = 1; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								deleteArmy(target_user, message, full_name.join(" "));
							} else {
								getArguments(message,
									[
										["text", "**Which army do you wish to disband?**\nDo `$army-list` for a full list of your armies."]
									],
									'deleteArmy(author_id, msg, arg[0]);'
								);
							}
						} else {
							message.channel.send("You don't even have a nation!");
						}
					}
					
					if (equalsIgnoreCase(arg[0], "army-list") || equalsIgnoreCase(arg[0], "armies")) { //$army-list
						console.log("Army list called!");
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							if (main.users[target_user] != undefined) {
								printArmies(target_user, message);
								console.log("printArmies invoked!");
							} else {
								message.channel.send("You don't even have a nation!");
							}
						} else if (arg.length == 2) {
							target_user = returnMention(arg[1]);
							if (main.users[target_user] != undefined) {
								printArmies(target_user, message);
							} else {
								message.channel.send("The user you have specified doesn't have a country!");
							}
						} else {
							getArguments(message,
								[
									["mention", "*Please ping a valid user:**"]
								],
								'printArmies(arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "mobilise")) { //$mobilise
						var target_user = returnMention(user_id);
						if (main.users[target_user] != undefined) {
							mobilise(target_user, message);
						} else {
							message.channel.send("You don't even have a nation!");
						}
					}
					
					if (equalsIgnoreCase(arg[0], "demobilise")) { //$demobilise
						var target_user = returnMention(user_id);
						if (main.users[target_user] != undefined) {
							demobilise(target_user, message);
						} else {
							message.channel.send("You don't even have a nation!");
						}
					}
				}
			
				//Cities
				{
					if (equalsIgnoreCase(arg[0], "city-new")) { //$city-new [province] [name]
						var target_user = returnMention(user_id);

						var full_name = [];
						for (var i = 2; i < arg.length; i++) {
							full_name.push(arg[i]);
						}
						
						if (full_name.join(" ").length <= 100) {
							if (main.users[target_user] != undefined) {
								var capital_exists = false;
								
								if (main.users[target_user].cities.city_array.length > 0) {
									capital_exists = true;
								}
								
								if (arg.length > 2) {
									if (main.users[target_user] != undefined) {
										
										if (capital_exists) {
											newCity(target_user, full_name.join(" "), "city", message, arg[1]);
										} else {
											newCity(target_user, full_name.join(" "), "capital", message, arg[1]);
										}
									} else {
										message.channel.send("You're currently stateless! Try registering first.");
									}
								} else {
									getArguments(message,
										[
											["text", "**What would you like to name your city?**", "minimum: 1", "maximum: 100"],
											["text", "**Please specify a province on which to settle:**"]
										],
										'if (' + capital_exists + ') { newCity(author_id, arg[0], "city", msg, arg[1]); } else { newCity(author_id, arg[0], "capital", msg, arg[1]); }'
									);
								}
							} else {
								message.channel.send("You're currently stateless!");
							}
						} else {
							message.channel.send("Your city name exceeded the maximum character limit of 100 characters!");
						}
					}

					if (equalsIgnoreCase(arg[0], "city-rename")) { //$city-rename <name> <new_name>
						var target_user = returnMention(user_id);

						var full_name = [];
						for (var i = 2; i < arg.length; i++) {
							full_name.push(arg[i]);
						}
						
						if (full_name.join(" ").length <= 100) {
							if (arg.length >= 2) {
								if (main.users[target_user] != undefined) {
									var city_exists = false;

									for (var i = 0; i < main.users[target_user].cities.city_array.length; i++) {
										if (main.users[target_user]["cities"][main.users[target_user].cities.city_array[i]].name.toLowerCase().indexOf(arg[1].toLowerCase()) != -1) {
											var old_name = main.users[target_user]["cities"][main.users[target_user].cities.city_array[i]].name;
											main.users[target_user]["cities"][main.users[target_user].cities.city_array[i]].name = full_name.join(" ");
											city_exists = true;
											message.channel.send("You have renamed **" + old_name + "** to **" + full_name.join(" ") + "**!");
										}
									}

									if (city_exists == false) {
										message.channel.send("The city that you have specified doesn't exist!");
									}
								} else {
									message.channel.send("You don't even have a nation to begin with!");
								}
							} else {
								getArguments(message,
									[
										["text", "**Specify the city which you wish to rename:**"],
										["text", "**What would you like to rename this city to?**"]
									],
									'renameCity(author_id, msg, arg[0], arg[1]);'
								);
							}
						} else {
							message.channel.send("Your city name exceeded the maximum character limit of 100 characters!");
						}
					}

					if (equalsIgnoreCase(arg[0], "city")) { //$city <@user> <city>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {

								var full_name = [];
								for (var i = 1; i < arg.length; i++) {
									full_name.push(arg[i]);
								}

								printCity(target_user, full_name.join(" "), message);
							}
						} else if (arg.length >= 3) {
							var target_user = returnMention(arg[1]);
							if (main.users[target_user] != undefined) {
								var full_name = [];
								for (var i = 2; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								printCity(target_user, full_name.join(" "), message);
							}
						} else {
							getArguments(message,
								[
									["text", "**Which city would you like to view?**"],
									["mention", "**Please ping the owner of the city:**"]
								],
								'printCity(arg[1], arg[0], msg);'
							);
						}
					}

					if (equalsIgnoreCase(arg[0], "city-list")) { //$city-list <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								printCities(target_user, message);
							}
						} else if (arg.length == 2) {
							var target_user = returnMention(arg[1]);
							if (main.users[target_user] != undefined) {
								printCities(target_user, message);
							}
						} else {
							msg.channel.send("Invalid amount of arguments.");
						}
					}
					
					if (equalsIgnoreCase(arg[0], "move-capital")) { //$move-capital <city>
						if (arg.length > 1) {
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								var full_name = [];
								for (var i = 1; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								moveCapital(target_user, full_name.join(" "), message);
							}
						} else {
							getArguments(message,
								[
									["text", "**Which city would you like to move your capital to?**"]
								],
								'moveCapital(author_id, arg[0], msg);'
							);
						}
					}
				}
				
				//Colonisation
				{
					if (equalsIgnoreCase(arg[0], "cancel-charter")) { //$cancel-charter
						var target_user = returnMention(user_id);
						
						if (equalsIgnoreCase(arg[0], "clear-peace-treaty") || equalsIgnoreCase(arg[0], "clear-peace-offer")) { //$cancel-charter <id>
							if (arg.length > 1) {
								cancelColonisation(user_id, arg[1], message);
							} else {
								getArguments(message,
									[
										["text", "**Please specify the ID of the colonial charter you wish to cancel** Type `" + bot_prefix + "colonisation` for a list of current colonial charters."]
									],
									'cancelColonisation(author_id, arg[0], msg);'
								);
							}
						}
					}
					
					if (equalsIgnoreCase(arg[0], "settle") || equalsIgnoreCase(arg[0], "colonise")) { //$settle <Prov1> <...> (arg0_user, arg1_msg, arg2_provs)
						var target_user = returnMention(user_id);
						if (arg.length > 1) {
							if (main.users[target_user] != undefined) {
								var temp_province_array = [];
								
								for (var i = 1; i < arg.length; i++) {
									temp_province_array.push(arg[i]);
								}
								
								settle(target_user, message, temp_province_array);
							} else {
								message.channel.send("You can't colonise, because you don't even have a nation!");
							}
						} else {
							message.channel.send("Invalid amount of arguments. Make sure to specify as many provinces as the unit is capable of settling.");
						}
					}
				}
				
				//Diplomacy
				{
					//Peace offers
					{
						if (equalsIgnoreCase(arg[0], "clear-peace-treaty") || equalsIgnoreCase(arg[0], "clear-peace-offer")) { //$clear-peace-offer <war name>
							if (arg.length == 2) {
								var target_user = returnMention(user_id);
								peaceOffer(target_user, arg[1], ["delete"], message);
							} else {
								getArguments(message,
									[
										["text", "**Please specify the name of the conflict for whom you wish to clear the peace offer:** Type `" + bot_prefix + "war-list` for a list of valid conflicts."]
									],
									'peaceOffer(author_id, arg[0], ["delete"], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "add-wargoal")) { //$add-wargoal <war> <wargoal> <arguments>
						
							/*
								Wargoal List (Data Structure):
								---
								status_quo: ["edit", "add", "status_quo"]
								install_government: ["edit", "add", "install_government", "nation"]
								cut_down_to_size: ["edit", "add", "cut_down_to_size", "nation"]
								liberation: ["edit", "add", "liberation"]
								puppet: ["edit", "add", "puppet", ["overlord", "puppet"]]
								retake_cores: ["edit", "add", "retake_cores", ["nation", "nation", "nation"]]
								annexation: ["edit", "add", "annexation", ["nation", ["prov1", "prov2", "prov3"]]]
							*/
							
							if (arg.length >= 2) {
								var target_user = returnMention(user_id);
								if (arg[1] == "status_quo") {
									peaceOffer(target_user, arg[1], ["edit", "add", "status_quo"], message);
								} else if (arg[1] == "install_government") {
									if (arg.length >= 3) {
										peaceOffer(target_user, arg[1], ["edit", "add", "install_government", returnMention(arg[2])], message);
									}
								} else if (arg[1] == "cut_down_to_size") {
									if (arg.length >= 3) {
										peaceOffer(target_user, arg[1], ["edit", "add", "cut_down_to_size", returnMention(arg[2])], message);
									}
								} else if (arg[1] == "liberation") {
									peaceOffer(target_user, arg[1], ["edit", "add", "liberation"], message);
								} else if (arg[1] == "puppet") {
									if (arg.length >= 4) {
										peaceOffer(target_user, arg[1], ["edit", "add", "puppet", [returnMention(arg[2]), returnMention(arg[3])]], message);
									}
								} else if (arg[1] == "retake_cores") {
									if (arg.length >= 3) {
										var all_countries = [];
										for (var i = 2; i < arg.length; i++) {
											all_countries.push(returnMention(arg[i]));
										}
										peaceOffer(target_user, arg[1], ["edit", "add", "retake_cores", all_countries], message);
									}
								} else if (arg[1] == "annexation") {
									if (arg.length >= 4) {
										var all_provinces = [];
										for (var i = 3; i < arg.length; i++) {
											all_provinces.push(arg[i]);
										}
										peaceOffer(target_user, arg[1], ["edit", "add", "annexation", [returnMention(arg[2]), all_provinces]]);
									}
								}
							} else {
								var help_wargoal_array = [];
								help_wargoal_array.push("**Oh no!** It appears that you've used this command incorrectly. Here's some example commands for various wargoals:");
								help_wargoal_array.push("---");
								help_wargoal_array.push("");
								help_wargoal_array.push("`" + bot_prefix + "add-wargoal status_quo`");
								help_wargoal_array.push("`" + bot_prefix + "add-wargoal install_government <@user>`");
								help_wargoal_array.push("`" + bot_prefix + "add-wargoal cut_down_to_size <@user>`");
								help_wargoal_array.push("`" + bot_prefix + "add-wargoal liberation`");
								help_wargoal_array.push("`" + bot_prefix + "add-wargoal puppet <@overlord> <@puppet>`");
								help_wargoal_array.push("`" + bot_prefix + "add-wargoal retake_cores <@user> [@user] [@user] <...>`");
								help_wargoal_array.push("`" + bot_prefix + "add-wargoal annexation <@user> <prov1> [prov2] [prov3] <...>`");
								message.channel.send(help_wargoal_array.join("\n"));
							}
						}
						
						if (equalsIgnoreCase(arg[0], "remove-wargoal") || equalsIgnoreCase(arg[0], "delete-wargoal")) { //$remove-wargoal <war name> <wargoal>
							var target_user = returnMention(user_id);
							
							if (arg.length >= 3) {
								peaceOffer(target_user, arg[1], ["edit", "remove", arg[2]], message);
							} else {
								getArguments(message,
									[
										["text", "**Please type the name of the war you're drafting a peace treaty for.** Type `" + bot_prefix + "war-list` for a list of valid conflicts."],
										["text", "**Type the name of the wargoal you wish to drop from the eventual peace treaty.**"]
									],
									'peaceOffer(author_id, arg[0], ["edit", "remove", arg[1]], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "send-peace-treaty") || equalsIgnoreCase(arg[0], "send-peace-offer")) {
							if (arg.length >= 2) {
								var target_user = returnMention(user_id);
								sendPeaceOffer(target_user, arg[1], message);
							} else {
								getArguments(message,
									[
										["text", "**Please type the name of the war you wish to send a peace offer for.** Type `" + bot_prefix + "war-list` for a list of valid conflicts."]
									],
									'sendPeaceOffer(author_id, arg[0], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "sign-peace-treaty") || equalsIgnoreCase(arg[0], "create-peace-offer")) { //$create-peace-offer <war name>
							if (arg.length == 2) {
								var target_user = returnMention(user_id);
								peaceOffer(target_user, arg[1], ["create"], message);
							} else {
								getArguments(message,
									[
										["text", "**Please specify the name of the conflict you wish to resolve:** Type `" + bot_prefix + "war-list` for a list of valid conflicts."]
									],
									'peaceOffer(author_id, arg[0], ["create"], msg);'
								);
							}
						}
					
						if (equalsIgnoreCase(arg[0], "view-peace-treaty") || equalsIgnoreCase(arg[0], "view-peace-offer")) {
							if (arg.length == 2) { //$view-peace-offer <war name>
								var target_user = returnMention(user_id);
								viewPeaceOffer(target_user, arg[1], message);
							} else if (arg.length == 3) { //$view-peace-offer <@user> <war name>
								var target_user = returnMention(arg[1]);
								viewPeaceOffer(target_user, arg[2], message);
							} else {
								getArguments(message,
									[
										["mention", "**Please ping the user proposing the peace treaty."],
										["text", "**Please specify a conflict you would like to view a peace proposal for. Type `" + bot_prefix + "war-list` for a list of valid conflicts."]
									],
									'viewPeaceOffer(arg[0], arg[1], msg);'
								);
							}
						}
					}
					
					if (equalsIgnoreCase(arg[0], "ally")) { //$ally <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							ally(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Please specify who you would like to send a request for an alliance to:** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'ally(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "break-ally") || equalsIgnoreCase(arg[0], "break-alliance") || equalsIgnoreCase(arg[0], "leave-faction")) { //$break-ally <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							breakAlly(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Who's alliance do you wish to leave?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'breakAlly(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "cancel-military-access")) { //$cancel-military-access <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							cancelMilitaryAccess(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Who would you like to deny military access to?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'cancelMilitaryAccess(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "cede-province")) { //$cede-province <province> <@user>
						var target_user = returnMention(user_id);
						if (arg.length > 2) {
							var ot_user = returnMention(arg[2]);
							cedeProvince(target_user, arg[1], ot_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Which province would you like to cede?**"],
									["mention", "**Who would you like to cede this province to?**"]
								],
								'cedeProvince(author_id, arg[0], arg[1], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "declare-war")) { //$declare-war <@user> <cb>
						if (arg.length == 3) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							declareWar(target_user, receiving_user, arg[2], message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to declare war upon?**"],
									["text", "**Which CB would you like to use?** Type `" + bot_prefix + "view-cb <@user>` for a list of valid casus belli."]
								],
								'declareWar(author_id, arg[0], arg[1], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "send-insult") || equalsIgnoreCase(arg[0], "decrease-relations") || equalsIgnoreCase(arg[0], "decrease-opinion") || equalsIgnoreCase(arg[0], "suspend-diplomatic-relations") || equalsIgnoreCase(arg[0], "denounce")) { //$denounce <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							decreaseRelations(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Who would you like to suspend diplomatic relations with?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'decreaseRelations(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "end-rivalry") || equalsIgnoreCase(arg[0], "thaw")) { //$end-rivalry <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							endRivalry(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Who would you like to end a rivalry with?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'endRivalry(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "liberate")) { //$liberate <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							liberate(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Who, under your control, would you like to liberate?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'liberate(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "improve-relations") || equalsIgnoreCase(arg[0], "improve-opinion")) { //$improve-relations <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							improveRelations(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Who would you like to improve relations with?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'improveRelations(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "request-military-access") || equalsIgnoreCase(arg[0], "military-access") || equalsIgnoreCase(arg[0], "mil-access")) { //$request-military-access <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							militaryAccess(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Who would you like to request military access from?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'militaryAccess(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "sign-non-aggression-pact") || equalsIgnoreCase(arg[0], "non-aggression-pact") || equalsIgnoreCase(arg[0], "non-agg-pact")) { //$non-aggression-pact <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							nonAggressionPact(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Who would you like to sign a non-aggression pact with?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'nonAggressionPact(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "justify-war") || equalsIgnoreCase(arg[0], "justify-wargoal") || equalsIgnoreCase(arg[0], "justify-cb")) { //$justify-wargoal <@user>
						if (arg.length == 3) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							justifyWar(target_user, receiving_user, arg[2], message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to justify a wargoal on?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."],
									["text", "**Which CB would you like to use in order to justify a war?** Type `" + bot_prefix + "view-cb <@user>` for a valid list of casus belli."]
								],
								'justifyWar(author_id, arg[0], arg[1], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "proclaim-guarantee") || equalsIgnoreCase(arg[0], "guarantee-independence")) { //$proclaim-guarantee <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							proclaimGuarantee(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Who's independence would you like to guarantee?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'proclaimGuarantee(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "revoke-guarantee") || equalsIgnoreCase(arg[0], "stop-guaranteeing-independence")) { //$revoke-guarantee <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							revokeGuarantee(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Who's guarantee of independence would you wish to revoke?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'revokeGuarantee(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "rival") || equalsIgnoreCase(arg[0], "declare-rivalry")) { //$declare-rivalry <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							rival(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Who would you like to declare a rivalry with?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'rival(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "vassalise")) { //$vassalise <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							vassalise(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Who would you like to vassalise?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'vassalise(author_id, arg[0], msg);'
							);
						}
					}
				
					if (equalsIgnoreCase(arg[0], "view-cb")) { //$view-cb <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							printCBs(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping the user that you would wish to see your CBs for.**"]
								],
								'printCBs(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "view-diplomacy") || equalsIgnoreCase(arg[0], "diplomacy-view")) { //$view-diplomacy <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							viewDiplomacy(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["text", "**Who's diplomatic ties would you like to see?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'viewDiplomacy(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "view-war")) { //$view-war <war name>
						var target_user = returnMention(user_id);
						if (arg.length == 2) {
							printWar(target_user, arg[1], message);
						} else {
							getArguments(message,
								[
									["text", "**Please enter the name of the conflict you would like to view.** Type `" + bot_prefix + "war-list` for a list of valid conflicts."]
								],
								'printWar(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "war-list")) { //$war-list
						printWars(message);
					}
				}
				
				//Interface and Modifiers Screen
				{
					if (equalsIgnoreCase(arg[0], "budget")) { //$budget <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 1);
						} else if (arg.length == 2) {
							var target_user = returnMention(arg[1]);
							printInterface(target_user, message, 1);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping a user:**"]
								],
								'printInterface(arg[0], msg, 1);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "colonisation") || equalsIgnoreCase(arg[0], "expeditions")) { //$expeditions <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 8);
						} else if (arg.length == 2) {
							var target_user = returnMention(arg[1]);
							printInterface(target_user, message, 8);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping a user:**"]
								],
								'printInterface(arg[0], msg, 7);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "diplomacy")) { //$diplomacy <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 7);
						} else if (arg.length == 2) {
							var target_user = returnMention(arg[1]);
							printInterface(target_user, message, 7);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping a user:**"]
								],
								'printInterface(arg[0], msg, 6);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "economy")) { //$economy <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 2);
						} else if (arg.length == 2) {
							var target_user = returnMention(arg[1]);
							printInterface(target_user, message, 2);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping a user:**"]
								],
								'printInterface(arg[0], msg, 2);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "military")) { //$military <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 9);
						} else if (arg.length == 2) {
							var target_user = returnMention(arg[1]);
							printInterface(target_user, message, 9);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping a user:**"]
								],
								'printInterface(arg[0], msg, 8);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "modifiers")) { //$modifiers <@user>
						if (arg.length > 1) {
							var target_user = returnMention(arg[1]);
							printAllModifiers(target_user, message);
						} else {
							var target_user = returnMention(user_id);
							printAllModifiers(target_user, message);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "pops")) { //$pops <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 5);
						} else if (arg.length == 2) {
							if (arg[1] != "view") {
								var target_user = returnMention(arg[1]);
								printInterface(target_user, message, 5);
							}
						} else {
							if (arg[1] != "view") {
								getArguments(message,
									[
										["mention", "**Please ping a user:**"]
									],
									'printInterface(arg[0], msg, 5);'
								);
							}
						}
					}
					
					if (equalsIgnoreCase(arg[0], "stats") || equalsIgnoreCase(arg[0], "info") || equalsIgnoreCase(arg[0], "overview")) { //$stats <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								if (main.users[target_user].government == "") {
									message.channel.send("You don't even have a government yet!");
								} else {
									printInterface(target_user, message);
								}
							} else {
								message.channel.send("You don't even have a country yet!");
							}
						} else if (arg.length == 2) {
							var target_user = returnMention(arg[1]);
							if (main.users[target_user] != undefined) {
								if (main.users[target_user].government == "") {
									message.channel.send("The person you have specified has no government!");
								} else {
									printInterface(target_user, message);
								}
							} else {
								message.channel.send("The person you have specified doesn't even have a country!");
							}
						} else {
							getArguments(message,
								[
									["mention", "**Please ping a user:**"]
								],
								'printInterface(arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "technology") || equalsIgnoreCase(arg[0], "tech")) { //$technology <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 3);
						} else if (arg.length == 2) {
							var target_user = returnMention(arg[1]);
							printInterface(target_user, message, 3);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping a user:**"]
								],
								'printInterface(arg[0], msg, 3);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "trade")) { //$trade <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 6);
						} else if (arg.length == 2) {
							var target_user = returnMention(arg[1]);
							printInterface(target_user, message, 6);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping a user:**"]
								],
								'printInterface(arg[0], msg, 6);'
							);
						}
					}
				}
				
				//Map Rendering
				{
					if (equalsIgnoreCase(arg[0], "display-map")) { //$display-map
						var target_user = returnMention(user_id);
						displaySVG(message.channel);
					}
				}
				
				//Politics
				{
					if (equalsIgnoreCase(arg[0], "enact")) { //$enact <reform>
						if (arg.length > 1) {
							var target_user = returnMention(user_id);
							enactReform(target_user, arg[1], message);
						} else {
							getArguments(message,
								[
									["text", "**What reform would you like to enact?**"]
								],
								'enactReform(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "reforms")) { //$reforms <page>
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							printReforms(target_user, 0, message);
						} else {
							printReforms(target_user, parseInt(arg[1]), message);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "stability")) { //$stability (raise)
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							printInterface(target_user, message, 4);
						} else if (arg.length == 2) {
							if (arg[1].toLowerCase() == "raise") {
								console.log("Stability raised!");
								if (main.users[target_user] != undefined) {
									raiseStability(target_user, message);
								} else {
									message.channel.send("You must register a country first! Use " + bot_prefix + "found <name> in order to register a country.");
								}
							}
						}
					}
				}
				
				//Population
				{
					if (equalsIgnoreCase(arg[0], "add-accepted-culture")) { //$add-accepted-culture <culture>
						if (arg.length > 1) {
							var target_user = returnMention(user_id);
							addAcceptedCulture(target_user, arg[1], message);
						} else {
							getArguments(message,
								[
									["text", "**What culture would you like to assimilate?**\nType `" + bot_prefix + "culture` for a list of valid cultures."]
								],
								'addAcceptedCulture(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "assimilate")) { //$assimilate <province> <culture>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								assimilate(target_user, arg[1], main.users[target_user].culture, message);
							}
						} else if (arg.length == 3) {
							var target_user = returnMention(user_id);
							assimilate(target_user, arg[1], arg[2], message);
						} else {
							getArguments(message,
								[
									["text", "**Which province would you like to assimilate? (Specify a Province ID).**"],
									["text", "**Which culture would you like to assimilate it to? (Specify an accepted culture).**\nType `" + bot_prefix + "culture` for a list of accepted cultures."]
								],
								'assimilate(author_id, arg[0], arg[1], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "culture")) { //$culture
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printCultures(target_user, message);
						} else if (arg.length > 1) {
							var target_user = returnMention(arg[1]);
							printCultures(target_user, message);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "pops")) { //$pops
						if (arg.length == 2) {
							if (arg[1].toLowerCase() == "view") {
								var target_user = returnMention(user_id);
								viewPops(target_user, message);
							}
						} else if (arg.length == 3) {
							if (arg[1].toLowerCase() == "view") {
								var target_user = returnMention(arg[2]);
								viewPops(target_user, message);
							}
						}
					}
				
					if (equalsIgnoreCase(arg[0], "remove-accepted-culture")) { //$remove-accepted-culture <name>
						if (arg.length > 1) {
							var target_user = returnMention(user_id);
							removeAcceptedCulture(target_user, arg[1], message);
						} else {
							getArguments(message,
								[
									["text", "**What minority would you like to oppress?**\nType `" + bot_prefix + "culture` for a list of valid cultures."]
								],
								'removeAcceptedCulture(author_id, arg[0], msg);'
							);
						}
					}
				}
			
				//Technologies
				{
					if (equalsIgnoreCase(arg[0], "add-research-queue")) { //$add-research-queue
						if (arg.length > 1) {
							var target_user = returnMention(user_id);
							addResearchQueue(target_user, arg[1], message);
						} else {
							getArguments(message,
								[
									["text", "**What do you want to add to your research queue?**\nType `" + bot_prefix + "research list` for a list of valid technologies."]
								],
								'addResearchQueue(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "cancel-research") || equalsIgnoreCase(arg[0], "research-cancel")) { //$cancel-research
						if (arg.length > 1) {
							var target_user = returnMention(user_id);
							cancelResearch(user_id, parseInt(arg[1]), message);
						} else {
							getArguments(message,
								[
									["number", "**Which research slot would you like to free up**\nType `" + bot_prefix + "research list` for a list of valid research slots."]
								],
								'cancelResearch(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "cancel-research-queue") || equalsIgnoreCase(arg[0], "remove-research-queue")) { //$remove-research-queue
						if (arg.length > 1) {
							var target_user = returnMention(user_id);
							removeResearchQueue(target_user, arg[1], message);
						} else {
							getArguments(message,
								[
									["number", "**Which research slot do you wish to free up?**\nType `" + bot_prefix + "research-queue` for a list of valid slot IDs.", "minimum: 0", "maximum: 20"]
								],
								'removeResearchQueue(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "research")) { //$research <option>
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							printResearch(target_user, message);
						} else if (arg.length == 2) {
							if (arg[1] == "list") {
								printTechList(target_user, message);
							} else {
								research(target_user, arg[1], message);
							}
						} else {
							getArguments(message,
								[
									["text", "**What would you like to research?**\nType `" + bot_prefix + "research list` for a list of valid technologies."]
								],
								'research(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "research-queue")) { //$research-queue <@user>
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							printResearchQueue(target_user, message);
						} else {
							target_user = returnMention(arg[1]);
							printResearchQueue(target_user, message);
						}
					}
				}
				
				//Trade
				{
					if (equalsIgnoreCase(arg[0], "auto-trade")) { //$auto-trade <@user> [number] <resource>
						var target_user = returnMention(user_id);
						if (arg.length == 3) {
							autoTrade(target_user, returnMention(arg[1]), 1, arg[3], message);
						} else if (arg.length > 3) {
							autoTrade(target_user, returnMention(arg[1]), parseInt(arg[2]), arg[3], message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to send items to?**\nType `" + bot_prefix + "diplomacy` for a list of valid countries."],
									["text", "**What resource would you like to send to this user?**\nType `" + bot_prefix + "inv` for a list of valid resources."],
									["number", "**How much of this item would you like to send?**"]
								],
								'autoTrade(author_id, arg[0], arg[2], arg[1], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "auto-trades")) { //$auto-trades [@user]
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							printAutoTrades(target_user, message);
						} else {
							target_user = returnMention(arg[1]);
							printAutoTrades(target_user, message);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "exports") || equalsIgnoreCase(arg[0], "list-exports")) { //$exports [@user]
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							printExports(target_user, message);
						} else {
							target_user = returnMention(arg[1]);
							printExports(target_user, message);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "imports") || equalsIgnoreCase(arg[0], "list-imports")) { //$imports [@user]
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							printImports(target_user, message);
						} else {
							target_user = returnMention(arg[1]);
							printImports(target_user, message);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "remove-auto-trade") || equalsIgnoreCase(arg[0], "cancel-auto-trade")) { //$cancel-auto-trade <number>
						var target_user = returnMention(user_id);
						if (arg.length > 1) {
							cancelAutoTrade(target_user, parseInt(arg[1]), message);
						} else {
							getArguments(message,
								[
									["number", "**Please type the Auto-Trade ID of the automatic trade you would like to cancel.**\nType `" + bot_prefix + "auto-trades` for a list of valid IDs."]
								],
								'cancelAutoTrade(author_id, arg[0], msg);'
							);
						}
					}
				}
			}
		}
		
		//Config commands
		{
			if (hasRole(message, authorised_role)) {
				if (equalsIgnoreCase(arg[0], "set-announcements-channel")) { //$set-announcements-channel <channel id>
					if (arg[1] != undefined) {
						announcements_channel = arg[1];
						saveConfig();
						readConfig();
						message.channel.send("The announcements channel has been set to the following channel ID: " + arg[1] + ".\nIf the prefix doesn't work, try typing the command again.")
						announcements_channel = arg[1];
						saveConfig();
						readConfig();
					}
				}
				if (equalsIgnoreCase(arg[0], "set-map-channel")) { //$set-map-channel <channel id>
					if (arg[1] != undefined) {
						map_channel = arg[1];
						saveConfig();
						readConfig();
						message.channel.send("The map channel has been set to the following channel ID: " + arg[1] + ".\nIf the prefix doesn't work, try typing the command again.")
						map_channel = arg[1];
						saveConfig();
						readConfig();
					}
				}
				if (equalsIgnoreCase(arg[0], "set-prefix")) { //$set-prefix <prefix>
					if (arg[1] != undefined) {
						bot_prefix = arg[1];
						saveConfig();
						readConfig();
						message.channel.send("The bot prefix has been changed to " + arg[1] + ".\nIf the prefix doesn't work, try typing the command again.");
						help = rawhelp.toString().replace(/@/g, bot_prefix);
						
						bot_prefix = arg[1];
						saveConfig();
						readConfig();
						help = rawhelp.toString().replace(/@/g, bot_prefix);
					}
				}
				if (equalsIgnoreCase(arg[0], "set-round-time")) { //$set-round-time <seconds>
					if (arg[1] != undefined) {
						turn_timer = arg[1];
						saveConfig();
						readConfig();
						message.channel.send("Turns are now " + arg[1] + " seconds long.\nIf the prefix doesn't work, try typing the command again.");
						
						turn_timer = arg[1];
						saveConfig();
						readConfig();
					}
				}
				if (equalsIgnoreCase(arg[0], "reset-rounds")) { //$reset-rounds
					main.roundCount = 0;
					message.channel.send("Server rounds have been reset!");
				}
			}
		}
	}
})
